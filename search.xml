<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Actor 模型简介</title>
    <url>/blogs/actor-introduce.html</url>
    <content><![CDATA[<h1 id="Actor-模型简介"><a href="#Actor-模型简介" class="headerlink" title="Actor 模型简介"></a>Actor 模型简介</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢~~</p>
<p>Actor 模型 = 数据 + 行为 + 消息</p>
<p>Actor 是单线程模型，所以 Actor 的内部数据及状态只能由自身进行修改。类似于 Redis 。</p>
<p>一个 Actor 向另一个 Actor 发送消息时，会将消息发送到目标 Actor 的 mailbox 中，目标 Actor 会从 mailbox 中选取数据进行消费。</p>
<h5 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h5><ul>
<li><a href="https://juejin.cn/post/6844903929814188045">函数响应式编程思想（FRP）</a></li>
</ul>
]]></content>
      <tags>
        <tag>响应式编程</tag>
      </tags>
  </entry>
  <entry>
    <title>AI 常用名词解释</title>
    <url>/blogs/ai-common-vocabulary.html</url>
    <content><![CDATA[<h1 id="AI-常用名词解释"><a href="#AI-常用名词解释" class="headerlink" title="AI 常用名词解释"></a>AI 常用名词解释</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢~~</p>
<h5 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h5>]]></content>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习 - 有监督学习</title>
    <url>/blogs/ai-supervised-learning.html</url>
    <content><![CDATA[<h1 id="机器学习-有监督学习"><a href="#机器学习-有监督学习" class="headerlink" title="机器学习 - 有监督学习"></a>机器学习 - 有监督学习</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢~~</p>
<h5 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h5>]]></content>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习 SVM 支持向量机</title>
    <url>/blogs/ai-svm.html</url>
    <content><![CDATA[<h1 id="机器学习-SVM-支持向量机"><a href="#机器学习-SVM-支持向量机" class="headerlink" title="机器学习 SVM 支持向量机"></a>机器学习 SVM 支持向量机</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢~~</p>
<h5 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h5>]]></content>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习 目标函数简介</title>
    <url>/blogs/ai-target-function.html</url>
    <content><![CDATA[<h1 id="机器学习-目标函数简介"><a href="#机器学习-目标函数简介" class="headerlink" title="机器学习 目标函数简介"></a>机器学习 目标函数简介</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢~~</p>
<h5 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h5>]]></content>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解 SpringBoot 注解 @ShellMethod</title>
    <url>/blogs/annotation-shellmethod.html</url>
    <content><![CDATA[<h1 id="深入理解-SpringBoot-注解-ShellMethod"><a href="#深入理解-SpringBoot-注解-ShellMethod" class="headerlink" title="深入理解 SpringBoot 注解 @ShellMethod"></a>深入理解 SpringBoot 注解 @ShellMethod</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢~~</p>
<p><code>@ShellMethod</code> 将一个方法声明为 Shell 命令。默认情况下：</p>
<ol>
<li>方法名为命令名称</li>
<li>类名称为 <code>shell</code> 所属分组</li>
<li>springshell 默认将驼峰方法名用 <code>-</code> 连接符替换<blockquote>
<p>caculateSum -&gt; caculate-sum</p>
</blockquote>
</li>
</ol>
<h2 id="一-定义-shell-属性"><a href="#一-定义-shell-属性" class="headerlink" title="一. 定义 shell 属性"></a>一. 定义 shell 属性</h2><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@ShellMethod</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"caculate two value sum"</span><span class="token punctuation">,</span> key <span class="token operator">=</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span><span class="token string">"add"</span><span class="token punctuation">,</span><span class="token string">"sum"</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">,</span> group <span class="token operator">=</span> <span class="token string">"group1"</span><span class="token punctuation">,</span> prefix <span class="token operator">=</span> <span class="token string">"-"</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">sum</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span>
<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre>
<h2 id="二-查看分组名"><a href="#二-查看分组名" class="headerlink" title="二. 查看分组名"></a>二. 查看分组名</h2><p>在终端，使用  help 命令，查看更多信息。</p>
<pre class=" language-shell"><code class="language-shell">help</code></pre>
<h2 id="三-方法调用"><a href="#三-方法调用" class="headerlink" title="三. 方法调用"></a>三. 方法调用</h2><pre class=" language-shell"><code class="language-shell">shell:>add 2 1
3
shell:>sum 2 1
3</code></pre>
<p>带参调用</p>
<pre class=" language-shell"><code class="language-shell">shell:>add -a 2 -b 1
3</code></pre>
<h5 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h5>]]></content>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title>算法 - 基础算法简介</title>
    <url>/blogs/basic-suanfa.html</url>
    <content><![CDATA[<h1 id="算法-基础算法简介"><a href="#算法-基础算法简介" class="headerlink" title="算法 - 基础算法简介"></a>算法 - 基础算法简介</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢 ~~</p>
<h5 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h5>]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>books-gitbook-developer</title>
    <url>/blogs/books-gitbook-developer.html</url>
    <content><![CDATA[<h1 id="books-gitbook-developer"><a href="#books-gitbook-developer" class="headerlink" title="books-gitbook-developer"></a>books-gitbook-developer</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢 ~~</p>
<h5 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h5><ul>
<li><p><a href="https://developer.gitbook.com/">GitBook Developer</a></p>
</li>
<li><p><a href="https://segmentfault.com/a/1190000005859901">Gitbook简易教程</a></p>
</li>
</ul>
]]></content>
      <tags>
        <tag>书籍资料</tag>
      </tags>
  </entry>
  <entry>
    <title>books-webpack</title>
    <url>/blogs/books-webpack.html</url>
    <content><![CDATA[<h1 id="books-webpack"><a href="#books-webpack" class="headerlink" title="books-webpack"></a>books-webpack</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢 ~~</p>
<h5 id="Webpack-GitBook-书籍地址"><a href="#Webpack-GitBook-书籍地址" class="headerlink" title="Webpack GitBook 书籍地址"></a>Webpack GitBook 书籍地址</h5><ul>
<li><a href="http://webpack.wuhaolin.cn/">GitBook - Webpack</a></li>
</ul>
]]></content>
      <tags>
        <tag>书籍资料</tag>
      </tags>
  </entry>
  <entry>
    <title>GitHub 集成 Travis-CI Maven 项目</title>
    <url>/blogs/ci-travis.html</url>
    <content><![CDATA[<h1 id="GitHub-集成-Travis-CI-Maven-项目"><a href="#GitHub-集成-Travis-CI-Maven-项目" class="headerlink" title="GitHub 集成 Travis-CI Maven 项目"></a>GitHub 集成 Travis-CI Maven 项目</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢~~</p>
<p><code>GitHub</code> 开源项目的集成，可以使用的工具很多，以下介绍 <code>GitHub</code> 与 <code>Travis-CI</code> 的集成。 </p>
<p>目前，<code>Travis-CI</code> 存在两个域名地址，<code>travis-ci.org</code> 与 <code>travis-ci.com</code>。<code>.org</code> 即将被弃用，目前已经存在的项目可以无缝迁移至 <code>.com</code>。迁移完成后，之前的历史记录不会被迁移，新迁移的项目，将会在该项目迁移后的第一次指定集成分支提交代码后，进行集成工作。</p>
<h2 id="一-新建-travis-yml"><a href="#一-新建-travis-yml" class="headerlink" title="一. 新建 .travis.yml"></a>一. 新建 <code>.travis.yml</code></h2><p>在需要使用 travis 的项目的根目录，新建 <code>.travsi.yml</code> 文件。</p>
<p><code>Travsi</code> 可以与多种开发语言及多种开发工具进行配合使用。具体使用方式，开参考官方文档。以下简介几种集成。</p>
<h3 id="1-Maven"><a href="#1-Maven" class="headerlink" title="1. Maven"></a>1. Maven</h3><pre class=" language-yml"><code class="language-yml">language: java

jdk:
  - openjdk8

cache:
  directories:
    - '$HOME/.m2/repository'

before_install:

script:
  - mvn clean package -DskipTests=true
  ## Codecov CI
  - mvn cobertura:cobertura

after_success:
  ## Codecov CI
  - bash <(curl -s https://codecov.io/bash)
  - cd ./target
  - git init
  - git config user.name "Starrier"
  - git config user.email "starrier@starrier.com"
  - git add .
  - git commit -m "travis-ci"
  - git push --force --quiet "https://$&#123;GITHUB_TOKEN&#125;@$&#123;GH_REF&#125;" master:master

## 指定需要进行集成的代码分支

branches:
  only:
    - master

## 环境配置，可以设置在  travis-ci 的界面中，作为环境变量植入
env:
  global:
    - GH_REF=https://github.com/Starrier/commons.git</code></pre>
<h5 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h5>]]></content>
      <tags>
        <tag>DevOps</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络 | 图解 DNS &amp; HTTPDNS 原理</title>
    <url>/blogs/cn-dns.html</url>
    <content><![CDATA[<h1 id="计算机网络-图解-DNS-amp-HTTPDNS-原理"><a href="#计算机网络-图解-DNS-amp-HTTPDNS-原理" class="headerlink" title="计算机网络 | 图解 DNS &amp; HTTPDNS 原理"></a>计算机网络 | 图解 DNS &amp; HTTPDNS 原理</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢 ~~</p>
<h5 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h5><ul>
<li><a href="https://juejin.cn/post/6884183177926033416">计算机网络 | 图解 DNS &amp; HTTPDNS 原理</a></li>
</ul>
]]></content>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络 - 基础知识点</title>
    <url>/blogs/cn-basic-introduce.html</url>
    <content><![CDATA[<h1 id="计算机网络-基础知识点"><a href="#计算机网络-基础知识点" class="headerlink" title="计算机网络 - 基础知识点"></a>计算机网络 - 基础知识点</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢 ~~</p>
<h5 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h5><ul>
<li><a href="https://www.cnblogs.com/aspirant/p/9172336.html">SOA,SOAP,RPC,以及 RPC协议与 REST 协议之间的关系(搜狗)</a></li>
</ul>
]]></content>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>osi-tcp-ip</title>
    <url>/blogs/cn-osi-tcp-ip.html</url>
    <content><![CDATA[<h1 id="计算机网络-网络模型"><a href="#计算机网络-网络模型" class="headerlink" title="计算机网络 - 网络模型"></a>计算机网络 - 网络模型</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢 ~~</p>
<h5 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h5><ul>
<li><a href="https://blog.csdn.net/huangjin0507/article/details/51613561">OSI七层与TCP/IP五层网络架构详解</a></li>
</ul>
]]></content>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>nw-tcp-ip</title>
    <url>/blogs/cn-tcp-ip.html</url>
    <content><![CDATA[<h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢 ~~</p>
<h5 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h5><ul>
<li><a href="https://blog.csdn.net/jtracydy/article/details/52366461">TCP拥塞控制-慢启动、拥塞避免、快重传、快启动</a></li>
</ul>
]]></content>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解 Http Https 原理</title>
    <url>/blogs/cn-http-https.html</url>
    <content><![CDATA[<h1 id="深入理解-Http-Https-原理"><a href="#深入理解-Http-Https-原理" class="headerlink" title="深入理解 Http Https 原理"></a>深入理解 Http Https 原理</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢 ~~</p>
<h3 id="Https-工作流程"><a href="#Https-工作流程" class="headerlink" title="Https 工作流程"></a>Https 工作流程</h3><ol>
<li><p>Client 发起 Https 请求到 Server 的 443 端口。Server 将 CA 颁发的证书返回。</p>
</li>
<li><p>Client 校验返回的证书是否有效。如果证书校验失败，则会出现高进</p>
</li>
</ol>
<h5 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h5><ul>
<li><p><a href="https://juejin.cn/post/6844903830916694030">深入理解HTTPS工作原理</a></p>
</li>
<li><p><a href="https://juejin.cn/post/6844903830916694030#heading-2">Https</a></p>
</li>
</ul>
]]></content>
      <tags>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络 TPC 链接</title>
    <url>/blogs/cn-tcp-link.html</url>
    <content><![CDATA[<h1 id="计算机网络-TPC-链接"><a href="#计算机网络-TPC-链接" class="headerlink" title="计算机网络 TPC 链接"></a>计算机网络 TPC 链接</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢 ~~</p>
<h5 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h5><ul>
<li><a href="https://blog.csdn.net/qq_41878620/article/details/105628943#:~:text=%E9%A6%96%E5%85%88%E8%AF%B4%E6%98%8E%E4%BB%80%E4%B9%88%E6%98%AFMSL,2%E5%80%8DMSL%E7%9A%84%E6%97%B6%E9%97%B4%E3%80%82&text=%E8%BF%99%E6%81%B0%E6%81%B0%E5%B0%B1%E6%98%AF2MSL(%20Maximum%20Segment%20Life)%E3%80%82">TCP第四次挥手后为什么要等待2MSL后才断开链接？等待时间为什么是2MSL？</a></li>
</ul>
]]></content>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>TCP  发送</title>
    <url>/blogs/cn-tcp-reset.html</url>
    <content><![CDATA[<h1 id="TCP-发送"><a href="#TCP-发送" class="headerlink" title="TCP  发送"></a>TCP  发送</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢 ~~</p>
<h5 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h5><ul>
<li><a href=""></a></li>
</ul>
]]></content>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>日志记录最佳实践</title>
    <url>/blogs/code-programming-log.html</url>
    <content><![CDATA[<h1 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢 ~~</p>
<h5 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h5><ul>
<li><a href="https://tech.meituan.com/2021/09/16/operational-logbook.html">如何优雅地记录操作日志？</a></li>
</ul>
]]></content>
      <tags>
        <tag>log</tag>
      </tags>
  </entry>
  <entry>
    <title>代码编程规范</title>
    <url>/blogs/code-programming-specification.html</url>
    <content><![CDATA[<h1 id="代码编程规范"><a href="#代码编程规范" class="headerlink" title="代码编程规范"></a>代码编程规范</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢 ~~</p>
<h5 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h5>]]></content>
      <tags>
        <tag>规范</tag>
      </tags>
  </entry>
  <entry>
    <title>Guava - MultiSet 原理与实战</title>
    <url>/blogs/commons-utils-guava-multiset.html</url>
    <content><![CDATA[<h1 id="Guava-MultiSet-原理与实战"><a href="#Guava-MultiSet-原理与实战" class="headerlink" title="Guava - MultiSet 原理与实战"></a>Guava - MultiSet 原理与实战</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢~~</p>
<p>函数签名：</p>
<pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@GwtCompatible</span>
<span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Multiset</span><span class="token operator">&lt;</span>E<span class="token operator">></span> <span class="token keyword">extends</span> <span class="token class-name">Collection</span><span class="token operator">&lt;</span>E<span class="token operator">></span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre>
<p><code>MultiSet</code> 可以跟踪每种对象的数量，所以可以用来进行数字统计。</p>
<p>常规的 <code>Java</code> 方法：</p>
<pre class=" language-java"><code class="language-java"> Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Integer<span class="token operator">></span> map1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

 List<span class="token operator">&lt;</span>String<span class="token operator">></span> wordList <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span><span class="token string">"the"</span><span class="token punctuation">,</span><span class="token string">"b"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token keyword">for</span> <span class="token punctuation">(</span>String word <span class="token operator">:</span> wordList<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
      Integer count <span class="token operator">=</span>  map1<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>word<span class="token punctuation">)</span><span class="token punctuation">;</span>
      map1<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>word<span class="token punctuation">,</span><span class="token punctuation">(</span>count <span class="token operator">==</span> null<span class="token punctuation">)</span><span class="token operator">?</span><span class="token number">1</span><span class="token operator">:</span>count <span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
    Integer count <span class="token operator">=</span> map1<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"the"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>count<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//1</span></code></pre>
<p>如果使用 <code>MultiSet</code>：</p>
<h5 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h5>]]></content>
      <tags>
        <tag>开发工具</tag>
      </tags>
  </entry>
  <entry>
    <title>产生随机数的三种方式</title>
    <url>/blogs/create-random-num.html</url>
    <content><![CDATA[<h1 id="产生随机数的三种方式"><a href="#产生随机数的三种方式" class="headerlink" title="产生随机数的三种方式"></a>产生随机数的三种方式</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢 ~~</p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul>
<li><a href="https://www.cnblogs.com/blogxjc/p/9687297.html">Java的三种随机数生成方式</a></li>
</ul>
]]></content>
      <tags>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机基础</title>
    <url>/blogs/cs-basic.html</url>
    <content><![CDATA[<h1 id="计算机基础"><a href="#计算机基础" class="headerlink" title="计算机基础"></a>计算机基础</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢 ~~</p>
<p>进程调度算法</p>
<p>先来先服务算法</p>
<p>短作业(进程)优先算法</p>
<p>时间片轮转</p>
<p>多级反馈队列调度算法</p>
<p>优先权调度算法</p>
<h5 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h5><ul>
<li><a href="https://blog.csdn.net/fuzhongmin05/article/details/55802925">操作系统中常用的进程调度算法</a></li>
</ul>
]]></content>
      <tags>
        <tag>计算机基础</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解同步队列</title>
    <url>/blogs/datastruct-SynchronousQueue.html</url>
    <content><![CDATA[<h1 id="深入理解同步队列"><a href="#深入理解同步队列" class="headerlink" title="深入理解同步队列"></a>深入理解同步队列</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢 ~~</p>
<h5 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h5><ul>
<li><a href=""></a></li>
</ul>
]]></content>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构 -ArrayBlockingQueue</title>
    <url>/blogs/datastruct-arrayblockingqueue.html</url>
    <content><![CDATA[<h1 id="数据结构-ArrayBlockingQueue"><a href="#数据结构-ArrayBlockingQueue" class="headerlink" title="数据结构 ArrayBlockingQueue"></a>数据结构 ArrayBlockingQueue</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢 ~~</p>
<p>有界阻塞队。底层采用数据，一旦初始化，就不可以改变容量大小。并发度使用可重入锁控制。对于插入和读取操作，都需要获取到锁才可以。可配置是否是公平锁，<br>配置公平锁会影响性能。</p>
<h5 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h5><ul>
<li><a href=""></a></li>
</ul>
]]></content>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构-FST-有限状态机</title>
    <url>/blogs/datastruct-fst.html</url>
    <content><![CDATA[<h1 id="数据结构-FST-有限状态机"><a href="#数据结构-FST-有限状态机" class="headerlink" title="数据结构-FST-有限状态机"></a>数据结构-FST-有限状态机</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢 ~~</p>
<h5 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h5>]]></content>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构 - LinkedBlockingQueue</title>
    <url>/blogs/datastruct-linkedblockingqueue.html</url>
    <content><![CDATA[<h1 id="数据结构-LinkedBlockingQueue"><a href="#数据结构-LinkedBlockingQueue" class="headerlink" title="数据结构 - LinkedBlockingQueue"></a>数据结构 - LinkedBlockingQueue</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢 ~~</p>
<p>有界队列 单向链表实现的。默认和最大长度都是 Integer.Max_Value。按照先进先出的顺序排序。</p>
<h5 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h5><ul>
<li><a href="https://blog.csdn.net/tonywu1992/article/details/83419448">【细谈Java并发】谈谈LinkedBlockingQueue</a></li>
</ul>
]]></content>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构 - 红黑树</title>
    <url>/blogs/datastruct-red-black-tree.html</url>
    <content><![CDATA[<h1 id="数据结构-红黑树"><a href="#数据结构-红黑树" class="headerlink" title="数据结构 - 红黑树"></a>数据结构 - 红黑树</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢 ~~</p>
<p>时间复杂度和空间复杂度</p>
<h5 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h5><ul>
<li><a href=""></a></li>
</ul>
]]></content>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>datastruce-spatial-index-geohash</title>
    <url>/blogs/datastruct-spatial-index-geohash.html</url>
    <content><![CDATA[<h1 id="空间索引-GeoHash-数据结构"><a href="#空间索引-GeoHash-数据结构" class="headerlink" title="空间索引 - GeoHash 数据结构"></a>空间索引 - GeoHash 数据结构</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢~~</p>
]]></content>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>空间索引 - Quard-Tree 四叉树数据结构</title>
    <url>/blogs/datastruct-spatial-index-quad-tree.html</url>
    <content><![CDATA[<h1 id="空间索引-Quard-Tree-四叉树数据结构"><a href="#空间索引-Quard-Tree-四叉树数据结构" class="headerlink" title="空间索引 - Quard-Tree 四叉树数据结构"></a>空间索引 - Quard-Tree 四叉树数据结构</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢~~</p>
]]></content>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>空间索引 - R-Tree 四叉树数据结构</title>
    <url>/blogs/datastruct-spatial-index-r-tree.html</url>
    <content><![CDATA[<h1 id="空间索引-R-Tree-四叉树数据结构"><a href="#空间索引-R-Tree-四叉树数据结构" class="headerlink" title="空间索引 - R-Tree 四叉树数据结构"></a>空间索引 - R-Tree 四叉树数据结构</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢~~</p>
]]></content>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>空间索引</title>
    <url>/blogs/datastruct-spatial-index.html</url>
    <content><![CDATA[<h1 id="空间索引"><a href="#空间索引" class="headerlink" title="空间索引"></a>空间索引</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢~~</p>
<h4 id="一-概念"><a href="#一-概念" class="headerlink" title="一. 概念"></a>一. 概念</h4><p><strong>空间索引</strong>（Spatial Index）是指依据空间对象的位置和形状或空间对象之间的某种空间关系按一定的顺序排列的一种数据结构，其中包含空间对象的概要信息，如对象的标识、外接矩形及指向空间对象实体的指针。</p>
<h4 id="二-数据结构"><a href="#二-数据结构" class="headerlink" title="二. 数据结构"></a>二. 数据结构</h4><ol>
<li>GeoHash</li>
<li>R-Tree</li>
<li>Quad-Tree</li>
</ol>
]]></content>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构 - Tire - 字典树</title>
    <url>/blogs/datastruct-tire.html</url>
    <content><![CDATA[<h1 id="数据结构-Tire-字典树"><a href="#数据结构-Tire-字典树" class="headerlink" title="数据结构 - Tire - 字典树"></a>数据结构 - Tire - 字典树</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢~~</p>
]]></content>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>领域驱动 CQRS</title>
    <url>/blogs/ddd-cqrs.html</url>
    <content><![CDATA[<h1 id="领域驱动-CQRS"><a href="#领域驱动-CQRS" class="headerlink" title="领域驱动 CQRS"></a>领域驱动 CQRS</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢 ~~</p>
<h5 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h5><ul>
<li><p><a href="https://www.cnblogs.com/cnblogsfans/p/4551990.html">领域驱动设计系列 (六)：CQRS</a></p>
</li>
<li><p><a href="http://agiledon.github.io/blog/2012/12/31/basic-understanding-on-cqrs/">对CQRS的基础理解</a></p>
</li>
</ul>
]]></content>
      <tags>
        <tag>DDD</tag>
      </tags>
  </entry>
  <entry>
    <title>反模式</title>
    <url>/blogs/design-anti-pattern.html</url>
    <content><![CDATA[<h1 id="反模式"><a href="#反模式" class="headerlink" title="反模式"></a>反模式</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢 ~~</p>
<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p><code>anti-patterns</code> 是软件开发中被认为是错误的编程实践的某些模式。</p>
<h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><ol>
<li><a href="https://blog.csdn.net/jiangpingjiangping/article/details/78067595">设计模式杂谈——模式与反模式之争</a></li>
</ol>
]]></content>
      <tags>
        <tag>desing</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式理论 2PC 详解</title>
    <url>/blogs/distribute-2pc.html</url>
    <content><![CDATA[<h1 id="分布式理论-2PC-详解"><a href="#分布式理论-2PC-详解" class="headerlink" title="分布式理论 - 2PC 详解"></a>分布式理论 - 2PC 详解</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢~~</p>
<p><strong>注意</strong></p>
<p>高并发中使用分布式事务的 2PC 协议应该遵循如下协议：</p>
<ol>
<li>能不用 2 PC 的精良不用，2PC 协议要有提交请求阶段，提交阶段，而每个阶段也要有协调器分别于多个事务参与者的应答，复杂度高，性能也受到挑战。</li>
<li>要获得事务强一致性，也要在性能和一致性上做折中，比如加上超时机制，阶段性补偿机制等。 </li>
</ol>
]]></content>
      <tags>
        <tag>分布式基础</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式 - 桥接模式 详解</title>
    <url>/blogs/design-pattern-bridge-pattern.html</url>
    <content><![CDATA[<h1 id="设计模式-桥接模式-详解"><a href="#设计模式-桥接模式-详解" class="headerlink" title="设计模式 - 桥接模式 详解"></a>设计模式 - 桥接模式 详解</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢~~</p>
]]></content>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式理论 3PC</title>
    <url>/blogs/distribute-3pc.html</url>
    <content><![CDATA[<h1 id="分布式理论-3PC"><a href="#分布式理论-3PC" class="headerlink" title="分布式理论 3PC"></a>分布式理论 3PC</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢~~</p>
]]></content>
      <tags>
        <tag>分布式基础</tag>
      </tags>
  </entry>
  <entry>
    <title>distribute-load-balance</title>
    <url>/blogs/distribute-load-balance.html</url>
    <content><![CDATA[<h1 id="分布式系统-负载均衡原理及算法实现"><a href="#分布式系统-负载均衡原理及算法实现" class="headerlink" title="分布式系统 - 负载均衡原理及算法实现"></a>分布式系统 - 负载均衡原理及算法实现</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢 ~~</p>
<p>常用的负载均衡算法有：</p>
<p>随机算法<br>加权随机算法<br>轮询算法<br>加权轮询算法<br>最小时延算法<br>一致性hash算法</p>
<h2 id="一致性-Hash-性质"><a href="#一致性-Hash-性质" class="headerlink" title="一致性 Hash 性质"></a>一致性 Hash 性质</h2><h3 id="平衡性"><a href="#平衡性" class="headerlink" title="平衡性"></a>平衡性</h3><h3 id="单调性"><a href="#单调性" class="headerlink" title="单调性"></a>单调性</h3><h3 id="分散性"><a href="#分散性" class="headerlink" title="分散性"></a>分散性</h3><h3 id="负载"><a href="#负载" class="headerlink" title="负载"></a>负载</h3><h3 id="平滑线"><a href="#平滑线" class="headerlink" title="平滑线"></a>平滑线</h3><p>平滑性是指缓存服务器的数据平滑改变和缓存对象的平滑改变一致。</p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><h5 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h5><p>一致性 Hash 算法在服务节点太少时，容易因为节点分布不均匀导致数据倾斜问题。</p>
<h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><ul>
<li><p><a href="https://www.cnblogs.com/lgjlife/p/10727245.html">分布式负载均衡算法的实现</a></p>
</li>
<li><p><a href="https://blog.csdn.net/weixin_41896463/article/details/106304145">一致性 Hash （复习版）</a></p>
</li>
<li><p><a href="https://www.jianshu.com/p/d7e173d212a8">常用负载均衡策略分析</a></p>
</li>
</ul>
]]></content>
      <tags>
        <tag>分布式基础</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式理论-CAP</title>
    <url>/blogs/distribute-cap.html</url>
    <content><![CDATA[<h2 id="分布式理论-CAP"><a href="#分布式理论-CAP" class="headerlink" title="分布式理论 - CAP"></a>分布式理论 - <code>CAP</code></h2><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢~~</p>
<p><code>CAP</code> 理论指出，对于一个分布式计算系统，不可能同时满足以下三点:</p>
<ol>
<li>一致性（Consistency）：所有节点在同一时间具有相同的数据。</li>
<li>可用性（Availability）：保证每个请求不管成功或者失败都有响应。</li>
<li>分隔容忍（Partition tolerance）：系统中任意信息的丢失或失败不会影响系统的继续运作。以实际效果来说，分区相当于对通信的时限要求。系统如果不能在时限内达成数据一致性，就意味着发生了分区情况，就必须在 C 和 A 之间做抉择。</li>
</ol>
<p><code>CAP</code> 理论的核心是：一个分布式系统不可能同时很好地满足一致性、可用性和分区容错性这三个需求，最多只能同时满足两个。因此，根据 <code>CAP</code> 理论，可以将 <code>NoSQL</code> 数据库分成满足 <code>CA</code> 、<code>CP</code>、和 <code>AP</code> 的三类：</p>
<h3 id="Partition-tolerance"><a href="#Partition-tolerance" class="headerlink" title="Partition tolerance"></a><code>Partition tolerance</code></h3><p>即：分区容错</p>
<p>大多数分布式系统都分布在多个子网络。每个子网络就叫做一个区（Partition）。分区容错的意思是，区间通信可能失败。比如，一台服务器放在中国，另一台服务器放在美国，这就是两个区，它们之间可能无法通信。</p>
<p>一般来说，分区容错无法避免，因此可以认为 <code>CAP</code> 中的 <code>P</code> 总是成立的。<code>CAP</code> 理论告诉我们，剩下的 <code>C</code> 和 <code>A</code> 无法同时做到。</p>
<h3 id="Consistency"><a href="#Consistency" class="headerlink" title="Consistency"></a><code>Consistency</code></h3><p>即：一致性。写操作之后的读操作，必须返回该值。</p>
<h3 id="Availability"><a href="#Availability" class="headerlink" title="Availability"></a><code>Availability</code></h3><p>即：可用性。意思是只要收到用户的请求，服务器就必须给出响应。</p>
<h3 id="Consistency-和-Availability-的矛盾"><a href="#Consistency-和-Availability-的矛盾" class="headerlink" title="Consistency 和 Availability 的矛盾"></a><code>Consistency</code> 和 <code>Availability</code> 的矛盾</h3><p>一致性和可用性，为什么不能同时成立？</p>
<p>因为存在通信失败（即出现分区容错）。</p>
<h2 id="一致性与可用性的决择编辑"><a href="#一致性与可用性的决择编辑" class="headerlink" title="一致性与可用性的决择编辑"></a>一致性与可用性的决择编辑</h2><p><code>CAP</code> 理论就是说在分布式存储系统中，最多只能实现上面的两点。而由于当前的网络硬件肯定会出现延迟丢包等问题，所以分区容忍性是我们必须需要实现的。所以我们只能在一致性和可用性之间进行权衡，没有 <code>NoSQL</code> 系统能同时保证这三点。</p>
<p>对于 <code>web2.0</code> 网站来说，关系数据库的很多主要特性却往往无用武之地</p>
<p><strong>数据库事务一致性需求</strong></p>
<p>　　很多web实时系统并不要求严格的数据库事务，对读一致性的要求很低，有些场合对写一致性要求并不高。允许实现最终一致性。<br>数据库的写实时性和读实时性需求</p>
<p>　　对关系数据库来说，插入一条数据之后立刻查询，是肯定可以读出来这条数据的，但是对于很多web应用来说，并不要求这么高的实时性，比方说发一条消息之 后，过几秒乃至十几秒之后，我的订阅者才看到这条动态是完全可以接受的。<br>对复杂的SQL查询，特别是多表关联查询的需求 </p>
<p>　　任何大数据量的web系统，都非常忌讳多个大表的关联查询，以及复杂的数据分析类型的报表查询，特别是SNS类型的网站，从需求以及产品设计角 度，就避免了这种情况的产生。往往更多的只是单表的主键查询，以及单表的简单条件分页查询，SQL的功能被极大的弱化了。</p>
<h3 id="BASE理论"><a href="#BASE理论" class="headerlink" title="BASE理论"></a>BASE理论</h3><p>BASE 是Basically Available（基本可用）、Soft state（软状态）和Eventually consistent（最终一致性）三个短语的简写，BASE是对CAP中一致性和可用性权衡的结果，其来源于对大规模互联网系统分布式实践的结论，是基于CAP定理逐步演化而来的，其核心思想是即使无法做到强一致性（Strong consistency），但每个应用都可以根据自身的业务特点，采用适当的方式来使系统达到最终一致性（Eventual consistency）。接下来我们着重对BASE中的三要素进行详细讲解。</p>
<p>基本可用</p>
<p>基本可用是指分布式系统在出现不可预知故障的时候，允许损失部分可用性——但请注意，这绝不等价于系统不可用，以下两个就是“基本可用”的典型例子。</p>
<p>响应时间上的损失：正常情况下，一个在线搜索引擎需要0.5秒内返回给用户相应的查询结果，但由于出现异常（比如系统部分机房发生断电或断网故障），查询结果的响应时间增加到了1~2秒。<br>功能上的损失：正常情况下，在一个电子商务网站上进行购物，消费者几乎能够顺利地完成每一笔订单，但是在一些节日大促购物高峰的时候，由于消费者的购物行为激增，为了保护购物系统的稳定性，部分消费者可能会被引导到一个降级页面。<br>弱状态也称为软状态，和硬状态相对，是指允许系统中的数据存在中间状态，并认为该中间状态的存在不会影响系统的整体可用性，即允许系统在不同节点的数据副本之间进行数据听不的过程存在延时。</p>
<p>最终一致性</p>
<p>最终一致性强调的是系统中所有的数据副本，在经过一段时间的同步后，最终能够达到一个一致的状态。因此，最终一致性的本质是需要系统保证最终数据能够达到一致，而不需要实时保证系统数据的强一致性</p>
<p>亚马逊首席技术官Werner Vogels在于2008年发表的一篇文章中对最终一致性进行了非常详细的介绍。他认为最终一致性时一种特殊的弱一致性：系统能够保证在没有其他新的更新操作的情况下，数据最终一定能够达到一致的状态，因此所有客户端对系统的数据访问都能够胡渠道最新的值。同时，在没有发生故障的前提下，数据达到一致状态的时间延迟，取决于网络延迟，系统负载和数据复制方案设计等因素。</p>
<p>在实际工程实践中，最终一致性存在以下五类主要变种。</p>
<p>因果一致性：</p>
<pre><code>    因果一致性是指，如果进程A在更新完某个数据项后通知了进程B，那么进程B之后对该数据项的访问都应该能够获取到进程A更新后的最新值，并且如果进程B要对该数据项进行更新操作的话，务必基于进程A更新后的最新值，即不能发生丢失更新情况。与此同时，与进程A无因果关系的进程C的数据访问则没有这样的限制。</code></pre>
<p>读己之所写：</p>
<pre><code>    读己之所写是指，进程A更新一个数据项之后，它自己总是能够访问到更新过的最新值，而不会看到旧值。也就是说，对于单个数据获取者而言，其读取到的数据一定不会比自己上次写入的值旧。因此，读己之所写也可以看作是一种特殊的因果一致性。</code></pre>
<p>会话一致性：</p>
<pre><code>    会话一致性将对系统数据的访问过程框定在了一个会话当中：系统能保证在同一个有效的会话中实现“读己之所写”的一致性，也就是说，执行更新操作之后，客户端能够在同一个会话中始终读取到该数据项的最新值。</code></pre>
<p>单调读一致性：</p>
<pre><code>    单调读一致性是指如果一个进程从系统中读取出一个数据项的某个值后，那么系统对于该进程后续的任何数据访问都不应该返回更旧的值。</code></pre>
<p>单调写一致性：</p>
<pre><code>     单调写一致性是指，一个系统需要能够保证来自同一个进程的写操作被顺序地执行。</code></pre>
<p>以上就是最终一致性的五类常见的变种，在时间系统实践中，可以将其中的若干个变种互相结合起来，以构建一个具有最终一致性的分布式系统。事实上，可以将其中的若干个变种相互结合起来，以构建一个具有最终一致性特性的分布式系统。事实上，最终一致性并不是只有那些大型分布式系统才设计的特性，许多现代的关系型数据库都采用了最终一致性模型。在现代关系型数据库中，大多都会采用同步和异步方式来实现主备数据复制技术。在同步方式中，数据的复制国耻鞥通常是更新事务的一部分，因此在事务完成后，主备数据库的数据就会达到一致。而在异步方式中，备库的更新往往存在延时，这取决于事务日志在主备数据库之间传输的时间长短，如果传输时间过长或者甚至在日志传输过程中出现异常导致无法及时将事务应用到备库上，那么狠显然，从备库中读取的的数据将是旧的，因此就出现了不一致的情况。当然，无论是采用多次重试还是认为数据订正，关系型数据库还是能搞保证最终数据达到一致——这就是系统提供最终一致性保证的经典案例。</p>
<p>总的来说，BASE理论面向的是大型高可用可扩展的分布式系统，和传统事务的ACID特性使相反的，它完全不同于ACID的强一致性模型，而是提出通过牺牲强一致性来获得可用性，并允许数据在一段时间内是不一致的，但最终达到一致状态。但同时，在实际的分布式场景中，不同业务单元和组件对数据一致性的要求是不同的，因此在具体的分布式系统架构设计过程中，ACID特性与BASE理论往往又会结合在一起使用。</p>
<p>小结：<br>计算机系统从集中式向分布式的变革随着包括分布式网络、分布式事务和分布式数据一致性等在内的一系列问题与挑战，同时也催生了一大批诸如ACID、CAP和BASE等经典理论的快速发展。</p>
<p>与NoSQL的关系编辑<br>传统的关系型数据库在功能支持上通常很宽泛，从简单的键值查询，到复杂的多表联合查询再到事务机制的支持。而与之不同的是，NoSQL系统通常注重性能和扩展性，而非事务机制（事务就是强一致性的体现）[2]  。<br>　　传统的SQL数据库的事务通常都是支持ACID的强事务机制。A代表原子性，即在事务中执行多个操作是原子性的，要么事务中的操作全部执行，要么一个都不执行;C代表一致性，即保证进行事务的过程中整个数据加的状态是一致的，不会出现数据花掉的情况;I代表隔离性，即两个事务不会相互影响，覆盖彼此数据等;D表示持久化，即事务一量完成，那么数据应该是被写到安全的，持久化存储的设备上（比如磁盘）。<br>　　NoSQL系统仅提供对行级别的原子性保证，也就是说同时对同一个Key下的数据进行的两个操作，在实际执行的时候是会串行的执行，保证了每一个Key-Value对不会被破坏。<br>CAP的是什么关系<br>It states, that though its desirable to have Consistency, High-Availability and Partition-tolerance in every system, unfortunately no system can achieve all three at the same time.<br>在分布式系统的设计中，没有一种设计可以同时满足一致性，可用性，分区容错性 3个特性</p>
<p>注意：不要将弱一致性，最终一致性放到CAP理论里混为一谈（混淆概念的坑真多）<br>弱一致性，最终一致性 你可以认为和CAP的C一点关系也没有，因为CAP的C是更新操作完成后，任何节点看到的数据完全一致, 弱一致性。最终一致性本身和CAP的C一致性是违背的，所以你可以看到那些谎称自己系统同时具备CAP 3个特性是多么的可笑，可能国内更多的场景是：一个开放人员一旦走上讲台演讲，就立马转变为了营销人员，连最基本的理念也不要了。<br>这里有一篇标题很大的文章  cap-twelve-years-later-how-the-rules-have-changed ，实际上本文的changed更多的是在思考方式上，而本身CAP理论是没有changed的</p>
<p>为什么会是这样<br>我们来看一个简单的问题, 一个DB服务   搭建在两个机房（北京,广州)，两个DB实例同时提供写入和读取</p>
<ol>
<li><p>假设DB的更新操作是同时写北京和广州的DB都成功才返回成功<br> 在没有出现网络故障的时候，满足CA原则，C 即我的任何一个写入，更新操作成功并返回客户端完成后,分布式的所有节点在同一时间的数据完全一致， A 即我的读写操作都能够成功，但是当出现网络故障时，我不能同时保证CA，即P条件无法满足</p>
</li>
<li><p>假设DB的更新操作是只写本地机房成功就返回，通过binlog/oplog回放方式同步至侧边机房<br> 这种操作保证了在出现网络故障时,双边机房都是可以提供服务的，且读写操作都能成功，意味着他满足了AP ，但是它不满足C，因为更新操作返回成功后，双边机房的DB看到的数据会存在短暂不一致，且在网络故障时，不一致的时间差会很大（仅能保证最终一致性）</p>
</li>
<li><p>假设DB的更新操作是同时写北京和广州的DB都成功才返回成功且网络故障时提供降级服务<br> 降级服务，如停止写入，只提供读取功能，这样能保证数据是一致的，且网络故障时能提供服务，满足CP原则，但是他无法满足可用性原则</p>
</li>
</ol>
<p>选择权衡<br>通过上面的例子，我们得知，我们永远无法同时得到CAP这3个特性，那么我们怎么来权衡选择呢？<br>选择的关键点取决于业务场景</p>
<p>对于大多数互联网应用来说（如网易门户），因为机器数量庞大，部署节点分散，网络故障是常态，可用性是必须需要保证的，所以只有设置一致性来保证服务的AP，通常常见的高可用服务吹嘘5个9 6个9服务SLA稳定性就本都是放弃C选择AP</p>
<p>对于需要确保强一致性的场景，如银行，通常会权衡CA和CP模型，CA模型网络故障时完全不可用，CP模型具备部分可用性，实际的选择需要通过业务场景来权衡（并不是所有情况CP都好于CA，只能查看信息不能更新信息有时候从产品层面还不如直接拒绝服务）</p>
<p>延伸<br>BASE(Basically Available, Soft State, Eventual Consistency  基本可用、软状态、最终一致性) 对CAP AP理论的延伸, Redis等众多系统构建与这个理论之上<br>ACID  传统数据库常用的设计理念, ACID和BASE代表了两种截然相反的设计哲学，分处一致性-可用性分布图谱的两极。</p>
<h3 id="分布式系统的典型应用"><a href="#分布式系统的典型应用" class="headerlink" title="分布式系统的典型应用"></a>分布式系统的典型应用</h3><p>分布式系统是一个非常广泛的概念，以算法来分：</p>
<ol>
<li>以 leader 选举为主的一类算法：Paxos、viewstamp，就是现在的 zookeeper、Chuby 等工具的主体。</li>
<li>以分布式事务为主的一类，主要是二段提交，这些分布式数据库管理器及数据库都支持</li>
<li>以弱一致性为主的，主要代表是 Cassandra 的 W、R、N 可调节的一致性。</li>
<li>以租赁机制为主的，主要是一些分布式锁的概念，目前还没有看到纯粹的分布式锁的实现。</li>
<li>以失败探测为主的，主要是 Gossip 和 phi 失败探测算法，当然也包括简单的心跳。</li>
<li>以弱一致性、因果一致性为主。</li>
<li>以异步解耦为主，还有各类的 Queue。</li>
</ol>
]]></content>
      <tags>
        <tag>分布式基础</tag>
      </tags>
  </entry>
  <entry>
    <title>distribute-rpc-serialization</title>
    <url>/blogs/distribute-rpc-serialization.html</url>
    <content><![CDATA[<h1 id="RPC-序列化"><a href="#RPC-序列化" class="headerlink" title="RPC - 序列化"></a>RPC - 序列化</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢 ~~</p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>将内存对象转化为字节流的过程。相对的是反序列化，即将字节流转化为内存对象的过程。</p>
<p>TCP/IP协议是一个四层协议，而OSI模型却是七层协议模型。在OSI七层协议模型中展现层（Presentation Layer）的主要功能是把应用层的对象转换成一段连续的二进制串，或者反过来，把二进制串转换成应用层的对象–这两个功能就是序列化和反序列化。一般而言，TCP/IP协议的应用层对应与OSI七层协议模型的应用层，展示层和会话层，所以序列化协议属于TCP/IP协议应用层的一部分。</p>
<h2 id="为什么要序列化"><a href="#为什么要序列化" class="headerlink" title="为什么要序列化"></a>为什么要序列化</h2><p>将数据存入文件或者通过网络进行发送，就需要将数据对象转化为字节流。</p>
<p>而究竟如何进行序列化，则需要考虑各种因素，比如性能、占用空间、向前向后的兼容性、多语言支持等等。</p>
<h2 id="常见的序列化方案"><a href="#常见的序列化方案" class="headerlink" title="常见的序列化方案"></a>常见的序列化方案</h2><p>使用字符串进行编码，不同字段间指定分隔符，比如 “,” 或者 “|” 等。<br>优点是简单，缺点是不能表达嵌套格式、图片等二进制文件，数据结构变更可能导致读写代码的修改。</p>
<ol start="2">
<li>使用特定语言的序列化模块，比如 Java Serialization 等。</li>
</ol>
<p>这种方式可以表达复杂的对象，对于嵌套格式更是不在话下，但是由于与语言绑定，无法做到跨语言支持。</p>
<ol start="3">
<li>使用通用的语言格式，比如 JSON、XML</li>
</ol>
<p>这种方式存在重复的 key，并且对于二进制支持不够，需要 base64 等特殊处理。</p>
<ol start="4">
<li>当上述 3 种方式的缺点严重阻碍你的应用时，则需要考虑自定义的序列化工具了。这个时候我们希望有一种方法，可以约束每个字段类型，并且提供数据的解析功能。这种带有 schema 的数据格式，常见的有 Thrift、Protobuf、Avro 等。此类序列化框架通常具有以下特征：</li>
</ol>
<p>提供 IDL（Interface Description language）描述数据格式<br>支持跨语言交互，比如使用 Java 开发服务端，Python 作为客户端读取数据<br>数据编码存储，对数据进行压缩等处理，尽可能减少存储占用<br>支持 schema 的演化，即按照一定规则修改 schema，同时保证读写模块的向前向后的兼容性</p>
<blockquote>
<p>注意<br>常见的序列化框架有 Thrift、Protobuf、Avro，而由于 Thrift、Avro 可以生成 RPC 实现，所以当提到如 Thrift 服务这种说法时一般指的是 Thrift 实现的 RPC 服务端。而 Protobuf 没有 RPC 实现，所以指的就是序列化与反序列化操作，一般会结合 gRPC 来进行 RPC 实现。</p>
</blockquote>
<p>参考文章</p>
<p><a href="https://zhuanlan.zhihu.com/p/206625402">https://zhuanlan.zhihu.com/p/206625402</a></p>
]]></content>
      <tags>
        <tag>分布式基础</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式 - 雪花算法</title>
    <url>/blogs/distribution-snowflake.html</url>
    <content><![CDATA[<h1 id="分布式-雪花算法"><a href="#分布式-雪花算法" class="headerlink" title="分布式 - 雪花算法"></a>分布式 - 雪花算法</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢 ~~</p>
<h5 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h5><p>64 位</p>
<p>0   - 不可变<br>时间戳 41<br>工作机器id 10<br>序列号 12</p>
<p>除了第一个位置不可变以外，其余三个可按照需求更改位数。</p>
<ul>
<li><a href="https://www.lanindex.com/twitter-snowflake%EF%BC%8C64%E4%BD%8D%E8%87%AA%E5%A2%9Eid%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3/">Twitter-Snowflake，64位自增ID算法详解</a></li>
</ul>
]]></content>
      <tags>
        <tag>分布式</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式系统 - RPC</title>
    <url>/blogs/distribute-rpc.html</url>
    <content><![CDATA[<h1 id="分布式系统-RPC"><a href="#分布式系统-RPC" class="headerlink" title="分布式系统 - RPC"></a>分布式系统 - RPC</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢 ~~</p>
<blockquote>
<ol>
<li><a href="">RPC - 序列化</a></li>
</ol>
</blockquote>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><blockquote>
<p>像调用本地的类的方法样来调用服务器端的方法实现</p>
</blockquote>
<p><code>RPC</code>（ RemoteProcedureCall）—远程过程调用 ，它是一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的协议。<code>RPC</code> 协议假定某些传输协议的存在，如 <code>TCP</code> 或 <code>UDP</code>，为通信程序之间携带信息数据。在 <code>OSI</code> 网络通信模型中，<code>RPC</code> 跨越了传输层和应用层。</p>
<p>比如两个不同的服务 <code>A</code>,<code>B</code> 部署在两台不同的机器上，那么服务 <code>A</code> 如果想要调用服务 <code>B</code> 中的某个方法该怎么办呢？使用 <code>HTTP</code> 请求当然可以，但是可能会比较慢而且一些优化做的并不好。<code>RPC</code> 的出现就是为了解决这个问题。</p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p><code>RPC</code> 采用客户端（服务调用方）/服务器端（服务提供方）模式， 都运行在自己的 <code>JVM</code> 中。客户端只需要引入要使用的接口，接口的实现和运行都在服务器端。<code>RPC</code> 主要依赖的技术包括序列化、反序列化和数据传输协议，这是一种定义与实现相分离的设计。</p>
<p><img src="https://ask.qcloudimg.com/http-save/yehe-5836255/sqmh32g7mx.jpeg?imageView2/2/w/1620"></p>
<p>同时在此处要对 RMI( Remote Method Invoke，远程方法调用)中的 stub (桩)和skeleton (骨架)的概念有一点了解。RMI 的代理模式是通过代理对象将方法传递给实际对象的。stub 驻留客户端,承担着代理远程对象实现者的角色。skeleton 类帮助远程对象与 stub 连接进行通信。 </p>
<p><img src="https://ask.qcloudimg.com/http-save/yehe-5836255/rok7xkgm7z.jpeg?imageView2/2/w/1620"></p>
<p>服务调用方（client）调用以本地调用方式调用服务；<br>client stub 接收到调用后负责将方法、参数等组装成能够进行网络传输的消息体；<br>client stub 找到服务地址，并将消息发送到服务端；<br>server stub 收到消息后进行解码；<br>server stub 根据解码结果调用本地的服务；<br>本地服务执行并将结果返回给 server stub；<br>server stub 将返回结果打包成消息并发送至调用方；<br>client stub 接收到消息，并进行解码；<br>服务调用方得到最终结果。</p>
<p>主要组成元素：</p>
<p>实体对象<br>业务接口<br>接口实现</p>
<p>实体对象和业务接口由客户端和服务端公用。</p>
<p>接口实现是由服务端对定义好的业务接口进行功能实现，并将接口实例注册服务中提供给客户端调用。</p>
<h3 id="设计的技术细节"><a href="#设计的技术细节" class="headerlink" title="设计的技术细节"></a>设计的技术细节</h3><p><code>RPC</code> 涉及 序列化、压缩算法、协议、动态代理、服务注册、加密、网络编程、连接管理、健康检测、负载均衡、优雅启停机、异常重试、业务分组以及熔断限流等</p>
<h2 id="常见-RPC-框架"><a href="#常见-RPC-框架" class="headerlink" title="常见 RPC 框架"></a>常见 <code>RPC</code> 框架</h2><p>目前 <code>Java</code> 使用比较多的 <code>RPC</code> 方案主要有 <code>RMI</code>（JDK自带）、<code>Hessian</code>、<code>Dubbo</code>、<code>Hprose</code>、<code>Thrift</code> 以及 <code>HTTP</code> 等。</p>
<blockquote>
<p>注意：<br><code>RPC</code> 主要指内部服务之间的调用，<code>RESTful</code> 也可以用于内部服务之间的调用，但其主要用途还在于外部系统提供服务，</p>
</blockquote>
<p>如何进行选择？<br>是否允许代码侵入： 即需要依赖相应的代码生成器生成代码，比如 Thrift。<br>是否需要长连接获取高性能： 如果对于性能需求较高的 haul，那么可以果断选择基于 TCP 的 Thrift、Dubbo。<br>是否需要跨越网段、跨越防火墙： 这种情况一般选择基于 HTTP 协议的Hessian 和 Thrift 的 HTTP Transport。<br>此外，Google 推出的基于 HTTP2.0 的 gRPC 框架也开始得到应用，其序列化协议基于 Protobuf，网络框架使用的是 Netty4 ,但是其需要生成代码，可扩展性比较差。</p>
<p>现代 RPC 的本质其实就是在网络上传输数据包，而这个数据包的特点是Header + Body。Header 即协议头，分为定长或者变长，这个取决于协议的设计者。例如 dubbo 协议就是定长的。而有些协议是变长的。Body 就是消息体，其实就是对象序列化的过程，把序列化好的数据放入 Body 里面。现在流行的序列化方案有 Hessian，Java-built-in，JSON，MsgPack，Protobuf 等。底层框架一般使用 NIO/Netty 架构，因为是异步通信，需要支持高性能、高并发。</p>
<p>参考文章</p>
<p><a href="https://cloud.tencent.com/developer/article/1465446">性能基础之常见RPC框架浅析</a></p>
]]></content>
      <tags>
        <tag>分布式基础</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解 Docker Daemon 网络</title>
    <url>/blogs/docker-daemon.html</url>
    <content><![CDATA[<h1 id="深入理解-Docker-Daemon-网络"><a href="#深入理解-Docker-Daemon-网络" class="headerlink" title="深入理解 Docker Daemon 网络"></a>深入理解 Docker Daemon 网络</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢 ~~</p>
<p>docker start 会解析绑定 ip 地址，然后 flag 标志位是否为true，来判断是否要给<br>docker 生成一个 docker 网络驱动器或者是docker</p>
<h4 id="1-网络初始化"><a href="#1-网络初始化" class="headerlink" title="1. 网络初始化"></a>1. 网络初始化</h4><ul>
<li>解析 flag</li>
<li>预处理 flag</li>
<li>确定 docker 网桥模式</li>
</ul>
<p>确定网络环境后</p>
<ul>
<li>创建指定网络相关的job</li>
<li>job 环境参数等配置</li>
<li>触发执行 job</li>
</ul>
<h4 id="2-创建网桥"><a href="#2-创建网桥" class="headerlink" title="2. 创建网桥"></a>2. 创建网桥</h4><ol>
<li>提取 job 的环境变量</li>
<li>确定当前的网桥名称</li>
</ol>
<ul>
<li>如果没有配置，则会默认使用 docker 0</li>
</ul>
<ol start="3">
<li>查找 bridgeInterface。</li>
</ol>
<ul>
<li>如果查到，直接返回 ip地址。否则直接报错。<blockquote>
<p>指定<br>未指定</p>
</blockquote>
</li>
</ul>
<h5 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h5><ul>
<li><a href=""></a></li>
</ul>
]]></content>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解 Docker</title>
    <url>/blogs/docker-introduce.html</url>
    <content><![CDATA[<h1 id="深入理解-Docker"><a href="#深入理解-Docker" class="headerlink" title="深入理解 Docker"></a>深入理解 Docker</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢 ~~</p>
<ul>
<li><p><a href="">深入理解 Docker - NameSpace</a></p>
</li>
<li><p><a href="">深入理解 Docker - CGroups</a></p>
</li>
</ul>
<h5 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h5><ul>
<li><a href=""></a></li>
</ul>
]]></content>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker 分层存储原理</title>
    <url>/blogs/docker-layered-storage.html</url>
    <content><![CDATA[<h1 id="深入理解-Docker-分层存储原理"><a href="#深入理解-Docker-分层存储原理" class="headerlink" title="深入理解 Docker 分层存储原理"></a>深入理解 Docker 分层存储原理</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢 ~~</p>
<p>Centos 发行版的 overlay2 文件系统有三个层次结构</p>
<ul>
<li>lowerdir</li>
<li>upperdir</li>
<li>merged</li>
</ul>
<p>1、lowerdir层：<br>其中lowerdir是只读的镜像层(image layer)，其中就包含bootfs/rootfs层，bootfs(boot file system)主要包含bootloader和kernel，bootloader主要是引导加载kernel，当boot成功 kernel 被加载到内存中，bootfs就被umount了，rootfs(root file system)包含的就是典型Linux系统中的/dev、/proc、/bin、/etc等标准目录。<br>lowerdir是可以分很多层的，除了bootfs/rootfs层以外，还可以通过Dockerfile建立很多image层，构建过程如下：</p>
<p><img src="https://img2020.cnblogs.com/blog/1715041/202102/1715041-20210226171304231-1913260993.png"></p>
<p>Dockerfile中每一个指令都会生成一个新的image层，如上图所示。<br>当FROM时就已经生成了bootfs/rootfs层，也就是kernel和base层。</p>
<p>2、upperdir层<br>upperdir层是lowerdir的上一层，只有这一层可读可写的，其实就是Container层，在启动一个容器的时候会在最后的image层的上一层自动创建，所有对容器数据的更改都会发生在这一层。</p>
<p>3、merged层<br>merged层就是联合挂载层，也就是给用户暴露的统一视觉，将image层和container层结合，就如最上边的图中描述一致，同一文件，在此层会展示离它最近的层级里的文件内容，或者可以理解为，只要container层中有此文件，便展示container层中的文件内容，若container层中没有，则展示image层中的。</p>
<p>联合挂载系统的工作原理<br>1、读：<br>如果文件在upperdir(容器)层，直接读取文件；<br>如果文件不在upperdir(容器)层，则从镜像层(lowerdir)读取；</p>
<p>2、写：<br>首次写入：如果upperdir中不存在，overlay和overlay2执行copy_up操作，把文件从lowdir拷贝到upperdir中，由于overlayfs是文件级别的(即使只有很少的一点修改，也会产生copy_up的动作)，后续对同一文件的再次写入操作将对已经复制到容器层的文件副本进行修改，这也就是尝尝说的写时复制(copy-on-write)。</p>
<p>删除文件或目录：当文件被删除时，在容器层(upperdir)创建whiteout文件，镜像层(lowerdir)的文件是不会被删除的，因为它们是只读的，但without文件会阻止它们显示，当目录被删除时，在容器层(upperdir)一个不透明的目录，这个和上边的whiteout的原理一样，组织用户继续访问，image层不会发生改变</p>
<p>3、注意事项<br>copy_up操作只发生在文件首次写入，以后都是只修改副本,<br>overlayfs只适用两层目录，,相比于比AUFS，查找搜索都更快。<br>容器层的文件删除只是一个“障眼法”，是靠whiteout文件将其遮挡,image层并没有删除，这也就是为什么使用docker commit 提交保存的镜像会越来越大，无论在容器层怎么删除数据，image层都不会改变。 </p>
<p><img src="https://img2020.cnblogs.com/blog/1715041/202102/1715041-20210226171354047-588353208.png"></p>
<p>为什么 Docker 那么快</p>
<p><img src="https://img2020.cnblogs.com/blog/1715041/202102/1715041-20210226171455346-2093471854.png"></p>
<p>可以清楚的看到，VM比docker多了Hypervisor 和 Guest OS的过程，也正是省略了这些过程使docker技高一筹，问题又来了，为什么docker可以省略这些过程呢？<br>Hypervisor：主要作用是实现硬件资源虚拟化；因为docker容器上程序直接使用的都是物理机的硬件资源，所以不需要资源虚拟化的过程，也因此在CPU、内存利用率上docker将会在效率上明显提高<br>Guest OS：主要作用加载操作系统内核；因为docker利用的是宿主机的内核，所以在启动一个容器时，不需要像VM一样重新加载一个操作系统内核，也因此大大节约了启动时间。</p>
]]></content>
      <tags>
        <tag>DevOps</tag>
      </tags>
  </entry>
  <entry>
    <title>深度学习 - 后向传播算法</title>
    <url>/blogs/dp-back-propagation.html</url>
    <content><![CDATA[<h1 id="深度学习-后向传播算法"><a href="#深度学习-后向传播算法" class="headerlink" title="深度学习 - 后向传播算法"></a>深度学习 - 后向传播算法</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢~~</p>
]]></content>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>深度学习 - 前向传播算法</title>
    <url>/blogs/dp-forward-propagation.html</url>
    <content><![CDATA[<h1 id="深度学习-前向传播算法"><a href="#深度学习-前向传播算法" class="headerlink" title="深度学习 - 前向传播算法"></a>深度学习 - 前向传播算法</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢~~</p>
]]></content>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>深度神经网络简介</title>
    <url>/blogs/dp-introduce.html</url>
    <content><![CDATA[<h1 id="深度神经网络简介"><a href="#深度神经网络简介" class="headerlink" title="深度神经网络简介"></a>深度神经网络简介</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢~~</p>
<ol>
<li>深度神经网络结构：</li>
</ol>
<ul>
<li>使用激活函数实现神经网络模型的去线性化</li>
<li>使用一个或多个隐藏层使神经网路层次更深来解决复杂问题</li>
<li>使用正则化来避免过度拟合</li>
<li>使用活动平均模型使模型更健壮</li>
</ul>
]]></content>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>环境搭建 - Docker - Linux 环境</title>
    <url>/blogs/env-install-docker.html</url>
    <content><![CDATA[<h1 id="环境搭建-Docker-安装-Linux-环境"><a href="#环境搭建-Docker-安装-Linux-环境" class="headerlink" title="环境搭建 - Docker - 安装 - Linux 环境"></a>环境搭建 - Docker - 安装 - Linux 环境</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢~~</p>
<h2 id="1-更新安装数据源"><a href="#1-更新安装数据源" class="headerlink" title="1. 更新安装数据源"></a>1. 更新安装数据源</h2><pre class=" language-shell"><code class="language-shell">sudo yum update</code></pre>
<pre><code>sudo yum install -y yum-utils\
     device-mapper-persistent-data\
     1vm2</code></pre>
]]></content>
      <tags>
        <tag>环境搭建</tag>
      </tags>
  </entry>
  <entry>
    <title>env-install-git</title>
    <url>/blogs/env-install-git.html</url>
    <content><![CDATA[<h1 id="Centos-Git"><a href="#Centos-Git" class="headerlink" title="Centos Git"></a>Centos Git</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢~~</p>
<h2 id="检查服务器中是否存在-Git"><a href="#检查服务器中是否存在-Git" class="headerlink" title="检查服务器中是否存在 Git"></a>检查服务器中是否存在 Git</h2><p><code>rpm -qa|grep git</code></p>
<p>如果已经安装，先卸载</p>
<p><code>rpm -e --nodeps git</code> 或者 <code>rpm -e git</code></p>
<p>安装 Git</p>
<p><code>yum install git</code></p>
]]></content>
      <tags>
        <tag>环境搭建</tag>
      </tags>
  </entry>
  <entry>
    <title>env-install-gitlab</title>
    <url>/blogs/env-install-gitlab.html</url>
    <content><![CDATA[<h1 id="环境搭建-Docker-安装-GitLab"><a href="#环境搭建-Docker-安装-GitLab" class="headerlink" title="环境搭建 - Docker - 安装 GitLab"></a>环境搭建 - Docker - 安装 GitLab</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢~~</p>
<h2 id="一-使用-Docker-安装-GitLab-镜像服务器"><a href="#一-使用-Docker-安装-GitLab-镜像服务器" class="headerlink" title="一. 使用 Docker 安装 GitLab 镜像服务器"></a>一. 使用 Docker 安装 GitLab 镜像服务器</h2><pre class=" language-shell"><code class="language-shell">docker run -dit \
-p 8443:443 \
-p 8080:80 \
-p 2222:22 \
-p 9090:9090 \
--name gitlab \
--restart always \
-v /home/gitlab/config:/etc/gitlab \
-v /home/gitlab/logs:/var/log/gitlab \
-v /home/gitlab/data:/var/opt/gitlab </code></pre>
<h2 id="二-GitLab-配置"><a href="#二-GitLab-配置" class="headerlink" title="二. GitLab 配置"></a>二. GitLab 配置</h2><h3 id="1-配置邮件服务器"><a href="#1-配置邮件服务器" class="headerlink" title="1. 配置邮件服务器"></a>1. 配置邮件服务器</h3><pre class=" language-shell"><code class="language-shell">#配置下面，需要配置smtp_tls 注意gitlab_rails['smtp_tls'] 这个是设定为true
gitlab_rails['smtp_enable'] = true
gitlab_rails['smtp_address'] = "smtp.exmail.qq.com"
gitlab_rails['smtp_port'] = 465
gitlab_rails['smtp_user_name'] = "xxx@*****.com"
gitlab_rails['smtp_password'] = "********"
gitlab_rails['smtp_domain'] = "smtp.exmail.qq.com"
gitlab_rails['smtp_authentication'] = "login"
gitlab_rails['smtp_enable_starttls_auto'] = true
gitlab_rails['smtp_tls'] = true
##配置邮箱来源， 与展示的名称
gitlab_rails['gitlab_email_enabled'] = true
gitlab_rails['gitlab_email_from'] = 'xxn@*****.com'
gitlab_rails['gitlab_email_display_name'] = ''</code></pre>
]]></content>
      <tags>
        <tag>环境搭建</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 环境安装 - Centos-Mac-Windows</title>
    <url>/blogs/env-install-java-centos.html</url>
    <content><![CDATA[<h1 id="Java-环境安装"><a href="#Java-环境安装" class="headerlink" title="Java 环境安装"></a>Java 环境安装</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢~~</p>
<h5 id="特别说明-1"><a href="#特别说明-1" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 PR 谢谢~~</p>
<h2 id="一-Centos"><a href="#一-Centos" class="headerlink" title="一. Centos"></a>一. Centos</h2><ol>
<li>卸载系统自带的 <code>JDK</code> 版本</li>
</ol>
<ul>
<li>查找系统 <code>jdk</code></li>
</ul>
<pre class=" language-shell"><code class="language-shell">[root@rort ~]#  rpm -qa|grep java 
java-1.6.0-openjdk-1.6.0.37-1.13.9.4.el5_11
tzdata-java-2015g-1.el5</code></pre>
<ul>
<li>如果存在，则进行卸载</li>
</ul>
<pre class=" language-shell"><code class="language-shell">[root@root ~]# rpm -e --allmatches --nodeps java-1.6.0-openjdk-1.6.0.37-1.13.9.4.el5_11
[root@root ~]# rpm -e --allmatches --nodeps tzdata-java-2015g-1.el5</code></pre>
<ul>
<li>检查是否卸载干净</li>
</ul>
<pre class=" language-shell"><code class="language-shell">[root@root ~]#  rpm -qa|grep java </code></pre>
<ol start="2">
<li>查找yum下可更新的Java列表</li>
</ol>
<pre class=" language-shell"><code class="language-shell">yum -y list java*
// or
yum search jdk</code></pre>
<ol start="3">
<li>安装 <code>java</code></li>
</ol>
<pre class=" language-shell"><code class="language-shell">yum install -y java-1.8.0-openjdk.x86_64</code></pre>
<ol start="4">
<li>验证</li>
</ol>
<pre class=" language-shell"><code class="language-shell">java -version</code></pre>
<p>配置环境变量</p>
<pre class=" language-shell"><code class="language-shell">export JAVA_HOME=/usr/lib/jvm/jre-1.8.0-openjdk
export PATH=$JAVA_HOME/bin:$PATH
export CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar</code></pre>
]]></content>
      <tags>
        <tag>环境搭建</tag>
      </tags>
  </entry>
  <entry>
    <title>env-install-jenkins</title>
    <url>/blogs/env-install-jenkins.html</url>
    <content><![CDATA[<h1 id="环境搭建-docker-安装-jenkins"><a href="#环境搭建-docker-安装-jenkins" class="headerlink" title="环境搭建 - docker - 安装 jenkins"></a>环境搭建 - docker - 安装 jenkins</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢~~</p>
<pre class=" language-shell"><code class="language-shell">docker run --name devops-jenkins \ 
--user=root \
-p 8080:8080 \
-p 50000:50000 \
-v /opt/data/jenkins_home:/var/jenkins_home \
-d jenkins/jenkins</code></pre>
]]></content>
      <tags>
        <tag>环境搭建</tag>
      </tags>
  </entry>
  <entry>
    <title>环境搭建 - kafka -docker</title>
    <url>/blogs/env-install-kafka.html</url>
    <content><![CDATA[<h1 id="使用-docker-搭建-kafka-环境"><a href="#使用-docker-搭建-kafka-环境" class="headerlink" title="使用 docker 搭建 kafka 环境"></a>使用 <code>docker</code> 搭建 <code>kafka</code> 环境</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢~~</p>
<h2 id="一-下载镜像"><a href="#一-下载镜像" class="headerlink" title="一. 下载镜像"></a>一. 下载镜像</h2><pre class=" language-dockerfile"><code class="language-dockerfile">docker pull wurstmeister/zookeeper
docker pull wurstmeister/kafka</code></pre>
<p>kafka</p>
<h2 id="Docker-zookeeper"><a href="#Docker-zookeeper" class="headerlink" title="Docker zookeeper"></a>Docker zookeeper</h2><p>docker run -d –name zookeeper -p 2181:2181 -t zookeeper</p>
<h2 id="Docker-Kafka-创建"><a href="#Docker-Kafka-创建" class="headerlink" title="Docker Kafka 创建"></a>Docker Kafka 创建</h2><p>docker run -d –name kafka –publish 9092:9092 <br>–link zookeeper <br>–env KAFKA_ZOOKEEPER_CONNECT=zookeeper:2181 <br>–env KAFKA_ADVERTISED_HOST_NAME=127.0.0.1 <br>–env KAFKA_ADVERTISED_PORT=9092 <br>wurstmeister/kafka</p>
<h2 id="Kafka-manager"><a href="#Kafka-manager" class="headerlink" title="Kafka manager"></a>Kafka manager</h2><p>docker run -d –name kafka-manager --link zookeeper:zookeeper --link kafka:kafka -p 9001:9000 --restart=always --env ZK_HOSTS=zookeeper:2181 \sheepkiller/kafka-manager</p>
]]></content>
      <tags>
        <tag>环境搭建</tag>
      </tags>
  </entry>
  <entry>
    <title>env-install-ngnix</title>
    <url>/blogs/env-install-ngnix.html</url>
    <content><![CDATA[<h1 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢~~</p>
<pre class=" language-shell"><code class="language-shell"> Nginx

 docker run --name nginx -d -p 82:80 \
-v /data/nginx/conf/nginx.conf:/etc/nginx/nginx.conf \
 -v /data/nginx/logs:/var/log/nginx -d docker.io/nginx</code></pre>
]]></content>
      <tags>
        <tag>环境搭建</tag>
      </tags>
  </entry>
  <entry>
    <title>env-install-postgresql</title>
    <url>/blogs/env-install-postgresql.html</url>
    <content><![CDATA[<h2 id="安装-postgresql-container"><a href="#安装-postgresql-container" class="headerlink" title="安装 postgresql container"></a>安装 postgresql container</h2><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢~~</p>
<pre class=" language-docker"><code class="language-docker">docker run <span class="token punctuation">-</span><span class="token punctuation">-</span>name gitlab<span class="token punctuation">-</span>postgresql <span class="token punctuation">-</span>d \
    <span class="token punctuation">-</span><span class="token punctuation">-</span>env <span class="token string">'DB_NAME=gitlabhq_production'</span> \
    <span class="token punctuation">-</span><span class="token punctuation">-</span>env <span class="token string">'DB_USER=gitlab'</span> <span class="token punctuation">-</span><span class="token punctuation">-</span>env <span class="token string">'DB_PASS=password'</span> \
    <span class="token punctuation">-</span><span class="token punctuation">-</span>volume /srv/docker/gitlab/postgresql<span class="token punctuation">:</span>/var/lib/postgresql \
    sameersbn/postgresql<span class="token punctuation">:</span>9.4<span class="token punctuation">-</span>12</code></pre>
]]></content>
      <tags>
        <tag>环境搭建</tag>
      </tags>
  </entry>
  <entry>
    <title>ES 底层 FST 有限状态机</title>
    <url>/blogs/es-fst.html</url>
    <content><![CDATA[<h1 id="ES-底层-FST-有限状态机"><a href="#ES-底层-FST-有限状态机" class="headerlink" title="ES 底层 FST 有限状态机"></a>ES 底层 FST 有限状态机</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢 ~~</p>
<h5 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h5><ul>
<li><a href="https://www.shangmayuan.com/a/4c53ea95cb1647579ee027e0.html">有限状态机FST</a></li>
</ul>
]]></content>
      <tags>
        <tag>ES</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解 ES - HA</title>
    <url>/blogs/es-ha.html</url>
    <content><![CDATA[<h1 id="深入理解-ES-HA"><a href="#深入理解-ES-HA" class="headerlink" title="深入理解 ES - HA"></a>深入理解 ES - HA</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢 ~~</p>
<p>es 是准实时的，数据写⼊ 1 秒后可以搜索到；可能会丢失数据的。有 5 秒的数 据，停留在 停留在 buffer和os cache中，而不在磁盘上，此时宕机，会有5s数据丢失。</p>
<p>ES 的选举算法是 Bully，但是会存在问题，</p>
<ul>
<li>假死</li>
<li>脑裂</li>
</ul>
<p>解决方案是使用 Quorum</p>
<h5 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h5><ul>
<li><p><a href="https://www.cnblogs.com/zh-ch/p/14166079.html">Elasticsearch脑裂问题详细分析以及解决方案</a></p>
</li>
<li><p><a href="https://zhuanlan.zhihu.com/p/110015509">Elasticsearch选举原理之Bully算法</a></p>
</li>
</ul>
]]></content>
      <tags>
        <tag>ES</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解 ES 原理目录</title>
    <url>/blogs/es-introduce.html</url>
    <content><![CDATA[<h1 id="深入理解-ES-原理目录"><a href="#深入理解-ES-原理目录" class="headerlink" title="深入理解 ES 原理目录"></a>深入理解 ES 原理目录</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢 ~~</p>
<ol>
<li><p><a href="">深入理解 ES 搜索原理</a></p>
</li>
<li><p><a href="">深入理解 ES 查询原理</a></p>
</li>
<li><p><a href="">深入理解 ES 写入原理</a></p>
</li>
<li><p><a href="">深入理解 ES 性能优化</a></p>
</li>
</ol>
<h5 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h5><ul>
<li><a href="https://segmentfault.com/a/1190000015256970">ES分布式架构及底层原理</a></li>
</ul>
]]></content>
      <tags>
        <tag>ES</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解 ES 性能优化</title>
    <url>/blogs/es-performance-optimize.html</url>
    <content><![CDATA[<h1 id="深入理解-ES-性能优化"><a href="#深入理解-ES-性能优化" class="headerlink" title="深入理解 ES 性能优化"></a>深入理解 ES 性能优化</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢 ~~</p>
<h5 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h5><ul>
<li><p><a href="https://www.elastic.co/guide/cn/elasticsearch/guide/current/heap-sizing.html#compressed_oops">堆内存：大小和交换</a></p>
</li>
<li><p><a href="https://juejin.cn/post/6862238580094435342">深入 Elastic Search： ES 性能优化总结</a></p>
</li>
<li><p><a href="https://www.cnblogs.com/mengrennwpu/p/10658144.html">Es性能优化</a></p>
</li>
</ul>
]]></content>
      <tags>
        <tag>ES</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式基础</title>
    <url>/blogs/fenbushi.html</url>
    <content><![CDATA[<h1 id="分布式基础"><a href="#分布式基础" class="headerlink" title="分布式基础"></a>分布式基础</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢 ~~</p>
<h5 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h5><ul>
<li><a href=""></a></li>
</ul>
]]></content>
      <tags>
        <tag>分布式</tag>
      </tags>
  </entry>
  <entry>
    <title>ES  数据更新 版本控制</title>
    <url>/blogs/es-version-control.html</url>
    <content><![CDATA[<h1 id="ES-数据更新-版本控制"><a href="#ES-数据更新-版本控制" class="headerlink" title="ES  数据更新 版本控制"></a>ES  数据更新 版本控制</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢 ~~</p>
<p>会比较 version 字段。只有比当前的 version 大 才能更新。</p>
<p>集群同步数据的时候，只有收到的version 大于等于当前的 version 才会进行更新。</p>
<h5 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h5><ul>
<li><a href="https://segmentfault.com/a/1190000021199668">Elasticsearch系列—并发控制及乐观锁实现原理</a></li>
</ul>
]]></content>
      <tags>
        <tag>ES</tag>
      </tags>
  </entry>
  <entry>
    <title>ES 数据写入原理</title>
    <url>/blogs/es-write-principle.html</url>
    <content><![CDATA[<h1 id="ES-数据写入原理"><a href="#ES-数据写入原理" class="headerlink" title="ES 数据写入原理"></a>ES 数据写入原理</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢 ~~</p>
<h5 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h5><ul>
<li><a href="https://juejin.cn/post/7034068713011839006"></a></li>
</ul>
]]></content>
      <tags>
        <tag>es</tag>
      </tags>
  </entry>
  <entry>
    <title>Git - git-checkout 深入理解与实战</title>
    <url>/blogs/git-checkout.html</url>
    <content><![CDATA[<h1 id="Git-git-checkout-深入理解与实战"><a href="#Git-git-checkout-深入理解与实战" class="headerlink" title="Git - git-checkout 深入理解与实战"></a>Git - git-checkout 深入理解与实战</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢~~</p>
<h5 id="git-checkout"><a href="#git-checkout" class="headerlink" title="git-checkout"></a>git-checkout</h5><ol>
<li>本地从当前所在分支上创建一个新分支。</li>
</ol>
<pre class=" language-git"><code class="language-git">git chekout -b 新分支名</code></pre>
<ol start="2">
<li>拉取远程某个分支到本地：</li>
</ol>
<pre class=" language-git"><code class="language-git">git chekout -b 本地分支名 origin/远程分支名</code></pre>
<h1 id="git-rebase"><a href="#git-rebase" class="headerlink" title="git-rebase"></a>git-rebase</h1><pre class=" language-git"><code class="language-git">git rebase &lt;basebranch> &lt;topicbranch></code></pre>
<p>git rebase origin/a</p>
<p>git am –show-current-patch</p>
<p>git 查看当前分支是从哪个分支切出来的</p>
<p><code>git reflog --date=local | grep 分支名</code></p>
<p>查看git log的图</p>
<p><code>git log --graph --all --decorate</code></p>
<p>git 添加上游仓库</p>
<p><code>git remote add upstream url</code></p>
<p><code>git fetch upstream</code></p>
<p><code>git merge upstream/master</code></p>
<h3 id="从远程分支新建分支"><a href="#从远程分支新建分支" class="headerlink" title="从远程分支新建分支"></a>从远程分支新建分支</h3><p><code>git checkout -b newBranchName origin/RemoteBranchName</code></p>
<h3 id="删除远程分支"><a href="#删除远程分支" class="headerlink" title="删除远程分支"></a>删除远程分支</h3><p><code>git push --delete oriign remoteBranchName</code></p>
]]></content>
      <tags>
        <tag>开发工具</tag>
      </tags>
  </entry>
  <entry>
    <title>Git 远程仓库设置</title>
    <url>/blogs/git-conf-repo.html</url>
    <content><![CDATA[<h1 id="Git-远程仓库设置"><a href="#Git-远程仓库设置" class="headerlink" title="Git 远程仓库设置"></a>Git 远程仓库设置</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢~~</p>
<h2 id="一-切换远程仓库地址"><a href="#一-切换远程仓库地址" class="headerlink" title="一. 切换远程仓库地址"></a>一. 切换远程仓库地址</h2><h3 id="1-本地仓库暂无关联的远程仓库"><a href="#1-本地仓库暂无关联的远程仓库" class="headerlink" title="1. 本地仓库暂无关联的远程仓库"></a>1. 本地仓库暂无关联的远程仓库</h3><blockquote>
<p>更换远程仓库地址，URL为新地址ß</p>
</blockquote>
<pre class=" language-git"><code class="language-git">git remote set-url origin URL</code></pre>
<h3 id="2-本地仓库已有关联的远程仓库"><a href="#2-本地仓库已有关联的远程仓库" class="headerlink" title="2. 本地仓库已有关联的远程仓库"></a>2. 本地仓库已有关联的远程仓库</h3><h4 id="1-删除现有远程仓库"><a href="#1-删除现有远程仓库" class="headerlink" title="1. 删除现有远程仓库"></a>1. 删除现有远程仓库</h4><pre class=" language-git"><code class="language-git">git remote rm origin</code></pre>
<h4 id="2-关联远程仓库"><a href="#2-关联远程仓库" class="headerlink" title="2. 关联远程仓库"></a>2. 关联远程仓库</h4><pre class=" language-git"><code class="language-git">git remote add origin URL</code></pre>
]]></content>
      <tags>
        <tag>开发工具</tag>
      </tags>
  </entry>
  <entry>
    <title>Git 删除远程分支</title>
    <url>/blogs/git-delete-branch.html</url>
    <content><![CDATA[<h1 id="Git-删除远程分支"><a href="#Git-删除远程分支" class="headerlink" title="Git 删除远程分支"></a>Git 删除远程分支</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢 ~~</p>
<h2 id="1-切换到-master"><a href="#1-切换到-master" class="headerlink" title="1. 切换到 master"></a>1. 切换到 master</h2><pre class=" language-git"><code class="language-git">git checkout master</code></pre>
<h2 id="2-删除目标分支"><a href="#2-删除目标分支" class="headerlink" title="2. 删除目标分支"></a>2. 删除目标分支</h2><h3 id="1）-推送空分支，相当于删除分支"><a href="#1）-推送空分支，相当于删除分支" class="headerlink" title="1）. 推送空分支，相当于删除分支"></a>1）. 推送空分支，相当于删除分支</h3><pre class=" language-git"><code class="language-git">git push origin :target-branch</code></pre>
<h3 id="2-使用-delete-关键字"><a href="#2-使用-delete-关键字" class="headerlink" title="2).  使用 delete 关键字"></a>2).  使用 <code>delete</code> 关键字</h3><pre class=" language-gitexclude"><code class="language-gitexclude">git push origin --delete targe-branch</code></pre>
]]></content>
      <tags>
        <tag>开发工具</tag>
      </tags>
  </entry>
  <entry>
    <title>git - reset - 版本回退</title>
    <url>/blogs/git-rest.html</url>
    <content><![CDATA[<h1 id="使用-git-reset-进行版本"><a href="#使用-git-reset-进行版本" class="headerlink" title="使用 git-reset 进行版本"></a>使用 git-reset 进行版本</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢~~</p>
<h2 id="一-git-reset"><a href="#一-git-reset" class="headerlink" title="一. git-reset"></a>一. <code>git-reset</code></h2><p>使用 git reset 时，当前分支的之前会回退到之前的某个版本，指针回退。回退的同时，可以指定</p>
<h2 id="二-git-reset-有三种模式"><a href="#二-git-reset-有三种模式" class="headerlink" title="二. git-reset 有三种模式"></a>二. <code>git-reset</code> 有三种模式</h2><ul>
<li><code>git-reset hard</code></li>
<li><code>git-reset soft</code></li>
<li><code>git-reset mixed</code></li>
</ul>
]]></content>
      <tags>
        <tag>开发工具</tag>
      </tags>
  </entry>
  <entry>
    <title>git-rebase</title>
    <url>/blogs/git-rebase.html</url>
    <content><![CDATA[<h1 id="Git-基变操作-git-rebase"><a href="#Git-基变操作-git-rebase" class="headerlink" title="Git - 基变操作 - git rebase"></a>Git - 基变操作 - git rebase</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢~~</p>
<h2 id="git-rebase-介绍"><a href="#git-rebase-介绍" class="headerlink" title="git-rebase 介绍"></a><code>git-rebase</code> 介绍</h2><h3 id="二-案例"><a href="#二-案例" class="headerlink" title="二. 案例"></a>二. 案例</h3><p>使用 <code>git-rebase</code> 清理 <code>git-commit</code> 的 <code>log</code> 日志。</p>
]]></content>
      <tags>
        <tag>开发工具</tag>
      </tags>
  </entry>
  <entry>
    <title>git-stash</title>
    <url>/blogs/git-stash.html</url>
    <content><![CDATA[<h1 id="Git-Stash-简介"><a href="#Git-Stash-简介" class="headerlink" title="Git Stash 简介"></a>Git Stash 简介</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢~~</p>
<p>git 修改已经提交的 commit</p>
<p>修改最后一次已提交的 commit</p>
<p><code>git commit --amend</code></p>
<p>修改之前已提交的 commit</p>
<p><code>git rebase -i HEAD~2</code></p>
<h2 id="git-stash"><a href="#git-stash" class="headerlink" title="git stash"></a>git stash</h2><p>应用场景</p>
<ol>
<li>发现有一个类是多余的，想删掉它又担心以后需要查看它的代码，想保存它但又不想增加一个脏的提交。这时就可以考虑 <code>git stash</code>。</li>
<li>使用 git 的时候，我们往往使用分支（branch）解决任务切换问题，例如，我们往往会建一个自己的分支去修改和调试代码, 如果别人或者自己发现原有的分支上有个不得不修改的 bug，我们往往会把完成一半的代码 commit 提交到本地仓库，然后切换分支去修改 bug，改好之后再切换回来。这样的话往往 log 上会有大量不必要的记录。其实如果我们不想提交完成一半或者不完善的代码，但是却不得不去修改一个紧急 Bug，那么使用 <code>git stash</code> 就可以将你当前未提交到本地（和服务器）的代码推入到Git的栈中，这时候你的工作区间和上一次提交的内容是完全一样的，所以你可以放心的修 Bug，等到修完 Bug，提交到服务器上后，再使用 <code>git stash apply</code> 将以前一半的工作应用回来。</li>
<li>经常有这样的事情发生，当你正在进行项目中某一部分的工作，里面的东西处于一个比较杂乱的状态，而你想转到其他分支上进行一些工作。问题是，你不想提交进行了一半的工作，否则以后你无法回到这个工作点。解决这个问题的办法就是 <code>git stash</code> 命令。储藏(stash)可以获取你工作目录的中间状态——也就是你修改过的被追踪的文件和暂存的变更——并将它保存到一个未完结变更的堆栈中，随时可以重新应用。</li>
</ol>
]]></content>
      <tags>
        <tag>开发工具</tag>
      </tags>
  </entry>
  <entry>
    <title>git-workflow</title>
    <url>/blogs/git-workflow.html</url>
    <content><![CDATA[<h1 id="Different-Authority"><a href="#Different-Authority" class="headerlink" title="Different Authority"></a>Different Authority</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢~~</p>
<p> Before the read following content, I consider you hava already had the basics of Git by default. If not, be sure to familiar with it first.</p>
<ol>
<li>As a developer, that is,having the authority of the repo.</li>
<li>As a open source developer</li>
</ol>
<h2 id="1"><a href="#1" class="headerlink" title="1."></a>1.</h2><p>You should checkout a new branch for your own development env. from the develop branch.</p>
<h3 id="Branch-name-regular"><a href="#Branch-name-regular" class="headerlink" title="Branch name regular:"></a>Branch name regular:</h3><h5 id="New-Branch："><a href="#New-Branch：" class="headerlink" title="New Branch："></a>New Branch：</h5><p><code>f-datatime-newFeature-developerName</code></p>
<p><strong>eg.</strong> </p>
<p><code>f-20190326-init-starrier</code></p>
<p><strong>Fix Bug</strong></p>
<p> <code>b-dataTime-projectName-developerName</code></p>
<p><strong>eg.</strong></p>
<p> <code>b-20190326-original-starrier</code></p>
<p> <strong>Note</strong></p>
<p> Whether your are developing new features or fixing bugs,make sure your commit(s) content makes sense every time.</p>
<p> Before you complete the contennt, the recommanded recommendation is to use <code>git stash</code> to temporarily store the current workspace. Otherwise, at the end of the execute <code>git push</code>, use <code>git rebase</code> or <code>git cherry-pick</code> to modify the commit record. Make sure the cleanliness of the project’s commit.</p>
<h2 id="2"><a href="#2" class="headerlink" title="2."></a>2.</h2><p> Before you PR(pull request), please fork your own version repo. When the new feature or modified content of your request has been confirmed, execute the PR finally.</p>
]]></content>
      <tags>
        <tag>开发工具</tag>
      </tags>
  </entry>
  <entry>
    <title>github-repo-transfer</title>
    <url>/blogs/github-repo-transfer.html</url>
    <content><![CDATA[<h1 id="GitHub-仓库迁移"><a href="#GitHub-仓库迁移" class="headerlink" title="GitHub 仓库迁移"></a>GitHub 仓库迁移</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢~~</p>
]]></content>
  </entry>
  <entry>
    <title>深入理解 - 灰度发布原理</title>
    <url>/blogs/grayscale-publishing.html</url>
    <content><![CDATA[<h1 id="深入理解-灰度发布原理"><a href="#深入理解-灰度发布原理" class="headerlink" title="深入理解 - 灰度发布原理"></a>深入理解 - 灰度发布原理</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢 ~~</p>
]]></content>
      <tags>
        <tag>分布式基础</tag>
      </tags>
  </entry>
  <entry>
    <title>GitHub - Hexo - 网站数据分析 - Baidu</title>
    <url>/blogs/hexo-analyse-baidu.html</url>
    <content><![CDATA[<h1 id="GitHub-Hexo-网站数据分析-Baidu"><a href="#GitHub-Hexo-网站数据分析-Baidu" class="headerlink" title="GitHub - Hexo - 网站数据分析 - Baidu"></a>GitHub - Hexo - 网站数据分析 - Baidu</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢~~</p>
<h2 id="一-Baidu"><a href="#一-Baidu" class="headerlink" title="一. Baidu"></a>一. Baidu</h2><h3 id="1-进入-theame-文件夹，正在使用的主题"><a href="#1-进入-theame-文件夹，正在使用的主题" class="headerlink" title="1. 进入 theame 文件夹，正在使用的主题"></a>1. 进入 <code>theame</code> 文件夹，正在使用的主题</h3><p>编辑文件 <code>themes/使用的主题/_config.yml</code>,添加一行配置，</p>
<pre class=" language-yml"><code class="language-yml">baidu_tongji: true</code></pre>
<h3 id="2-新建用于分析的脚本文件"><a href="#2-新建用于分析的脚本文件" class="headerlink" title="2. 新建用于分析的脚本文件"></a>2. 新建用于分析的脚本文件</h3><p>新建 <code>themes/使用的主题/layout/_partial/baidu_tongji.ejs</code>,新增内容：</p>
<pre class=" language-js"><code class="language-js"><span class="token operator">&lt;</span><span class="token operator">%</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>theme<span class="token punctuation">.</span>baidu_tongji<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span> <span class="token operator">%</span><span class="token operator">></span>
<span class="token operator">&lt;</span>script type<span class="token operator">=</span><span class="token string">"text/javascript"</span><span class="token operator">></span>
#申请的百度统计代码
<span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span>
<span class="token operator">&lt;</span><span class="token operator">%</span> <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token operator">%</span><span class="token operator">></span></code></pre>
<p>编辑 <code>themes/使用的主题/layout/_partial/head.ejs</code> 在 <code>&lt;/head&gt;</code> 前添加 <code>&lt;%- partial(&quot;baidu_tongji&quot;) %&gt;</code> 重新生产部署站点即可。</p>
]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo - GitHub 日历</title>
    <url>/blogs/hexo-calendar.html</url>
    <content><![CDATA[<h1 id="Hexo-GitHub-日历"><a href="#Hexo-GitHub-日历" class="headerlink" title="Hexo - GitHub 日历"></a>Hexo - GitHub 日历</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢 ~~</p>
<h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a href="https://blog.csdn.net/weixin_43340420/article/details/111407835">https://blog.csdn.net/weixin_43340420/article/details/111407835</a></p>
]]></content>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo 代码高亮</title>
    <url>/blogs/hexo-code-hightlight.html</url>
    <content><![CDATA[<h1 id="Hexo-代码高亮"><a href="#Hexo-代码高亮" class="headerlink" title="Hexo 代码高亮"></a>Hexo 代码高亮</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢 ~~</p>
<h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a href="https://www.dazhuanlan.com/2019/11/28/5ddf508fb24f2/">https://www.dazhuanlan.com/2019/11/28/5ddf508fb24f2/</a></p>
]]></content>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo 常用命令</title>
    <url>/blogs/hexo-commands.html</url>
    <content><![CDATA[<h1 id="Hexo-常用命令"><a href="#Hexo-常用命令" class="headerlink" title="Hexo 常用命令"></a>Hexo 常用命令</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢 ~~</p>
<pre class=" language-markdown"><code class="language-markdown">npm install hexo -g #安装  
npm update hexo -g #升级  
hexo init #初始化

hexo n "我的博客" == hexo new "我的博客" #新建文章
hexo p == hexo publish
hexo g == hexo generate#生成
hexo s == hexo server #启动服务预览
hexo d == hexo deploy#部署

hexo server #Hexo 会监视文件变动并自动更新，您无须重启服务器。
hexo server -s #静态模式
hexo server -p 5000 #更改端口
hexo server -i 192.168.1.1 #自定义 IP

hexo clean #清除缓存 网页正常情况下可以忽略此条命令
hexo g #生成静态网页
hexo d #开始部署

hexo generate #使用 Hexo 生成静态文件快速而且简单
hexo generate --watch #监视文件变动

两个命令的作用是相同的
hexo generate --deploy
hexo deploy --generate</code></pre>
]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo-function</title>
    <url>/blogs/hexo-function.html</url>
    <content><![CDATA[<h1 id="Hexo-功能启用"><a href="#Hexo-功能启用" class="headerlink" title="Hexo 功能启用"></a>Hexo 功能启用</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢~~</p>
<h2 id="搜索功能"><a href="#搜索功能" class="headerlink" title="搜索功能"></a>搜索功能</h2><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> stripe_code_line_num <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 去除代码</span>
    <span class="token keyword">return</span> str<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token regex">/&lt;figure class="highlight.*?&lt;\/figure>/ig</span><span class="token punctuation">,</span> <span class="token string">''</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> stripe <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>str<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 去除html标签</span>
    <span class="token keyword">return</span> str<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token regex">/(&lt;([^>]+)>)/ig</span><span class="token punctuation">,</span> <span class="token string">''</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> minify <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>str<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 压缩成一行</span>
    <span class="token keyword">return</span> str<span class="token punctuation">.</span><span class="token function">trim</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token regex">/\n/g</span><span class="token punctuation">,</span> <span class="token string">' '</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token regex">/\s+/g</span><span class="token punctuation">,</span> <span class="token string">' '</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>

module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>locals<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
  <span class="token keyword">var</span> config <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>config<span class="token punctuation">;</span>
  <span class="token keyword">var</span> database <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'./database'</span><span class="token punctuation">)</span><span class="token punctuation">(</span>locals<span class="token punctuation">,</span> config<span class="token punctuation">)</span><span class="token punctuation">;</span>
  database<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span> <span class="token keyword">function</span><span class="token punctuation">(</span>element<span class="token punctuation">,</span> index<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
    element<span class="token punctuation">.</span>content <span class="token operator">=</span> <span class="token function">minify</span><span class="token punctuation">(</span><span class="token function">stripe</span><span class="token punctuation">(</span><span class="token function">stripe_code_line_num</span><span class="token punctuation">(</span>element<span class="token punctuation">.</span>content<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">var</span> xml <span class="token operator">=</span> searchTmpl<span class="token punctuation">.</span><span class="token function">render</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
    articles<span class="token punctuation">:</span> database<span class="token punctuation">,</span>
    config  <span class="token punctuation">:</span> config<span class="token punctuation">.</span>search
  <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
    path<span class="token punctuation">:</span> config<span class="token punctuation">.</span>search<span class="token punctuation">.</span>path<span class="token punctuation">,</span>
    data<span class="token punctuation">:</span> xml
  <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">;</span>
<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">;</span>
</code></pre>
]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo-gulp</title>
    <url>/blogs/hexo-gulp.html</url>
    <content><![CDATA[<h1 id="Hexo-Glup-压缩静态资源"><a href="#Hexo-Glup-压缩静态资源" class="headerlink" title="Hexo - Glup 压缩静态资源"></a>Hexo - Glup 压缩静态资源</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢 ~~</p>
<h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a href="https://www.voidking.com/dev-hexo-gulp/">https://www.voidking.com/dev-hexo-gulp/</a></p>
]]></content>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo-seo 优化</title>
    <url>/blogs/hexo-seo.html</url>
    <content><![CDATA[<h1 id="Hexo-SEO-优化"><a href="#Hexo-SEO-优化" class="headerlink" title="Hexo SEO  优化"></a>Hexo SEO  优化</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢~~</p>
<h2 id="一"><a href="#一" class="headerlink" title="一."></a>一.</h2><h2 id="二-nofollow-标签"><a href="#二-nofollow-标签" class="headerlink" title="二. nofollow 标签"></a>二. <code>nofollow</code> 标签</h2><h3 id="1-安装插件"><a href="#1-安装插件" class="headerlink" title="1. 安装插件"></a>1. 安装插件</h3><h4 id="1-npm"><a href="#1-npm" class="headerlink" title="1). npm"></a>1). npm</h4><pre class=" language-shell"><code class="language-shell">npm i hexo-filter-nofollow --save</code></pre>
<h4 id="2-yarn"><a href="#2-yarn" class="headerlink" title="2). yarn"></a>2). yarn</h4><pre class=" language-shell"><code class="language-shell">yarn add hexo-filter-nofollow
</code></pre>
<h3 id="2-启用配置"><a href="#2-启用配置" class="headerlink" title="2. 启用配置"></a>2. 启用配置</h3><p>在根目录下的 <code>_config.yml</code> 中启用配置</p>
<pre class=" language-yaml"><code class="language-yaml"><span class="token comment" spellcheck="true"># nofollow</span>
<span class="token key atrule">nofollow</span><span class="token punctuation">:</span>
  <span class="token key atrule">enable</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>
  <span class="token key atrule">field</span><span class="token punctuation">:</span> site
  <span class="token key atrule">exclude</span><span class="token punctuation">:</span>
    <span class="token punctuation">-</span> <span class="token string">'starriers.starrier.org'</span>
    <span class="token punctuation">-</span> <span class="token string">'github.com/Starrier'</span>
    <span class="token punctuation">-</span> <span class="token string">'github.com/Starriers'</span></code></pre>
<p>配置说明：</p>
<ul>
<li>enable - 是否启用插件，默认值为 true</li>
<li>field - 插件的处理范围，默认值为 site，可选 post 或 site<ul>
<li>post - 仅处理文章内容</li>
<li>site - 处理全站所有页面</li>
</ul>
</li>
<li>exclude - 域名白名单，不同的子域名视为不同的域名（如 www）<ul>
<li>starriers.starrier.org不包括 <a href="http://starriers.starrier.org/">http://starriers.starrier.org</a> 或 starriers.starrier.org</li>
</ul>
</li>
</ul>
<h2 id="三-开启压缩文件"><a href="#三-开启压缩文件" class="headerlink" title="三. 开启压缩文件"></a>三. 开启压缩文件</h2><h3 id="1-下载配置"><a href="#1-下载配置" class="headerlink" title="1. 下载配置"></a>1. 下载配置</h3><pre class=" language-shell"><code class="language-shell">npm install hexo-neat --save</code></pre>
<h3 id="2-开启配置"><a href="#2-开启配置" class="headerlink" title="2. 开启配置"></a>2. 开启配置</h3><pre class=" language-yaml"><code class="language-yaml"><span class="token comment" spellcheck="true"># hexo - neat</span>
<span class="token comment" spellcheck="true"># 开启压缩, 博文压缩</span>
<span class="token key atrule">neat_enable</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>
<span class="token comment" spellcheck="true"># 压缩 html</span>
<span class="token key atrule">neat_html</span><span class="token punctuation">:</span>
  <span class="token key atrule">enable</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>
  <span class="token key atrule">exclude</span><span class="token punctuation">:</span>
<span class="token comment" spellcheck="true"># 压缩 css</span>
<span class="token key atrule">neat_css</span><span class="token punctuation">:</span>
  <span class="token key atrule">enable</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>
  <span class="token key atrule">exclude</span><span class="token punctuation">:</span>
    <span class="token punctuation">-</span> <span class="token string">'**/*.min.css'</span>
<span class="token comment" spellcheck="true"># 压缩 js</span>
<span class="token key atrule">neat_js</span><span class="token punctuation">:</span>
  <span class="token key atrule">enable</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>
  <span class="token key atrule">mangle</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>
  <span class="token key atrule">output</span><span class="token punctuation">:</span>
  <span class="token key atrule">compress</span><span class="token punctuation">:</span>
  <span class="token key atrule">exclude</span><span class="token punctuation">:</span>
    <span class="token punctuation">-</span> <span class="token string">'**/*.min.js'</span>
    <span class="token punctuation">-</span> <span class="token string">'**/index.js'</span></code></pre>
<h2 id="四-hexo-search"><a href="#四-hexo-search" class="headerlink" title="四. hexo search"></a>四. hexo search</h2><pre class=" language-shell"><code class="language-shell">npm install hexo-generator-searchdb</code></pre>
<h2 id="五-hexo-keywords"><a href="#五-hexo-keywords" class="headerlink" title="五. hexo keywords"></a>五. hexo keywords</h2><p>关键字优化，为文章添加 HTML meta keywords 关键字描述</p>
<pre class=" language-javascript"><code class="language-javascript"> <span class="token operator">&lt;</span><span class="token operator">%</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>page<span class="token punctuation">.</span>keywords<span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span> <span class="token operator">%</span><span class="token operator">></span>
    <span class="token operator">&lt;</span>meta name<span class="token operator">=</span><span class="token string">"keywords"</span> content<span class="token operator">=</span><span class="token string">"&lt;%= page.keywords %>,&lt;%= config.keywords %>"</span><span class="token operator">></span>
 <span class="token operator">&lt;</span><span class="token operator">%</span> <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>config<span class="token punctuation">.</span>keywords<span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span> <span class="token operator">%</span><span class="token operator">></span>
    <span class="token operator">&lt;</span>meta name<span class="token operator">=</span><span class="token string">"keywords"</span> content<span class="token operator">=</span><span class="token string">"&lt;%= config.keywords %>"</span><span class="token operator">></span>
  <span class="token operator">&lt;</span><span class="token operator">%</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token operator">%</span><span class="token operator">></span></code></pre>
]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo-rss</title>
    <url>/blogs/hexo-ssr.html</url>
    <content><![CDATA[<h1 id="Hexo-RSS-文章推送"><a href="#Hexo-RSS-文章推送" class="headerlink" title="Hexo - RSS - 文章推送"></a>Hexo - RSS - 文章推送</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢~~</p>
<p>使用 SSR 推送新文章给订阅者。</p>
<h2 id="一-下载-hexo-插件"><a href="#一-下载-hexo-插件" class="headerlink" title="一. 下载 hexo 插件"></a>一. 下载 hexo 插件</h2><pre class=" language-npm"><code class="language-npm">npm install hexo-generator-feed</code></pre>
<h2 id="启用"><a href="#启用" class="headerlink" title="启用"></a>启用</h2><pre class=" language-shell"><code class="language-shell">
# 配置 Rss 订阅
Plugins: 
- hexo-generate-feed</code></pre>
]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>用 Hexo 部署 github.io 静态网站 - 起源</title>
    <url>/blogs/hexo-start.html</url>
    <content><![CDATA[<h1 id="用-Hexo-部署-github-io-静态网站-起源"><a href="#用-Hexo-部署-github-io-静态网站-起源" class="headerlink" title="用 Hexo 部署 github.io 静态网站 - 起源"></a>用 Hexo 部署 github.io 静态网站 - 起源</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢~~</p>
<h5 id="特别说明-1"><a href="#特别说明-1" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <code>PR</code> 谢谢~~</p>
<h2 id="一-环境配置"><a href="#一-环境配置" class="headerlink" title="一. 环境配置"></a>一. 环境配置</h2><ol>
<li><p>安装 <code>Node.js</code> 和配置好 <code>Node.js</code> 的环境，输入 <code>node -v</code> 和 <code>npm -v</code>，检查是否安装成功</p>
</li>
<li><p>安装 <code>Git</code> 和配置好 <code>Git</code> 的环境，输入 <code>git --version</code>，检查是否安装成功</p>
</li>
</ol>
<h2 id="二-GitHub-账户注册与新建项目"><a href="#二-GitHub-账户注册与新建项目" class="headerlink" title="二. GitHub 账户注册与新建项目"></a>二. <code>GitHub</code> 账户注册与新建项目</h2><ol>
<li><p>登录 <code>GitHub</code> 官网进行账户注册，注册完成后点击右上角的 + 号的 <code>New repository</code> 新建一个项目，项目名称使用 “账户名.github.io”，并勾选 <code>Initialze this repository with a README</code></p>
</li>
<li><p>在建好的项目右侧的 <code>settings</code> 中，有一个 <code>Github Pages</code>，那儿有一个网址，这就是你刚刚部署的项目，能够通过外网访问它</p>
</li>
</ol>
<h2 id="三-Hexo-安装与配置"><a href="#三-Hexo-安装与配置" class="headerlink" title="三. Hexo 安装与配置"></a>三. <code>Hexo</code> 安装与配置</h2><h4 id="1-安装-Hexo，在合适的地方建立一个文件夹"><a href="#1-安装-Hexo，在合适的地方建立一个文件夹" class="headerlink" title="1. 安装 Hexo，在合适的地方建立一个文件夹"></a>1. 安装 Hexo，在合适的地方建立一个文件夹</h4><p>在该文件夹下打开 <code>Git Bash</code> ，输入以下命令即可安装 <code>Blog</code>：</p>
<pre class=" language-javascript"><code class="language-javascript">npm install hexo <span class="token operator">-</span>g</code></pre>
<p>检查 <code>hexo</code> 是否安装成功</p>
<pre class=" language-javascript"><code class="language-javascript">hexo <span class="token operator">-</span>v</code></pre>
<p>初始化该文件夹，若成功，可看见 <code>start blogging with hexo!</code>:</p>
<pre class=" language-javascript"><code class="language-javascript">  hexo init</code></pre>
<p>安装所需组件</p>
<pre class=" language-js"><code class="language-js"> hexo install</code></pre>
<p>生成静态页面，开始使用 <code>hexo</code></p>
<pre class=" language-js"><code class="language-js">hexo <span class="token function">generate</span><span class="token punctuation">(</span>hexo g<span class="token punctuation">)</span></code></pre>
<p>启动服务器，访问网址即可(若端口被占用，可使用 <code>hexo server -p 端口号</code>)</p>
<pre class=" language-js"><code class="language-js">hexo s</code></pre>
<h4 id="2-将-Hexo-与-Github-Pages-联系起来（如果-Git-已经连接过-Github-可忽略）。-设置-Git-的-user-name-和-email"><a href="#2-将-Hexo-与-Github-Pages-联系起来（如果-Git-已经连接过-Github-可忽略）。-设置-Git-的-user-name-和-email" class="headerlink" title="2. 将 Hexo 与 Github Pages 联系起来（如果 Git 已经连接过 Github 可忽略）。 设置 Git 的 user name 和 email"></a>2. 将 Hexo 与 Github Pages 联系起来（如果 Git 已经连接过 Github 可忽略）。 设置 Git 的 user name 和 email</h4><pre class=" language-javascript"><code class="language-javascript"> <span class="token template-string"><span class="token string">`git config --global user.name "用户名"`</span></span>
 <span class="token template-string"><span class="token string">`git config --global user.email "邮箱"`</span></span>）</code></pre>
<p>检查是否有 .ssh 文件(以下命令非 win 环境)：</p>
<pre class=" language-shell"><code class="language-shell"> cd ~/.ssh</code></pre>
<p>生成密钥：</p>
<pre class=" language-shell"><code class="language-shell">ssh-keygen -t rsa -C "邮箱"</code></pre>
<p>将密钥添加到 ssh-agent</p>
<pre class=" language-shell"><code class="language-shell">eval "$(ssh-agent -s)"
ssh-add ~/.ssh/id_rsa</code></pre>
<p>登录 Github，点击头像下的 settings，添加 ssh，点击 SSH and GPG keys，新建 New SSH key，将 is_rsa.pub 里的内容复制过来</p>
<p>用以下命令查看是否添加成功，出现Hi后加你的用户名就是成功了：</p>
<pre class=" language-shell"><code class="language-shell">ssh -T git@github.com</code></pre>
<h4 id="3-配置-Deployment"><a href="#3-配置-Deployment" class="headerlink" title="3. 配置 Deployment"></a>3. 配置 Deployment</h4><p>在文件夹根目录中找到 <code>_config.yml</code> 文件，在末尾找到 deploy` 并修改</p>
<pre class=" language-yml"><code class="language-yml">  deploy：
    type: git
    repository: git@github.com:用户名/用户名.github.io.git （即用于Clone的SSH的地址）
    branch: master</code></pre>
<p>注意每个冒号后面要空一格（英文格式下）</p>
<h4 id="4-新建博客，"><a href="#4-新建博客，" class="headerlink" title="4. 新建博客，"></a>4. 新建博客，</h4><p>输入 <code>hexo new post &quot;博客名&quot;</code>, 此时在 <strong>source/_posts</strong> 目录下便可以看到新建的文件,在生成、部署文章前，要安装一个扩展:</p>
<pre class=" language-javascript"><code class="language-javascript">npm installhexo<span class="token operator">-</span>deployer<span class="token operator">-</span>git <span class="token operator">--</span>save</code></pre>
<p>安装完成后便可提交到 <code>GitHub</code> 上</p>
<p>编好文章后（Markdown格式），输入以下命令即可:</p>
<pre class=" language-javascript"><code class="language-javascript">hexo deploy（hexo d）</code></pre>
<p>，便部署到GitHub上了。</p>
<p>部署成功后，你的仓库会多出很多文件，而使用  <code>https://用户名.github.io</code> 就可以看到你的网站。</p>
<h3 id="注意："><a href="#注意：" class="headerlink" title="注意："></a><strong>注意：</strong></h3><ol>
<li><p>每次对博客进行修改后需要先用  <code>hexo s</code> 进行界面查看，查看是否修改成功<br>然后使用 <code>hexo clean &amp;&amp; hexo g &amp;&amp; hexo d </code> 来完成部署</p>
</li>
<li><p>在 CMD 命令行中显示 node、npm、hexo 没有此命令时，需要将他们的 bin 的路径部署到环境变量中的系统变量下的 PATH 中</p>
</li>
</ol>
]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>high-performance-bloomfilter</title>
    <url>/blogs/high-performance-bloomfilter.html</url>
    <content><![CDATA[<h1 id="深入理解高性能利器-布隆过滤器"><a href="#深入理解高性能利器-布隆过滤器" class="headerlink" title="深入理解高性能利器 - 布隆过滤器"></a>深入理解高性能利器 - 布隆过滤器</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢 ~~</p>
<h2 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h2><p>布隆过滤器可以用于检索一个元素是否在一个集合中。它的优点是空间效率和查询时间都远远超过一般的算法，缺点是有一定的误识别率且删除困难。</p>
<p>布隆过滤器的使用场景比较多，比如我们现在讲的防止缓存穿透、垃圾邮件的检测等。Google chrome 浏览器使用 Bloom Filter 识别恶意链接，Goolge 在 BigTable 中也使用 Bloom Filter 以避免在硬盘中寻找不存在的条目。我公司使用布隆过滤器来对爬虫抓取的 Url 进行重复检查等。</p>
]]></content>
      <tags>
        <tag>分布式基础</tag>
      </tags>
  </entry>
  <entry>
    <title>high-performance-interface-equivalence</title>
    <url>/blogs/high-performance-interface-equivalence.html</url>
    <content><![CDATA[<h1 id="高性能-接口的冥等性"><a href="#高性能-接口的冥等性" class="headerlink" title="高性能 - 接口的冥等性"></a>高性能 - 接口的冥等性</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢 ~~</p>
<h2 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h2><p>幂等性是系统服务对外一种承诺，承诺只要调用接口成功，外部多次调用对系统的影响是一致的。声明为幂等的服务会认为外部调用失败是常态，并且失败之后必然会有重试。</p>
<h3 id="冥等的场景"><a href="#冥等的场景" class="headerlink" title="冥等的场景"></a>冥等的场景</h3><p>以SQL为例：</p>
<p>SELECT col1 FROM tab1 WHER col2=2，无论执行多少次都不会改变状态，是天然的幂等。<br>UPDATE tab1 SET col1=1 WHERE col2=2，无论执行成功多少次状态都是一致的，因此也是幂等操作。<br>UPDATE tab1 SET col1=col1+1 WHERE col2=2，每次执行的结果都会发生变化，这种不是幂等的。<br>insert into user(userid,name) values(1,’a’) 如userid为唯一主键，即重复操作上面的业务，只会插入一条用户数据，具备幂等性。<br>如userid不是主键，可以重复，那上面业务多次操作，数据都会新增多条，不具备幂等性。<br>delete from user where userid=1，多次操作，结果一样，具备幂等性</p>
<h2 id="如何保证接口的冥等性"><a href="#如何保证接口的冥等性" class="headerlink" title="如何保证接口的冥等性"></a>如何保证接口的冥等性</h2><p>token机制</p>
<p>1、服务端提供了发送token的接口。我们在分析业务的时候，哪些业务是存在幂等问题的，就必须在执行业务前，先去获取token，服务器会把token保存到redis中。</p>
<p>2、然后调用业务接口请求时，把token携带过去，一般放在请求头部。</p>
<p>3、服务器判断token是否存在redis中，存在表示第一次请求，然后删除token,继续执行业务。</p>
<p>4、如果判断token不存在redis中，就表示是重复操作，直接返回重复标记给client，这样就保证了业务代码，不被重复执行。</p>
<p>关键点 先删除token，还是后删除token。</p>
<p>后删除token：如果进行业务处理成功后，删除redis中的token失败了，这样就导致了有可能会发生重复请求，因为token没有被删除。这个问题其实是数据库和缓存redis数据不一致问题，后续会写文章进行讲解。</p>
<p>先删除token：如果系统出现问题导致业务处理出现异常，业务处理没有成功，接口调用方也没有获取到明确的结果，然后进行重试，但token已经删除掉了，服务端判断token不存在，认为是重复请求，就直接返回了，无法进行业务处理了。</p>
<p>先删除token可以保证不会因为重复请求，业务数据出现问题。出现业务异常，可以让调用方配合处理一下，重新获取新的token，再次由业务调用方发起重试请求就ok了。<br>token机制缺点<br>业务请求每次请求，都会有额外的请求（一次获取token请求、判断token是否存在的业务）。其实真实的生产环境中，1万请求也许只会存在10个左右的请求会发生重试，为了这10个请求，我们让9990个请求都发生了额外的请求。</p>
<p>乐观锁机制</p>
<p>这种方法适合在更新的场景中，update t_goods set count = count -1 , version = version + 1 where good_id=2 and version = 1<br>根据version版本，也就是在操作库存前先获取当前商品的version版本号，然后操作的时候带上此version号。我们梳理下，我们第一次操作库存时，得到version为1，调用库存服务version变成了2；但返回给订单服务出现了问题，订单服务又一次发起调用库存服务，当订单服务传如的version还是1，再执行上面的sql语句时，就不会执行；因为version已经变为2了，where条件就不成立。这样就保证了不管调用几次，只会真正的处理一次。<br>乐观锁主要使用于处理读多写少的问题</p>
<p>唯一主键<br>这个机制是利用了数据库的主键唯一约束的特性，解决了在insert场景时幂等问题。但主键的要求不是自增的主键，这样就需要业务生成全局唯一的主键。</p>
<p>如果是分库分表场景下，路由规则要保证相同请求下，落地在同一个数据库和同一表中，要不然数据库主键约束就不起效果了，因为是不同的数据库和表主键不相关。</p>
<p>防重表<br>使用订单号orderNo做为去重表的唯一索引，把唯一索引插入去重表，再进行业务操作，且他们在同一个事务中。这个保证了重复请求时，因为去重表有唯一约束，导致请求失败，避免了幂等问题。这里要注意的是，去重表和业务表应该在同一库中，这样就保证了在同一个事务，即使业务操作失败了，也会把去重表的数据回滚。这个很好的保证了数据一致性。</p>
<p>唯一ID<br>调用接口时，生成一个唯一id，redis将数据保存到集合中（去重），存在即处理过。</p>
<p>备注：</p>
<p>原文：先删除token：如果系统出现问题导致业务处理出现异常，业务处理没有成功，接口调用方也没有获取到明确的结果，然后进行重试，但token已经删除掉了，服务端判断token不存在，认为是重复请求，就直接返回了，无法进行业务处理了。<br>这里你的理解很不正确，每次接口操作的token不同，不是业务推进的关键，token仅仅是快速判断是否重新提交的依据。即使因为业务处理失败，造成上次请求的缓存的token被删除，但是需要操作的业务并没有完成（状态依然是未确认、未提交、未修改之类的状态），后端业务肯定还要依据业务的完成度，来判断本次请求是忽略（提示已完成，不必重复提交），还是下发新的token，重新执行业务流程才对！</p>
]]></content>
      <tags>
        <tag>分布式基础</tag>
      </tags>
  </entry>
  <entry>
    <title>重点内容</title>
    <url>/blogs/important-dong-task.html</url>
    <content><![CDATA[<h2 id="当前网站建设的重点内容"><a href="#当前网站建设的重点内容" class="headerlink" title="当前网站建设的重点内容"></a>当前网站建设的重点内容</h2><h5 id="1-由于目录内容太多，需要对应建设一个-wiki-进行维护"><a href="#1-由于目录内容太多，需要对应建设一个-wiki-进行维护" class="headerlink" title="1. 由于目录内容太多，需要对应建设一个 wiki 进行维护"></a>1. 由于目录内容太多，需要对应建设一个 wiki 进行维护</h5><h5 id="2-文章内容迁移"><a href="#2-文章内容迁移" class="headerlink" title="2. 文章内容迁移"></a>2. 文章内容迁移</h5>]]></content>
      <tags>
        <tag>Starrier</tag>
      </tags>
  </entry>
  <entry>
    <title>文件传输异常</title>
    <url>/blogs/io-brokenpipeexception.html</url>
    <content><![CDATA[<h1 id="文件传输异常"><a href="#文件传输异常" class="headerlink" title="文件传输异常"></a>文件传输异常</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢 ~~</p>
]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>BigDecimal 最佳实践</title>
    <url>/blogs/java-basic-bigdecimal.html</url>
    <content><![CDATA[<h1 id="BigDecimal-最佳实践"><a href="#BigDecimal-最佳实践" class="headerlink" title="BigDecimal 最佳实践"></a>BigDecimal 最佳实践</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢 ~~</p>
<h2 id="1-BigDecimal-subtract"><a href="#1-BigDecimal-subtract" class="headerlink" title="1. BigDecimal.subtract()"></a>1. BigDecimal.subtract()</h2><p>返回一个BigDecimal，其值为 (this - subtrahend), 精度为 max(this.scale(), subtrahend.scale()).</p>
<pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BigDecimalDemo</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>

        <span class="token comment" spellcheck="true">// create 3 BigDecimal objects</span>
        BigDecimal bg1<span class="token punctuation">,</span> bg2<span class="token punctuation">,</span> bg3<span class="token punctuation">;</span>

        bg1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BigDecimal</span><span class="token punctuation">(</span><span class="token string">"100.123"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        bg2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BigDecimal</span><span class="token punctuation">(</span><span class="token string">"50.56"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment" spellcheck="true">// subtract bg1 with bg2 and assign result to bg3</span>
        bg3 <span class="token operator">=</span> bg1<span class="token punctuation">.</span><span class="token function">subtract</span><span class="token punctuation">(</span>bg2<span class="token punctuation">)</span><span class="token punctuation">;</span>

        String str <span class="token operator">=</span> <span class="token string">"The Result of Subtraction is "</span> <span class="token operator">+</span> bg3<span class="token punctuation">;</span>

        <span class="token comment" spellcheck="true">// print bg3 value</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span> str <span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre>
<h2 id="2-NumberFormatException"><a href="#2-NumberFormatException" class="headerlink" title="2. NumberFormatException"></a>2. NumberFormatException</h2><p>一般是由于输入值为空字符串导致的。</p>
]]></content>
      <tags>
        <tag>java basic</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 集合 ArrayList 详解</title>
    <url>/blogs/java-basic-collection-arraylist.html</url>
    <content><![CDATA[<h1 id="Java-集合-ArrayList-详解"><a href="#Java-集合-ArrayList-详解" class="headerlink" title="Java 集合 ArrayList 详解"></a>Java 集合 ArrayList 详解</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢~~</p>
<p>函数签名：</p>
<pre class=" language-javascript"><code class="language-javascript"> <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span>E<span class="token operator">></span> <span class="token keyword">extends</span> <span class="token class-name">AbstractList</span><span class="token operator">&lt;</span>E<span class="token operator">></span> 
 <span class="token keyword">implements</span> <span class="token class-name">List</span><span class="token operator">&lt;</span>E<span class="token operator">></span><span class="token punctuation">,</span>RandomAccess<span class="token punctuation">,</span>Cloneable<span class="token punctuation">,</span>java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>Serializable</code></pre>
<p><strong>AbastrctList</strong>: 抽象父类，提供了 List 的方法。添加、删除、修改、遍历等。</p>
<p><strong>RandomAccess</strong>： 可随机访问。由 Lis 实现，为 List 提供快速访问功能。在 ArrayList 中，我们可以通过元素的序号快速获取元素对象；这就是快速随机访问。</p>
<p><strong>Clonable</strong>：可拷贝</p>
<p><strong>Serializable</strong> 可序列化</p>
<h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><pre class=" language-javascript"><code class="language-javascript"><span class="token function">ArrayList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token function">ArrayList</span><span class="token punctuation">(</span>int capacity<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token function">ArrayList</span><span class="token punctuation">(</span>Collection<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">E</span><span class="token operator">></span> Collection<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
]]></content>
      <tags>
        <tag>Java 基础</tag>
      </tags>
  </entry>
  <entry>
    <title>CopyOnWriteArrayList实现原理及源码分析</title>
    <url>/blogs/java-basic-collection-copyonwritearraylist.html</url>
    <content><![CDATA[<h1 id="CopyOnWriteArrayList-实现原理及源码分析"><a href="#CopyOnWriteArrayList-实现原理及源码分析" class="headerlink" title="CopyOnWriteArrayList 实现原理及源码分析"></a>CopyOnWriteArrayList 实现原理及源码分析</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢 ~~</p>
<h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><ul>
<li><p><a href="https://www.cnblogs.com/chengxiao/p/6881974.html">CopyOnWriteArrayList实现原理及源码分析</a></p>
</li>
<li><p><a href="https://blog.csdn.net/ThinkWon/article/details/102508258">并发容器之CopyOnWriteArrayList详解</a></p>
</li>
</ul>
]]></content>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>java-basic-collection-linked-blocking-queue</title>
    <url>/blogs/java-basic-collection-linked-blocking-queue.html</url>
    <content><![CDATA[<h1 id="LinkedBlockingQueue"><a href="#LinkedBlockingQueue" class="headerlink" title="LinkedBlockingQueue"></a>LinkedBlockingQueue</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢~~</p>
<p><code>LinkedBlockingQueue</code> 由单链表实现，只能从 <code>head</code> 中取元素，向 <code>tail</code> 添加元素。添加元素预计获取元素都有独立的锁，即 <code>LinkedBlockingQueue</code> 是读写分离的，可以并行执行。<code>LinkedBlockingQueue</code> 采用可重入锁（<code>ReentrantLock</code>）来保证并发环境下的线程安全。</p>
<p>函数签名：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LinkedBlockingDeque</span><span class="token operator">&lt;</span>E<span class="token operator">></span>
    <span class="token keyword">extends</span> <span class="token class-name">AbstractQueue</span><span class="token operator">&lt;</span>E<span class="token operator">></span>
    <span class="token keyword">implements</span> <span class="token class-name">BlockingDeque</span><span class="token operator">&lt;</span>E<span class="token operator">></span><span class="token punctuation">,</span> java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>Serializable <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span></code></pre>
<p>构造器</p>
<ol>
<li>无参构造器(默认的构造器)。默认容量是 Integer.MAX_VALUE，可能存在队列还没有满，但是内存已经满了。</li>
</ol>
<pre class=" language-java"><code class="language-java">    <span class="token keyword">public</span> <span class="token function">LinkedBlockingDeque</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">(</span>Integer<span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre>
<ol start="2">
<li>指定大小的构造器</li>
</ol>
<pre class=" language-java"><code class="language-java"> <span class="token keyword">public</span> <span class="token function">LinkedBlockingDeque</span><span class="token punctuation">(</span><span class="token keyword">int</span> capacity<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>capacity <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>capacity <span class="token operator">=</span> capacity<span class="token punctuation">;</span>
    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre>
<ol start="3">
<li>接入一个容器的构造器</li>
</ol>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token function">LinkedBlockingDeque</span><span class="token punctuation">(</span>Collection<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">E</span><span class="token operator">></span> c<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">(</span>Integer<span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">addAll</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre>
<h3 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a>常用操作</h3><table>
<thead>
<tr>
<th>method</th>
<th>function</th>
</tr>
</thead>
<tbody><tr>
<td>take()</td>
<td>首选，当队列为空时候</td>
</tr>
<tr>
<td>poll()</td>
<td>弹出队列顶部元素，队列为空时，返回空</td>
</tr>
<tr>
<td>peek()</td>
<td>返回队列顶部元素，但顶元素不弹出，队列为空时，返回 null</td>
</tr>
<tr>
<td>remove（object）</td>
<td>移除某个元素，队列为空时，抛出异常。成功移除返回true</td>
</tr>
</tbody></table>
<h5 id="判断队列是否为空"><a href="#判断队列是否为空" class="headerlink" title="判断队列是否为空"></a>判断队列是否为空</h5><p>size() 方法会遍历整个队列，时间复杂度为 O(n)，所以最好选择 isEmpty()</p>
<h2 id="take"><a href="#take" class="headerlink" title="take():"></a>take():</h2><pre class=" language-java"><code class="language-java"> <span class="token keyword">public</span> E <span class="token function">takeFirst</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
        <span class="token keyword">final</span> ReentrantLock lock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>lock<span class="token punctuation">;</span>
        lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">try</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
            E x<span class="token punctuation">;</span>
            <span class="token keyword">while</span> <span class="token punctuation">(</span> <span class="token punctuation">(</span>x <span class="token operator">=</span> <span class="token function">unlinkFirst</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> null<span class="token punctuation">)</span>
                notEmpty<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span> x<span class="token punctuation">;</span>
        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">finally</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
            lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre>
<h2 id="put"><a href="#put" class="headerlink" title="put():"></a>put():</h2><pre class=" language-java"><code class="language-java">put元素原理

基本过程：

<span class="token number">1</span><span class="token punctuation">.</span>判断元素是否为null，为null抛出异常

<span class="token number">2</span><span class="token punctuation">.</span>加锁<span class="token punctuation">(</span>可中断锁<span class="token punctuation">)</span>

<span class="token number">3</span><span class="token punctuation">.</span>判断队列长度是否到达容量，如果到达一直等待

<span class="token number">4</span><span class="token punctuation">.</span>如果没有队满，<span class="token function">enqueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span>在队尾加入元素

<span class="token number">5</span><span class="token punctuation">.</span>队列长度加<span class="token number">1</span>，此时如果队列还没有满，调用signal唤醒其他堵塞队列
</code></pre>
<h3 id="二-添加数据"><a href="#二-添加数据" class="headerlink" title="二. 添加数据"></a>二. 添加数据</h3><ul>
<li><p>poll()：弹出队顶元素，队列为空时，返回空</p>
</li>
<li><p>peek()：和 <code>poll</code> 类似，返回队队顶元素，但顶元素不弹出。队列为空时返回 <code>null</code></p>
</li>
<li><p>remove(Object o)：移除某个元素，队列为空时抛出异常。成功移除返回 <code>true</code></p>
</li>
</ul>
<h3 id="三-取出数据"><a href="#三-取出数据" class="headerlink" title="三. 取出数据"></a>三. 取出数据</h3><p>添加数据</p>
<ul>
<li><p>put()：首选。队满是阻塞</p>
</li>
<li><p>offer()：队满时返回 <code>false</code></p>
</li>
</ul>
<p>判断队列是否为空</p>
<p><code>size()</code> 方法会遍历整个队列，时间复杂度为O(n),所以最好选用 <code>isEmtpy()</code></p>
<p>LinkedBlockingQueue与LinkedBlockingDeque比较</p>
<p>LinkedBlockingDeque和LinkedBlockingQueue的相同点在于：</p>
<ol>
<li>基于链表</li>
<li>容量可选，不设置的话，就是Int的最大值</li>
</ol>
<p>和LinkedBlockingQueue的不同点在于：</p>
<ol>
<li>双端链表和单链表</li>
<li>不存在哨兵节点</li>
<li>一把锁+两个条件</li>
</ol>
<p>AtomicInteger的getAndIncrment和getAndDcrement()等方法，这些方法分为两步，get和increment(decrement)，在get和increment中间可能有其他线程进入，导致多个线程get到的数值是相同的，也会导致多个线程累加后的值其实累加1.在这种情况下，使用volatile也是没有效果的，因为get之后没有对值进行修改，不能触发volatile的效果。</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ProducerAndConsumer</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>

        <span class="token keyword">try</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
            BlockingQueue queue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedBlockingQueue</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

            ExecutorService executor <span class="token operator">=</span> Executors<span class="token punctuation">.</span><span class="token function">newFixedThreadPool</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            Produer producer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Produer</span><span class="token punctuation">(</span>queue<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token number">3</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
                executor<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span>producer<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
            executor<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Consumer</span><span class="token punctuation">(</span>queue<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

            executor<span class="token punctuation">.</span><span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>

    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">Produer</span> <span class="token keyword">implements</span>  <span class="token class-name">Runnable</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>

    <span class="token keyword">private</span> BlockingQueue queue<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">int</span> nums <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//循环次数</span>

    <span class="token comment" spellcheck="true">//标记数据编号</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">volatile</span> AtomicInteger count <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AtomicInteger</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">boolean</span> isRunning <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token function">Produer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token function">Produer</span><span class="token punctuation">(</span>BlockingQueue queue<span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>queue <span class="token operator">=</span> queue<span class="token punctuation">;</span>
    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
        String data <span class="token operator">=</span> null<span class="token punctuation">;</span>
        <span class="token keyword">try</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"开始生产数据"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"-----------------------"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

          <span class="token keyword">while</span><span class="token punctuation">(</span>nums<span class="token operator">></span><span class="token number">0</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
                nums<span class="token operator">--</span><span class="token punctuation">;</span>
                count<span class="token punctuation">.</span><span class="token function">decrementAndGet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

                Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span> <span class="token string">" :生产者生产了一个数据"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                queue<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>count<span class="token punctuation">.</span><span class="token function">getAndIncrement</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token keyword">catch</span><span class="token punctuation">(</span>Exception e<span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">interrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token keyword">finally</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"生产者线程退出！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">Consumer</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>

    <span class="token keyword">private</span> BlockingQueue queue<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">int</span> nums <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">boolean</span> isRunning <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token function">Consumer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token function">Consumer</span><span class="token punctuation">(</span>BlockingQueue queue<span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>queue <span class="token operator">=</span> queue<span class="token punctuation">;</span>
    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>

        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"消费者开始消费"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"-------------------------"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">while</span><span class="token punctuation">(</span>nums<span class="token operator">></span><span class="token number">0</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
            nums<span class="token operator">--</span><span class="token punctuation">;</span>
            <span class="token keyword">try</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
                <span class="token keyword">while</span><span class="token punctuation">(</span>isRunning<span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
                    <span class="token keyword">int</span> data <span class="token operator">=</span> <span class="token punctuation">(</span>Integer<span class="token punctuation">)</span>queue<span class="token punctuation">.</span><span class="token function">take</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"消费者消费的数据是"</span> <span class="token operator">+</span> data<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>

            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token keyword">catch</span><span class="token punctuation">(</span>Exception e<span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">interrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token keyword">finally</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"消费者线程退出!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>

        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre>
]]></content>
      <tags>
        <tag>Java 基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 集合 Set 详解</title>
    <url>/blogs/java-basic-collection-set.html</url>
    <content><![CDATA[<h1 id="Java-集合-Set-详解"><a href="#Java-集合-Set-详解" class="headerlink" title="Java 集合 Set 详解"></a>Java 集合 Set 详解</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢~~</p>
<h5 id="特别说明-1"><a href="#特别说明-1" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 PR 谢谢~~</p>
<p>Set 不允许包含相同的元素，如果试图把两个相同的元素加入同一个集合中，add 方法返回 false。Set 判断两个对象相同不是使用 == 运算符，而是根据 equals 方法。也就是说，只要两个对象用 equals 比较后返回 true，Set 就不会接受这两个对象。</p>
<h3 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h3><p>不能保证元素的排列顺序，顺序有可能发生变化，不是同步的，集合元素可以是 null，但只能放入一个 null。底层是哈希表（是一个元素为链表的数组）。HashSet 其实使用 HashMap 实现的，HashMap 是 Map 接口的实现类。调用 HashSet 的 add 方法，其实就是在调用 HashMap 中的 put 方法，put 方法主要涉及两个方面。</p>
<ol>
<li><p>对象的 hash 值，通过调用 hash() 得到，这个方法是由 hashCode() 经过操作实现的，由 hashCode() 的值控制。</p>
</li>
<li><p>创建了 hash 表，hash 表会将每一个 hash 值收入，然后比较：</p>
<ol>
<li>先在 hash 表中查找看是否有这个 hash 值（第一次比较，看 hash 表中是否有当前元素的 hahs 值（这个值有 hahsCode 操作的得到），如果没有，直接将这个 hahs 值对应的对象添加到 HashSet 中，如果有，还需要进行第二次比较）。</li>
<li>如果 hash 表有这个 hash 值，那么获取列表中的这个 hash 对应的对象，如果这两个对象的地址值(e.key == key)或者key.equal(e.key)。（第二次比较，如果两个对象的 hahs 值相同，还是不能认为是同一个对象，还要比较两个对象的地址值，或者是 equals() 这里是一个 ||，只要有一个满足相等，就可以认为是同一个元素，不添加）。</li>
</ol>
</li>
<li><p>为什么存储字符串的时候，字符串相同的时候，只存储了一个？因为 String 类重写了 hashCode 和 equals，而 String 类的 hashCode 值和 equals 结果都是由字符串的内容决定的。</p>
</li>
<li><p>如果 HashSet 中收入的是自定义对象，那如何实现唯一呢？</p>
<ol>
<li>通过上述的 String 类的分析，我们知道，HashSet 中实现唯一的两个方法，先是比较 hash 值（这个由 hahsCode 值控制），如果这个值相同，那么再比较地址值或者 equals，所以我们可以通过重写 hahsCode 和 queals 来实现对自定义对象的唯一性判断。</li>
<li>只要重写了 equals，让这个方法比较的是对象的内容，那么就可以排除掉相同的对象。让 hashCode 返回一个常数，这样 hash 就相等了，然后通过 equals 判断，但这样会导致每一个新对象都要和老对象进行比较，太麻烦，所以我们可以仿照 String 类中对 hashCode 重写的方式，同样的有对象的成员变量来决定这个对象的 hashCode 值，equals 也是通过比较对象的成员变量是否相等。这样既可以得到最后的结论。</li>
</ol>
</li>
</ol>
<h3 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h3><p>底层数据结构是红黑树（是一个自平衡的二叉树）。TreeSet 是如何保证元素排列方式，以及元素的唯一性呢。</p>
<p>TreeSet 是 SortedSet 接口的唯一实现类，TreeSet 可以确保集合元素处于排序状态，TreeSet 支持两种排序方式，自然排序和定制排序，其中自然排序为默认的排序方式。向 TreeSet 中加入的应该是同一类的对象。TreeSet 判断两个对象不相等的方式是两个对象通过 equals 方法返回 false 或者是通过 CompareTo 方法比较没有返回 0。</p>
<h4 id="自然排序"><a href="#自然排序" class="headerlink" title="自然排序"></a>自然排序</h4><p>自然排序使用要排序元素的 CompareTo(Object object) 方法来比较元素之间的大小关系，然后将元素按照升序排列。Java 提供了一个 Comparable 接口，改接口中定义了一个 compareTo(Object obj) 方法，该方法返回一个整数值，实现了该接口的对象就可以比较大小。</p>
<p>obj.compareTo(obj2) 方法如果返回 0，则说明被比较的两个对象相等，如果返回一个整数，则表明 obj1 大于 obj2，如果是负数，则表明 obj1 小于 obj2。</p>
<p>如果我们将两个对象的 equals 方法总是返回 false，则这两个对象的 compareTo 方法总是返回 0。</p>
<h4 id="定制排序"><a href="#定制排序" class="headerlink" title="定制排序"></a>定制排序</h4><p>自然排序是根据集合元素的大小，以升序排列，如果要定制排序，应该使用 Comparatoer 接口，实现 int compare(a,b)方法。</p>
<h3 id="LinkedLisst"><a href="#LinkedLisst" class="headerlink" title="LinkedLisst"></a>LinkedLisst</h3><p>LinkedHashSet 集合同样是根据元素的 hashCode 值来决定元素的存储位置，但是它同时使用链表维护元素的次序。这样使得元素看起来像是以插入顺序保存的，也就是说，当遍历该集合时，LinkedListSet 将以元素的添加顺序访问集合的元素。LinkedListSet 在迭代访问 Set 中的全部元素时，性能比 HashSet 好，但是插入时性能稍微逊色于 HashSet。</p>
]]></content>
      <tags>
        <tag>Java 基础</tag>
      </tags>
  </entry>
  <entry>
    <title>java 数据机构 -concurrenthashmap</title>
    <url>/blogs/java-basic-concurrenthashmap.html</url>
    <content><![CDATA[<h1 id="java-数据结构-concurrenthashmap"><a href="#java-数据结构-concurrenthashmap" class="headerlink" title="java 数据结构 -concurrenthashmap"></a>java 数据结构 -concurrenthashmap</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢 ~~</p>
<p>ConcurrentHashMap</p>
<p>诸如  size isEmpty 这类方法，会存在中间态，只能用于参考不能用于流程计算，否则也会存在线程安全问题。</p>
<p>putAll 这样的数据也不安全。可能会获取到部分数据</p>
<h5 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h5><ul>
<li><p><a href="http://antsnote.club/2018/05/31/Java-ConcurrentHashMap/">1</a></p>
</li>
<li><p><a href="https://www.cnblogs.com/jxxblogs/p/12517197.html">ConcurrentHashMap 原理</a></p>
</li>
</ul>
]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>java-basic-condition</title>
    <url>/blogs/java-basic-condition.html</url>
    <content><![CDATA[<h1 id="Condition"><a href="#Condition" class="headerlink" title="Condition"></a>Condition</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢~~</p>
<p>Condition 与 Object 的对比</p>
<table>
<thead>
<tr>
<th>Condition</th>
<th>Object</th>
</tr>
</thead>
<tbody><tr>
<td>awati()</td>
<td>wait()</td>
</tr>
<tr>
<td>signal()</td>
<td>notify()</td>
</tr>
<tr>
<td>signalAll()</td>
<td>notifyAll()</td>
</tr>
</tbody></table>
<p><strong>Note</strong>:</p>
<p>Object  中的这些方法需要和同步锁（“synchronized”）捆绑使用，而 Condition 则是与 “互斥锁/共享锁”捆绑使用。</p>
<p>ReentrantLock 的 Condition 实现了等待/通知模型。Condition 的 await() 方法是是释放锁的。因为如果 await() 不释放锁，那么 singal()  方法就无法被调用。</p>
<h5 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h5><ul>
<li><p><a href="https://blog.csdn.net/qq_22798455/article/details/81335515">Java多线程8：Condition的详细介绍</a></p>
</li>
<li><p><a href="https://www.cnblogs.com/gemine/p/9039012.html">Java并发之Condition</a></p>
</li>
</ul>
]]></content>
      <tags>
        <tag>Java 基础</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解 Java HashMap 及对应面试题</title>
    <url>/blogs/java-basic-hashmap.html</url>
    <content><![CDATA[<h1 id="深入理解-Java-HashMap-及对应面试题"><a href="#深入理解-Java-HashMap-及对应面试题" class="headerlink" title="深入理解 Java HashMap 及对应面试题"></a>深入理解 Java HashMap 及对应面试题</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢 ~~</p>
<p>HashMap 非线程安全的类。</p>
<blockquote>
<p>线程安全的类：<code>HashTable</code>，<code>ConcurrentHashMap</code>,<code>Collections.synchronizedMap</code></p>
</blockquote>
<p>Hash 冲突解决方案</p>
<ol>
<li>链地址法</li>
<li>Rehash</li>
<li>公共溢出区</li>
<li>线性探测法：hash(key) 冲突 则查看 hash(key) +n /mod 是否有冲突。</li>
</ol>
<h4 id="1-为什么不用-hash-进行分布式存储"><a href="#1-为什么不用-hash-进行分布式存储" class="headerlink" title="1. 为什么不用 hash 进行分布式存储"></a>1. 为什么不用 <code>hash</code> 进行分布式存储</h4><p>一致性 hash 存在什么问题，数据倾斜如何处理。</p>
<p>为什么扩容的时候是 2 的冥次方</p>
<ul>
<li>h&amp;(n-1) 增大随机性，提高数组的利用率</li>
<li>扩容的时候，移动数据的时候更加方便<br>rehash时的取余操作，hash % length == hash &amp; (length - 1)这个关系只有在length等于二的幂次方时成立，位运算能比%高效得多。</li>
</ul>
<p>扰动函数</p>
<p>get 方法如何确定key在数组中的位置，先通过 hash(key) 再通过 tab[(n-1) &amp; hash] 来确定位置。</p>
<ul>
<li>混合高位来增大随机性 hash(key)。</li>
<li>尽量保证数据落在不同的地方，均匀分布在不同的位置。</li>
</ul>
<h5 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h5><ul>
<li><p><a href="https://blog.csdn.net/weixin_33748818/article/details/91994025">Java集合-HashMap扰动函数</a></p>
</li>
<li><p><a href="https://juejin.cn/post/6844904013909983245#heading-26">HashMap面试题，看这一篇就够了！</a></p>
</li>
<li><p><a href="https://www.bilibili.com/read/cv6114752">阿里面试官最喜欢问的21个HashMap面试题</a></p>
</li>
<li><p><a href="https://blog.csdn.net/xt199711/article/details/113918057">【Java自顶向下】HashMap面试题（2021最新版）</a></p>
</li>
<li><p><a href="https://zhuanlan.zhihu.com/p/388105370">HashMap面试题集源码解答</a></p>
</li>
<li><p><a href="https://www.zhihu.com/column/c_1396819332995809280">hashmap 面试相关</a></p>
</li>
<li><p><a href="https://blog.csdn.net/weixin_33748818/article/details/91994025">扰动函数</a></p>
</li>
</ul>
]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java - final</title>
    <url>/blogs/java-basic-final.html</url>
    <content><![CDATA[<h1 id="Java-final"><a href="#Java-final" class="headerlink" title="Java - final"></a>Java - final</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢 ~~</p>
<p>final 的可见性</p>
<p>保障构造函数中，对象不溢出的情况下，其他线程拿到的是初始化后的对象。</p>
<h5 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h5><ul>
<li><a href=""></a></li>
</ul>
]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>java 初始化时机</title>
    <url>/blogs/java-basic-initialize-time.html</url>
    <content><![CDATA[<h1 id="Java-初始化时机"><a href="#Java-初始化时机" class="headerlink" title="Java 初始化时机"></a>Java 初始化时机</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢~~</p>
<h5 id="特别说明-1"><a href="#特别说明-1" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 PR 谢谢~~</p>
<p>Java 初始化时机</p>
<h4 id="1-使用-new-关键字"><a href="#1-使用-new-关键字" class="headerlink" title="1. 使用 new 关键字"></a>1. 使用 new 关键字</h4><blockquote>
<p>由执行类实例创建表达式而引起的对象创建。</p>
</blockquote>
]]></content>
      <tags>
        <tag>Java 基础</tag>
      </tags>
  </entry>
  <entry>
    <title>java-basic-inner-class</title>
    <url>/blogs/java-basic-inner-class.html</url>
    <content><![CDATA[<h1 id="Java-基础-内部类"><a href="#Java-基础-内部类" class="headerlink" title="Java 基础 - 内部类"></a>Java 基础 - 内部类</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢 ~~</p>
<h5 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h5><ul>
<li><a href="https://blog.csdn.net/liuxiao723846/article/details/108006609">Java内部类（一篇就够）</a></li>
</ul>
]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>int和Integer深入分析</title>
    <url>/blogs/java-basic-int-integer.html</url>
    <content><![CDATA[<h1 id="int和Integer深入分析"><a href="#int和Integer深入分析" class="headerlink" title="int和Integer深入分析"></a>int和Integer深入分析</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢 ~~</p>
<h5 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h5><ul>
<li><a href="https://segmentfault.com/a/1190000016168233">int和Integer深入分析</a></li>
</ul>
]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 基础 IO-NIO-AIO</title>
    <url>/blogs/java-basic-io.html</url>
    <content><![CDATA[<h1 id="Java-基础-IO-NIO-AIO"><a href="#Java-基础-IO-NIO-AIO" class="headerlink" title="Java 基础 IO-NIO-AIO"></a>Java 基础 IO-NIO-AIO</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢 ~~</p>
<h5 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h5><ul>
<li><a href=""></a></li>
</ul>
]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>java-basic-introduce</title>
    <url>/blogs/java-basic-introduce.html</url>
    <content><![CDATA[<h1 id="Java-基础"><a href="#Java-基础" class="headerlink" title="Java 基础"></a>Java 基础</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢 ~~</p>
<h5 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h5><ul>
<li><a href=""></a></li>
</ul>
]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构 - LinkedHahsMap</title>
    <url>/blogs/java-basic-linkedhashmap.html</url>
    <content><![CDATA[<h1 id="数据结构-LinkedHahsMap"><a href="#数据结构-LinkedHahsMap" class="headerlink" title="数据结构 - LinkedHahsMap"></a>数据结构 - LinkedHahsMap</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢 ~~</p>
<h5 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h5><ul>
<li><a href="https://blog.csdn.net/qq_40050586/article/details/105851970">超详细LinkedHashMap解析</a></li>
</ul>
]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>String 详解</title>
    <url>/blogs/java-basic-string-principle.html</url>
    <content><![CDATA[<h1 id="String-详解"><a href="#String-详解" class="headerlink" title="String 详解"></a>String 详解</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢 ~~</p>
<h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><ul>
<li><a href="https://segmentfault.com/a/1190000018211009">你有没有想过: 为什么Java中String是不可变的？</a></li>
</ul>
]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解 Java static 关键字</title>
    <url>/blogs/java-basic-static.html</url>
    <content><![CDATA[<h1 id="深入理解-Java-static-关键字"><a href="#深入理解-Java-static-关键字" class="headerlink" title="深入理解 Java static 关键字"></a>深入理解 Java static 关键字</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢~~</p>
<h3 id="1-修饰成员变量"><a href="#1-修饰成员变量" class="headerlink" title="1. 修饰成员变量"></a>1. 修饰成员变量</h3><h3 id="2-修饰成员方法"><a href="#2-修饰成员方法" class="headerlink" title="2. 修饰成员方法"></a>2. 修饰成员方法</h3><h3 id="3-静态块"><a href="#3-静态块" class="headerlink" title="3. 静态块"></a>3. 静态块</h3><h3 id="4-静态导包"><a href="#4-静态导包" class="headerlink" title="4. 静态导包"></a>4. 静态导包</h3><pre class=" language-Java"><code class="language-Java"> // PrintTest.java
 package org.starrier.test;
 public class PrintTest&#123;
     public static void print(Object object)&#123;
         System.out.println(object);
     &#125;
 &#125;

 // Test.java
 import static org.starrier.test;

 public class Test&#123;
     public static void main(String [] args)&#123;
         print("Hello World");
     &#125;
 &#125;</code></pre>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li>用来修饰成员变量，该变量就会成为类的成员，从而实现所有对象对该成员变量的共享。</li>
<li>用来修饰成员方法，将其变为类方法，可以直接使用<strong>类名.方法名</strong>的方式调用，常用于工具类。</li>
<li>静态块，将多个类成员放在一起初始化，是程序更加规整。</li>
<li>静态导包，将类的方法直接导入到当前类，从而直接使用<strong>方法名</strong>即可实现类方法的调用。</li>
</ol>
<p>当 Java 类中包含 static 修饰的静态字段，或者有使用 static｛｝块包裹的代码时，编译后便会在字节码文件中包含一个名为&lt;clinit&gt;() 的方法，JVM 在吃刷阶段便会调用该方法。注意，该方法仅可以被 Java 编译器生成把那个由 JVM 调用，程序开发者无法自定义一个同名方法，更无法直接在 Java 程序中调用。</p>
<p>Java 的初始化顺序：</p>
<p>父类的静态构造成员初始化 ——》 父类的静态代码块 ——》 子类的静态成员初始化 ——》 子类的静态代码块 ——》 父类的代码块 ——》 父类的构造方法 ——》 子类的代码块 ——》 子类的构造方法</p>
]]></content>
      <tags>
        <tag>Java 基础</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解 Java UUID 及其实战应用</title>
    <url>/blogs/java-basic-uuid.html</url>
    <content><![CDATA[<h1 id="深入理解-Java-UUID-及其实战应用"><a href="#深入理解-Java-UUID-及其实战应用" class="headerlink" title="深入理解 Java UUID 及其实战应用"></a>深入理解 Java UUID 及其实战应用</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢 ~~</p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><code>UUID</code>：<code>Universally Unique IDentifier</code>，也被称为 <code>GUID(Globally Unique IDentifier)</code>。是一种由算法生成的唯一标识，它实质上是一个 <code>128</code> 位长的二进制整数。通常表示成 <code>32</code> 个 <code>16</code> 进制数组成的字符串，如：<code>21EC2020-3AEA-1069-A2DD-08002B30309D</code>。关于 <code>UUID</code> 标准的 <code>rfc</code> 定义详见<a href="http://www.ietf.org/rfc/rfc4122.txt">标准规范</a> 。 当然，<code>GUID</code> 一词有时也专指微软对 UUID标准的实现，用于Windows操作系统中。 </p>
]]></content>
      <tags>
        <tag>分布式基础</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解 Java 基础 重写和重载</title>
    <url>/blogs/java-basic-overloading-overwrite.html</url>
    <content><![CDATA[<h1 id="深入理解-Java-基础-重写和重载"><a href="#深入理解-Java-基础-重写和重载" class="headerlink" title="深入理解 Java 基础 重写和重载"></a>深入理解 Java 基础 重写和重载</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢 ~~</p>
<h5 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h5><ul>
<li><a href=""></a></li>
</ul>
]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解 java 可变参数 - 实战</title>
    <url>/blogs/java-basic-variable-parameter.html</url>
    <content><![CDATA[<h1 id="深入理解-java-可变参数-实战"><a href="#深入理解-java-可变参数-实战" class="headerlink" title="深入理解 java 可变参数 - 实战"></a>深入理解 java 可变参数 - 实战</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢~~</p>
<h2 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h2><p>Java 要求实参和形参的数量和类型必须一致，而形参的数目是在方法定义时就已经确定了。重载允许我们扩展参数的类型和数目，但如果需求不同的内容过多，就会产生过多的重载方法。</p>
<p>在这种情况下，我们可以用数组来包裹多个参数，然后将其作为参数进行传递。</p>
<p>在不确定方法需要处理的对象的数量时可以使用可变长参数，会使得方法调用更简单，无需手动创建数组 new T[]{…}。与“数组包裹”的方法相比，真正的实参个数可变的方法，在调用时更为简单，含义也更清楚，但存在自身的限制。</p>
<h3 id="函数签名"><a href="#函数签名" class="headerlink" title="函数签名"></a>函数签名</h3><pre class=" language-text"><code class="language-text">public void test(Integer... args)</code></pre>
<p>只要在一个形参的“类型”与“参数名”之间加上三个连续的“.”（即“…”，英文里的句中省略号），就可以让它和不确定个实参相匹配。而一个带有这样的形参的方法，就是一个实参个数可变的方法。</p>
<h4 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h4><ol>
<li>不定项参数必须放在参数列表最后一个</li>
<li>不定项参数只能有一个（多个，必然有一个不是最后一个）。</li>
<li>重载时，运行优先级问题。(系统优先匹配确定参数，然后匹配不确定参数)</li>
<li><strong>不定参数会被 Java 转型成数组，所以本质上是一个二维数组</strong></li>
<li>与数组包裹方法相比，存在泛型不可用。</li>
<li>自动装箱和自动拆箱问题</li>
</ol>
<pre class=" language-java"><code class="language-java"><span class="token number">3</span><span class="token punctuation">.</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">method</span><span class="token punctuation">(</span>String <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">method</span><span class="token punctuation">(</span>String s1<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">method</span><span class="token punctuation">(</span>String s1<span class="token punctuation">,</span>String s2<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
    <span class="token function">method</span><span class="token punctuation">(</span><span class="token string">"test1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>              <span class="token comment" spellcheck="true">// invoke method(String s1)</span>
    <span class="token function">method</span><span class="token punctuation">(</span><span class="token string">"test1"</span><span class="token punctuation">,</span><span class="token string">"test2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// invoke method(String s1,String s2);</span>
<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre>
<pre class=" language-java"><code class="language-java"><span class="token number">4</span><span class="token punctuation">.</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">method</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>args<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">method</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span> </code></pre>
<p>因为可变参数最后会被编译成数组，所以不能同时存在。可变参数兼容数组，反之不成立。</p>
<pre class=" language-java"><code class="language-java"><span class="token number">5</span><span class="token punctuation">.</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span>T<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> args<span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// compile failure</span>

<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span>T <span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
     List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> integers <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
         integers<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
                 <span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span>integer <span class="token operator">-</span><span class="token operator">></span> integer <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">)</span>
                 <span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span>Collectors<span class="token punctuation">.</span><span class="token function">toList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                 <span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>integer <span class="token operator">-</span><span class="token operator">></span> System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>integer<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// compile successfully</span></code></pre>
<p>6.</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> args<span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span>INteger <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> args<span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">//Invoke</span>
<span class="token function">test</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">test</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token comment" spellcheck="true">// Above of all,compile failure</span></code></pre>
<ol start="7">
<li><p>可变参数不可以与泛型一起使用，会导致 “generic array creation” 错误。</p>
</li>
<li><p>避免带有可变长度的方法重写。</p>
</li>
<li><p>重写带有可变参数的方法。</p>
</li>
</ol>
<pre class=" language-Java"><code class="language-Java">Class Base&#123;
    public void print(String... args)&#123;
        System.out.println("Base----Test");
    &#125;
&#125;

Class Sub extends Base&#123;
    @Override
    public void print(String [] args)&#123;
        System.out.println("Sub-----Test");
    &#125;
&#125;
class variableParameters()&#123;

     public static void main(String [] args)&#123;
         Base base = new Sub();
         base.println("hello"); //pass

         Sub sub = new Sub();
         sub.println("hello"); //error
     &#125;
 &#125;
</code></pre>
<p>base 对象将子类对象做了向上转型，形参列表是由父类决定的，所以可以通过。而 sub 调用自身复写的方法，参数类型不匹配也不会父类去匹配，所以导致类型不匹配错误。</p>
<ol start="10">
<li>Object… 参数问题</li>
</ol>
<pre class=" language-Java"><code class="language-Java">public void test(Object... args)&#123;
    System.out.println(args.length);
&#125;

test(new String[]&#123;"1","2","3"&#125;);//3
test(100,new String[]&#123;"1","2"&#125;);//2
test(new Integer[]&#123;1,2,3&#125;)//3
test(100,new Integer[]&#123;1,2&#125;)//2
test(1,2,3);//3
test(new int[](1,2,3));//1
</code></pre>
<p>int[] 无法转型为 Object[] ,只会被当成一个数组对象。Integer[] 可以转型为 Object[],可以成为一个对象数组。</p>
<ol start="11">
<li>反射方法调用时的注意事项</li>
</ol>
<pre class=" language-Java"><code class="language-Java">public class Test()&#123;
    public static void test(String... args)&#123;
        System.out.println(args.length);
    &#125;

    public static void main(String [] args)&#123;
        String [] varArgs =new String[]&#123;"a","b"&#125;;
        try&#123;
            Method method = Test.class.getmethod("test",String[].class);
            // Object invoke(Object obj,Object...args);
            method.invoke(null,varArgs);// varArgs.length =2 error
            method.invoke(null,(Object[])varArgs);// String[]  转换为 Object[],varArgs.length =2.error.
            method.invoke(null,(Object) varArgs);// 将整个 String [] 转换为 Object，varArgs.length= 1，right.
            method.invoke(null,new Object[]&#123;varArgs&#125;);//Object[] 长度为 1，right。等价于第三个方法调用。
        &#125;catch(Exception e)&#123;
            e.printStackTrace();
        &#125;
    &#125;
&#125;</code></pre>
<ol start="11">
<li>调用的参数也可以是 0(等价于空数组)</li>
</ol>
<pre class=" language-Java"><code class="language-Java">test();</code></pre>
]]></content>
      <tags>
        <tag>Java 基础</tag>
      </tags>
  </entry>
  <entry>
    <title>java volatile</title>
    <url>/blogs/java-basic-volatile.html</url>
    <content><![CDATA[<h2 id="深入理解-JVM-volatile"><a href="#深入理解-JVM-volatile" class="headerlink" title="深入理解 JVM - volatile"></a>深入理解 JVM - volatile</h2><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢~~</p>
<h4 id="Volatile-和-Synchronized-四个不同点："><a href="#Volatile-和-Synchronized-四个不同点：" class="headerlink" title="Volatile 和 Synchronized 四个不同点："></a>Volatile 和 Synchronized 四个不同点：</h4><ol>
<li>粒度不同，前者锁对象和类，后者针对变量。</li>
<li>syn 阻塞，volatile 线程不阻塞</li>
<li>syn 保证三大特性，volatile 不保证原子性</li>
<li>syn 编译器优化，volatile 不优化</li>
</ol>
<h4 id="volatile具备两种特性："><a href="#volatile具备两种特性：" class="headerlink" title="volatile具备两种特性："></a>volatile具备两种特性：</h4><ol>
<li>保证此变量对所有线程的可见性，指一条线程修改了这个变量的值，新值对于其他线程来说是不可见的，但并不是多线程安全的。</li>
<li>禁止指令重排序优化。</li>
</ol>
<h4 id="Volatile-如何保证内存可见性"><a href="#Volatile-如何保证内存可见性" class="headerlink" title="Volatile 如何保证内存可见性:"></a>Volatile 如何保证内存可见性:</h4><ol>
<li>当写一个 volatile 变量时，JVM 会把该线程对应的本地内存中的共享变量刷新到主内存中。</li>
<li>当读一个 volatile 变量时，JVM 会把该线程对应的本地内存置为无效。线程接下来将从主内存中读取共享变量。</li>
</ol>
<p>同步：就是一个任务的完成需要依赖另外一个任务，只有等待被依赖的任务完成后，依赖任务才能完成。</p>
<p>异步：不需要等待被依赖的任务完成，只是通知被依赖的任务要完成什么工作，只要自己任务完成了就算完成了，被依赖的任务是否完成会通知回来。（异步的特点就是通知）。</p>
<h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ul>
<li><p><a href="https://blog.csdn.net/zero__007/article/details/90545073">深入解析 volatile 、CAS 的实现原理</a></p>
</li>
<li><p><a href="https://segmentfault.com/a/1190000037799975">一文读懂Java内存模型(JMM)及volatile关键字</a></p>
</li>
</ul>
]]></content>
      <tags>
        <tag>Java 基础</tag>
      </tags>
  </entry>
  <entry>
    <title>java-clean-code-警告压制</title>
    <url>/blogs/java-clean-code-warnning.html</url>
    <content><![CDATA[<h1 id="Java-clean-code-警告压制"><a href="#Java-clean-code-警告压制" class="headerlink" title="Java-clean-code-警告压制"></a>Java-clean-code-警告压制</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢~~</p>
<h2 id="一-列表"><a href="#一-列表" class="headerlink" title="一. 列表"></a>一. 列表</h2><table>
<thead>
<tr>
<th>值</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td><code>all</code></td>
<td>抑制所有警告</td>
</tr>
<tr>
<td><code>boxing</code></td>
<td>抑制与封装/拆装作业相关的警告</td>
</tr>
<tr>
<td><code>cast</code></td>
<td>抑制与强制转型作业相关的警告</td>
</tr>
<tr>
<td><code>dep-ann</code></td>
<td>抑制与淘汰注释相关的警告</td>
</tr>
<tr>
<td><code>deprecation</code></td>
<td>抑制与淘汰的相关警告</td>
</tr>
<tr>
<td><code>fallthrough</code></td>
<td>抑制与 <code>switch</code> 陈述式中遗漏 <code>break</code> 相关的警告</td>
</tr>
<tr>
<td><code>finally</code></td>
<td>抑制与未传回finally区块相关的警告</td>
</tr>
<tr>
<td><code>hiding</code></td>
<td>抑制与隐藏变数的区域变数相关的警告</td>
</tr>
<tr>
<td><code>incomplete-switch</code></td>
<td>抑制与 <code>switch</code> 陈述式（<code>enum case</code>）中遗漏项目相关的警告</td>
</tr>
<tr>
<td><code>javadoc</code></td>
<td>抑制与 <code>javadoc</code> 相关的警告</td>
</tr>
<tr>
<td><code>nls</code></td>
<td>抑制与非 <code>nls</code> 字串文字相关的警告</td>
</tr>
<tr>
<td><code>null</code></td>
<td>抑制与空值分析相关的警告</td>
</tr>
<tr>
<td><code>rawtypes</code></td>
<td>抑制与使用 <code>raw</code> 类型相关的警告</td>
</tr>
<tr>
<td><code>resource</code></td>
<td>抑制与使用 <code>Closeable</code> 类型的资源相关的警告</td>
</tr>
<tr>
<td><code>restriction</code></td>
<td>抑制与使用不建议或禁止参照相关的警告</td>
</tr>
<tr>
<td><code>serial</code></td>
<td>抑制与可序列化的类别遗漏 <code>serialVersionUID</code> 栏位相关的警告</td>
</tr>
<tr>
<td><code>static-access</code></td>
<td>抑制与静态存取不正确相关的警告</td>
</tr>
<tr>
<td><code>static-method</code></td>
<td>抑制与可能宣告为 <code>static</code> 的方法相关的警告</td>
</tr>
<tr>
<td><code>super</code></td>
<td>抑制与置换方法相关但不含 <code>super</code> 呼叫的警告</td>
</tr>
<tr>
<td><code>synthetic-acces</code></td>
<td>抑制与内部类别的存取未最佳化相关的警告</td>
</tr>
<tr>
<td><code>sync-override</code></td>
<td>抑制因为置换同步方法而遗漏同步化的警告</td>
</tr>
<tr>
<td><code>unchecked</code></td>
<td>抑制与未检查的作业相关的警告</td>
</tr>
<tr>
<td><code>unqualified-field-access</code></td>
<td>抑制与栏位存取不合格相关的警告</td>
</tr>
<tr>
<td><code>unused</code></td>
<td>抑制与未用的程式码及停用的程式码相关的警告</td>
</tr>
</tbody></table>
<h2 id="二-示例"><a href="#二-示例" class="headerlink" title="二. 示例"></a>二. 示例</h2><h3 id="1-all"><a href="#1-all" class="headerlink" title="1. all"></a>1. <code>all</code></h3>]]></content>
      <tags>
        <tag>Java 基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 并发编程目录</title>
    <url>/blogs/java-concurrent%20programming.html</url>
    <content><![CDATA[<h1 id="Java-并发编程目录"><a href="#Java-并发编程目录" class="headerlink" title="Java 并发编程目录"></a>Java 并发编程目录</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢~~</p>
<h2 id="一-互斥"><a href="#一-互斥" class="headerlink" title="一. 互斥"></a>一. 互斥</h2><h3 id="1-无锁"><a href="#1-无锁" class="headerlink" title="1. 无锁"></a>1. 无锁</h3><h3 id="2-互斥锁"><a href="#2-互斥锁" class="headerlink" title="2. 互斥锁"></a>2. 互斥锁</h3><h2 id="二-协作"><a href="#二-协作" class="headerlink" title="二. 协作"></a>二. 协作</h2><ol>
<li><p>信号量</p>
</li>
<li><p>管程</p>
</li>
<li><p><code>CountDownLatch</code></p>
</li>
<li><p><code>CyclicBarrier</code></p>
</li>
<li><p><code>Phaser</code></p>
</li>
<li><p><code>Exchanger</code></p>
</li>
</ol>
<h2 id="三-协同分工"><a href="#三-协同分工" class="headerlink" title="三. 协同分工"></a>三. 协同分工</h2>]]></content>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解 Java 动态代理</title>
    <url>/blogs/java-dynamic-proxy.html</url>
    <content><![CDATA[<h1 id="深入理解-Java-动态代理"><a href="#深入理解-Java-动态代理" class="headerlink" title="深入理解 Java 动态代理"></a>深入理解 Java 动态代理</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢 ~~</p>
]]></content>
      <tags>
        <tag>Java 基础</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解 Java Web 拦截器和过滤器</title>
    <url>/blogs/java-filter-interceptor.html</url>
    <content><![CDATA[<h1 id="深入理解-Java-Web-拦截器和过滤器"><a href="#深入理解-Java-Web-拦截器和过滤器" class="headerlink" title="深入理解 Java Web 拦截器和过滤器"></a>深入理解 Java Web 拦截器和过滤器</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢 ~~</p>
<p>过滤器 Filter</p>
<p>基于 函数回调，</p>
<p>拦截器 Interceptor 基于反射</p>
<p>filter -&gt; servlet -&gt; interceptor -&gt; controller</p>
<h5 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h5><ul>
<li><a href="https://www.zhihu.com/question/30212464/answer/1786967139">Spring 拦截器和过滤器的区别？</a></li>
</ul>
]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>java-features-module-system</title>
    <url>/blogs/java-features-module-system.html</url>
    <content><![CDATA[<h1 id="Java-Features-Module-System-JDK-9"><a href="#Java-Features-Module-System-JDK-9" class="headerlink" title="Java Features - Module System -JDK 9"></a>Java Features - Module System -JDK 9</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢~~</p>
<h2 id="一-背景"><a href="#一-背景" class="headerlink" title="一. 背景"></a>一. 背景</h2><p>Java 8 以前，我们使用 maven 或者 gradle 管理 jar 包时，可能会因为某一个小方法而必须引入一整个对应的 jar 包，这就导致当前 jar 包的 classpath 路径名会非常长，从而形成 jar hell。</p>
<h2 id="二-module-system-的目标"><a href="#二-module-system-的目标" class="headerlink" title="二. module system 的目标"></a>二. module system 的目标</h2><p>Java 9 引入 Model System，您可以将 Java 应用程序视为具有明确定义的边界和这些模块之间依赖关系的交互模块的集合。 模块系统的开发具有以下目标：</p>
<ol>
<li>可靠的配置</li>
<li>强封装</li>
<li>模块化JDK/JRE</li>
</ol>
<p>Java 9 中的模块系统脱胎于 OpenJDK 的 Jigsaw 项目。Jigsaw的设计目标是：</p>
<ul>
<li><p>为了让开发者构建和维护一个大型的库或应用程序更容易</p>
</li>
<li><p>-提高javaSE平台及JDK实现的安全性和可维护性；</p>
</li>
<li><p>提升应用的性能；</p>
</li>
<li><p>在javase及JDK平台，让应用更小以便于部署于更小的计算单元及紧密的云部署系统。</p>
</li>
</ul>
<h2 id="三-如何使用"><a href="#三-如何使用" class="headerlink" title="三. 如何使用"></a>三. 如何使用</h2><p>为了解决 jar hell 的问题，同时达到目标，module system 实际上是在 package 的级别上又封装了一层。</p>
<h3 id="1-引入-module-info-java"><a href="#1-引入-module-info-java" class="headerlink" title="1. 引入 module-info.java"></a>1. 引入 module-info.java</h3><p>我们需要对应的 package 的目录下引入<code> module-info.java</code> 文件。</p>
<h3 id="2-在-文件中，写入相关信息"><a href="#2-在-文件中，写入相关信息" class="headerlink" title="2. 在 文件中，写入相关信息"></a>2. 在 文件中，写入相关信息</h3><pre class=" language-java"><code class="language-java">module test<span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
  export com<span class="token punctuation">.</span>test<span class="token punctuation">;</span>
  require java<span class="token punctuation">.</span>security<span class="token punctuation">;</span>
<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre>
<ul>
<li><p>test  为当前 module 名。</p>
</li>
<li><p>export 为暴露的模块名</p>
</li>
<li><p>require  为当前模块需要依赖的 module 名。</p>
</li>
</ul>
<h3 id="四-module-种类"><a href="#四-module-种类" class="headerlink" title="四. module 种类"></a>四. module 种类</h3>]]></content>
      <tags>
        <tag>Java 基础</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解 Java 函数式编程</title>
    <url>/blogs/java-function-principle.html</url>
    <content><![CDATA[<h1 id="深入理解-Java-函数式编程"><a href="#深入理解-Java-函数式编程" class="headerlink" title="深入理解 Java 函数式编程"></a>深入理解 Java 函数式编程</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢~~</p>
<h2 id="一-Functional-Interface"><a href="#一-Functional-Interface" class="headerlink" title="一. Functional Interface"></a>一. Functional Interface</h2><blockquote>
<p>函数式接口</p>
</blockquote>
<p>Java 8 引入了一个新的注解 <code>@FunctionalInterface</code>，<br>c</p>
]]></content>
      <tags>
        <tag>函数式编程</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解 Future</title>
    <url>/blogs/java-future.html</url>
    <content><![CDATA[<h1 id="深入理解-Future"><a href="#深入理解-Future" class="headerlink" title="深入理解 Future"></a>深入理解 Future</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢 ~~</p>
<p>只有在使用 future.get() 的时候才会阻塞线程，使用 get() 时，如果当前线程已经执行结束，就会直接返回执行结果，否则阻塞线程，直到获取执行结果。</p>
<ul>
<li><a href="https://cloud.tencent.com/developer/article/1680378">理解Future及FutureTask的实现</a></li>
<li><a href="https://segmentfault.com/a/1190000007961347">Java多线程（3）：取消正在运行的任务</a></li>
</ul>
]]></content>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>java-gc-introduce</title>
    <url>/blogs/java-gc-introduce.html</url>
    <content><![CDATA[<h1 id="JVM-GC-介绍"><a href="#JVM-GC-介绍" class="headerlink" title="JVM GC 介绍"></a>JVM GC 介绍</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢 ~~</p>
<h5 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h5><ol>
<li>GC的作用范围</li>
<li>GC负责的事情</li>
<li>JVM中的4种GC</li>
<li>G1的一些细节</li>
<li>使用Java 9正式版对G1进行测试</li>
<li>一些简单的GC调优方法</li>
</ol>
<h2 id="一-GC-的作用范围"><a href="#一-GC-的作用范围" class="headerlink" title="一. GC 的作用范围"></a>一. GC 的作用范围</h2><p>VM内存中主要有以下几个区域：堆、方法区（JVM规范中的叫法，Hotspot大致对应的是Metaspace）、栈、本地方法栈、PC等，其中GC主要作用在堆上，如下图所示：</p>
<p>其中堆和方法区是所有线程共享的，其他则为线程独有，HotSpot JVM使用基于分代的垃圾回收机制，所以在堆上又分为几个不同的区域（在G1中，各年龄代不再是连续的一整片内存，为了描述方便，这里还使用传统的表示方法）</p>
<h2 id="二-GC负责的事情"><a href="#二-GC负责的事情" class="headerlink" title="二. GC负责的事情"></a>二. GC负责的事情</h2><p><img src="https://upload-images.jianshu.io/upload_images/1966024-e8931d97a17952df.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/729/format/webp" alt="JVM 内存结构"> </p>
<ol>
<li>分配对象和对象的年龄管理<br>通常而言，GC需要管理「在上图中的年轻代（Young）分配对象，然后通过一系列的年龄管理，将之销毁或晋升到老年代（Tenured）中去」的过程。这个过程会伴随着若干次的Minor GC。</li>
</ol>
<p>对于普通的对象而言，分配内存是一件很简单而且快速的事情。在对象还未创建时，其所占内存大小通过类的元数据就可以确定，而Eden区域的内存可以认为是连续的，所以给对象分配内存要做的只是在上图中Eden区域中把指针移动相应的长度，并将地址返回给对象的引用即可。当然实际的过程比这个复杂，在下文中会提到。</p>
<p>不过，有时候一个对象会直接在老年代中创建，这个点也会在后边提到。</p>
<ol start="2">
<li>在老年代中进行标记<br>老年代的GC算法可以大致是认为是一个标记-整理（Mark-Compact，其实是混合了标记-清理，标记-复制和标记-整理）算法，所以老年代的垃圾清理首先要做的就是在老年代对存活的对象（可达性分析，关于不同的可达性可以参考JDK解构 - Java中的引用和动态代理的实现）进行标记，对于寻求大吞吐量的服务器应用来说，这个过程往往需要是并发的。</li>
</ol>
<p>标记的过程发生在Major GC被触发之后，不同的GC对于MajorGC的触发条件和标记过程的实现也不尽相同。</p>
<ol start="3">
<li>在老年代中进行压缩<br>在上一条的基础上，将还存活的对象进行压缩（CMS和G1的行为与此有些不同之处），压缩的过程就是将存活的对象从老年代的起点进行挨个复制，使得老年代维持在一片连续的内存中，消除内存碎片，对于内存分配速度的提升会有很大的帮助。</li>
</ol>
<p><img src="https://upload-images.jianshu.io/upload_images/1966024-52f4a8ac4586025d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/456/format/webp"></p>
<h2 id="三-GC-的种类"><a href="#三-GC-的种类" class="headerlink" title="三. GC 的种类"></a>三. GC 的种类</h2><ol>
<li>Serail </li>
</ol>
<p>Serail是最早的一款GC，它只使用一个线程来做所有的Minor和Major垃圾回收。它在运行时，其他所有的事情都会暂停。其工作方式十分简单，在需要GC的安全点，它会停止所有其他线程（Stop-The-World），对年轻代进行标记-复制，或对老年代进行标记-整理。</p>
<p>可以使用JVM参数-XX:+UseSerialGC来开启此GC，当使用此参数时，年轻代和老年代将都是用Serial来做垃圾回收。在年轻代使用标记-复制算法，将Eden中存活的对象和非空的Suvivor区（From）中存活的对象复制到空的Suvivor区（To）中去，同时将一部分Suvivor中的对象晋升到老年代去。在老年代则使用标记-整理算法。</p>
<p>看起来Serial古老而简陋，但在宿主机资源紧张或者JVM堆很小的情况下（比如堆内存大小只有不到100M），Serial反而可以达到更好的效果，因为其他并发或并行GC都是基于多线程的，会带来额外的线程切换和线程间通信的开销。</p>
<ol start="2">
<li>Parallel/Throughput</li>
</ol>
<p>Parallel在Java 9之前是服务器型宿主机中JVM的默认GC，其垃圾回收的算法和Serial基本相同，不同之处在与它使用多线程来执行。由于使用了多线程，可以享受多核CPU带来的优势，可以通过参数-XX:+UseParallelGC -XX:+UseParallelOldGC显示指定。</p>
<ol start="3">
<li>CMS<br>CMS和G1都属于「Mostly Concurrent Mark and Sweep Garbage Collector」，可以使用-XX:+UseConcMarkSweepGC参数打开。CMS的年轻代垃圾回收使用的是Parallel New来做，其行为和Parallel中的差不多相同，他们的实现上有一些不同的地方，比如Parallel可以自动调节年轻代中各区的大小，用的是广度优先搜索等。</li>
</ol>
<p>老年代使用CMS，CMS的回收和Parallel也基本类似，不同点在与，CMS使用的更复杂的可达性分析步骤，并且不是每次都做压缩的动作，这样达到的效果就是，Stop-The-World的时长会降低，JVM运行中断的时间减少，适合在对延迟敏感的场景下使用。</p>
<p>CMS在Java 9中已经被废弃，但了解CMS的行为对理解G1会有一些帮助，所以这里还是会简单的叙述一下。CMS的步骤大致如下：</p>
<p>第一次标记<br>从GC Roots开始，找到它们在老年代中第一个可达的对象，这些对象或者是直接被GC Roots引用，或者通过年轻代中的对象被GC Roots引用。这一步会Stop-The-World。</p>
<p>并发标记<br>在第一次标记的基础上，进一步进行可达性分析，从而标记存活的对象。这一步叫「并发」标记，是因为做标记的线程是和应用的工作线程并发执行的，也就是说，这一步不会Stop-The-World。</p>
<p>第二次标记<br>在并发标记的过程中，由于程序仍在执行，会导致在并发标记完成后，有一些对象的可达性会发生变化，所以需要再次对他们进行标记。这一步会Stop-The-World。</p>
<p>清理<br>回收不使用的对象，留作以后使用。</p>
<p>CMS的设计比较复杂，所以也带来了一些问题，比如浮动垃圾（Floating Garbage，指的是在第一步标记可达，但在第二步执行的同时已经不可达的对象），由于不做老年代压缩，导致老年代会出现较多的内存碎片。</p>
<ol start="4">
<li>G1</li>
</ol>
<p>由于「引入了并发标记」和「不做老年代压缩」，CMS可以带来更好的响应时延表现，但同时也带来了一些问题。G1本身就是作为CMS的替代品出现的，在它的使用场景里，堆不再是连续的被分为上文所说的各种代，整个堆会被分为一个个区域（Region），每个区域可以是任何代。如下图所示：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1966024-8b22f9ff4c8a5d75.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/447/format/webp"></p>
<p>其中有红色方框的为年轻代（标S的为Survivor区域，其他为Eden），其他蓝色底的区域为老年代（标H的为大对象区域，用以存储大对象）。</p>
<p>G1与以上3种GC相同，也是基于分代的垃圾回收器。它的垃圾回收步骤可以分为年轻代回收（Young-only phase，类似于Minor GC）和混合垃圾回收阶段（Space-reclamation phase）。下图是Oracle文档中对于此两个阶段的示意图：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1966024-95152dc9cfb20d55.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/359/format/webp"></p>
<p>G1设计目标和适用对象<br>G1的设计目标是让大型的JVM可以动态的控制GC的行为以满足用户配置的性能目标。G1会在平衡吞吐和响应时延的基础上，尽可能的满足用户的需求。它适用的JVM往往有以下特征：</p>
<p>堆的大小可能达到数十G（或者更大），同时存活的对象数量也很多。<br>对象的分配和年龄增长的行为随着程序的运行不断的变化<br>堆上很容易形成碎片<br>要求较少的Stop-The-World暂停时间，通常小于数百毫秒</p>
<p>对G1的行为进行测试<br>如果想要看垃圾回收的具体执行过程，可以使用虚拟机参数-Xlog:gc*=debug或者-Xlog:gc*=info，前一个会打印更多的细节。注意传统的VM参数-XX:+PrintGCDetails在Java9中已经废弃，会有Warning信息。可以使用以下代码中的程序去测试：</p>
<pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">static</span> int TOTAL_SIZE <span class="token operator">=</span> <span class="token number">1024</span> <span class="token operator">*</span> <span class="token number">5</span><span class="token punctuation">;</span>
<span class="token keyword">static</span> Object<span class="token punctuation">[</span><span class="token punctuation">]</span> floatingObjs<span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">[</span>TOTAL_SIZE<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">static</span> LinkedList<span class="token operator">&lt;</span>Object<span class="token operator">></span> immortalObjs <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token operator">&lt;</span>Object<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">//释放浮动垃圾</span>
synchronized <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">renewFloatingObjs</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
    System<span class="token punctuation">.</span>err<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"存活对象满========================================"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>floatingSize <span class="token operator">+</span> <span class="token number">5</span> <span class="token operator">>=</span> TOTAL_SIZE<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
        floatingObjs<span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">[</span>TOTAL_SIZE<span class="token punctuation">]</span><span class="token punctuation">;</span>
        floatingSize <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">//添加浮动垃圾</span>
synchronized <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">addObjToFloating</span><span class="token punctuation">(</span>Object obj<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>floatingSize<span class="token operator">++</span> <span class="token operator">&lt;</span> TOTAL_SIZE<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
        floatingObjs<span class="token punctuation">[</span>floatingSize<span class="token punctuation">]</span> <span class="token operator">=</span> obj<span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>immortalSize<span class="token operator">++</span> <span class="token operator">&lt;</span> TOTAL_SIZE<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
            immortalObjs<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">else</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
            immortalObjs<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span>TOTAL_SIZE<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            immortalObjs<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>int i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
            <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
                <span class="token keyword">try</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
                    Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
                    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
                Byte<span class="token punctuation">[</span><span class="token punctuation">]</span> garbage <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Byte</span><span class="token punctuation">[</span><span class="token number">1024</span> <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">+</span> <span class="token keyword">new</span> <span class="token class-name">Random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
                    <span class="token keyword">if</span> <span class="token punctuation">(</span>floatingSize <span class="token operator">+</span> <span class="token number">5</span> <span class="token operator">>=</span> TOTAL_SIZE<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
                        <span class="token function">renewFloatingObjs</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
                    <span class="token function">addObjToFloating</span><span class="token punctuation">(</span>garbage<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre>
<p>年轻代回收（Young-only）</p>
<p>对于纯粹的年轻代回收，其算法很简单，与Parallel和CMS的年轻代十分类似，这是一个多线程并行执行的过程，同样需要Stop-The-World（对应上边日志中的Pause Young），停下来所有的工作线程，然后将Eden上存活的对象拷贝到Suvivor区域，这里会将很多个对象从多个不同的区域拷贝到少数的几个区域内，所以这一步在G1中叫做疏散（Evacuation），同时把Suvivor上触及年龄阈值的对象晋升到老年代区域。</p>
<p>老年代回收（concurrent cycle）<br>G1的老年代回收是在老年代空间触及一个阈值（Initiating Heap Occupancy Percent）之后，这个回收伴随着年轻代的回收工作，但与上边所说的回收有些不同。</p>
<p>年轻代回收：伴随着年轻代的回收工作，同时会执行并发标记和一部分清理的工作，这样可以共用年轻代垃圾回收的Stop-The-World。</p>
<p>第一次标记：对应一次Pause Initial Mark<br>和CMS的步骤类似，首先进行第一次标记。但实现方法上有很大的区别，G1首先对当前堆上的对象情况进行一个虚拟快照（Snapshot-At-The-Beginning），然后根据这个快照对老年代的对象和区域进行标记，并执行之后的垃圾回收。之后像CMS一样会有并发标记的过程。<br>这样会产生一个问题，在这次回收结束之后，会有些对象在并发标记的过程中，它的可达性已经变化，导致已经不可达的对象仍然没有被回收。但是这样能带来更好的响应时间。</p>
<p>重新标记：对应一次Pause Remark<br>在这个阶段，G1首先完成上一步开始的标记工作，之后会对特殊引用的对象进行处理（具体可以参考JDK解构 - Java中的引用和动态代理的实现），还有对Metaspace区域进行垃圾回收。这一步会进行Stop-The-World。</p>
<p>清理：对应一次Pause Cleanup<br>这一步主要做的是收集当前堆中的内存区域信息，对空的区域进行回收，为接下来的空间回收做一些准备工作，清理结束之后，通常会伴随着一次年轻代回收，如果判断不需要进行空间回收，则会进入下一个年轻代回收的工作。这一步会进行Stop-The-World。</p>
<p>混合垃圾回收：对应一次或多次Pause Mixed<br>主要做的是对老年代的区域内存进行疏散（Evacuation），也包含对年轻代的区域回收工作。同时这一步也会动态地调整IHOP</p>
<p>从对G1的GC日志的分析，可以看到G1的垃圾回收行为是基于一个可预测的模型：GC会不断的主动触发垃圾回收，在这个过程中不断地进行信息统计和系统GC参数的设置，然后将上边这些步骤安排在这些垃圾回收过程中。</p>
<p>大对象的分配<br>正常情况下，一个对象会在年轻代的Eden中创建，然后通过垃圾回收和年龄管理之后，晋升到老年代。但对于某些比较大的对象，可能会直接分配到老年代去。</p>
<p>对于G1，对象大多数情况都会在Eden上分配，如果JVM判断一个对象为大对象（其阈值可以通过-XX:G1HeapRegionSize来设置），则会直接分配如老年代的大对象区域中。</p>
<p>对于其他的内存区域连续的GC，下面是从StackOverflow上搬运过来的对象在堆上的分配过程：</p>
<p>使用 thread local allocation buffer (TLAB), 如果空间足够，则分配成功。<br>从名称便可知，TLAB是线程独占的，所以线程安全，且速度非常快。如果一个TLAB满了，线程会被分配一个新的TLAB。</p>
<p>如果TLAB 空间不够这次分配对象，但其中还有很多空间可用，则不使用TLAB，直接在Eden中分配对象。<br>直接在Eden上分配对象要去抢占Eden中的指针操作，其代价较使用TLAB要大一些。</p>
<p>如果Eden的对象分配失败，出发Minor GC。</p>
<p>如果Minor GC完成后还不够，则直接分配到老年代。</p>
<p>一些简单的GC调优方法</p>
<p>详情参见 [JVM - 性能调优]</p>
<ol>
<li><p>使用不同的索引对象<br>引用的类型会直接影响其所引用对象的GC行为，当要做一些内存敏感的应用时，可以参考使用合适的引用类型。具体可以参考JDK解构 - Java中的引用和动态代理的实现。</p>
</li>
<li><p>使用Parallel<br>从上文中可知，Java 8默认的GC是Parallel，它也叫Throughput，所以它的目的是尽可能的增加系统的吞吐量。在Parallel里，可以通过参数调节最大停止时间（-XX:MaxGCPauseMillis，默认无设置）和吞吐量（-XX:GCTimeRatio，默认值是99，即最大使用1%的时间来做垃圾回收）来调优GC的行为。其中设置最大停止时间可能会导致GC调节各年龄代分区的尺寸（通过增量来实现）。</p>
</li>
<li><p>使用G1<br>从Java 9开始G1变成了默认的GC，G1中有一些细节的概念在上文中没有叙述，这里先介绍一下：</p>
</li>
</ol>
<p>Remembered Sets（Rsets）：对于每个区域，都有一个集合记录这个区域中所有的引用。<br>G1 refinement：G1中需要有一系列的线程不断地维护Rsets。<br>Collection Sets（Csets）：在垃圾回收中需要被回收的区域，这些区域中的可达对象（活着的对象）会被疏散。这些区域可能是任何年龄代。<br>写屏障（Write Barriers）：对于每一次赋值操作，G1都会有两个写屏障，写之前（Pre-Write）一个，写之后（Post-Write）一个。Pre-write主要与SATB相关，Post-write主要与Rsets相关<br>Dirty Card Queue：写屏障会将写的记录放入这个队列，会有线程将这里的对象不断的刷入Rsets。<br>Green/Yellow/Red Zone：三个会影响处理Dirty Card Queue线程数的阈值。根据Dirty Card Queue中元素的个数，可以来设置一些GC行为（可以认为是逻辑上将Dirty Card Queue分隔成多个区域）。Green表示超过此阈值则开始新建线程来处理这个队列，Yellow表示超过此阈值，强制启动这些线程，Red表示超过此阈值则会让写操作的线程自己来执行G1 refinement。</p>
<p>G1提供了丰富的基于不同目的的可调优的参数，列表如下：</p>
<p>参数    描述<br>-XX:+G1UseAdaptiveConcRefinement,    调节G1 refinement所使用的资源。<br>-XX:G1ConcRefinementGreenZone=<ergo>,    调节G1 refinement所使用的资源。<br>-XX:G1ConcRefinementYellowZone=<ergo>,    调节G1 refinement所使用的资源。<br>-XX:G1ConcRefinementRedZone=<ergo>,    调节G1 refinement所使用的资源。<br>-XX:G1ConcRefinementThreads=<ergo>    调节G1 refinement所使用的资源。<br>-XX:G1RSetUpdatingPauseTimePercent=10    调节G1 refinement所需要的时间在整个垃圾回收时间的比例，G1会根据这个时间动态地调节第一行的各个参数。<br>-XX:+ReduceInitialCardMarks    批量执行对象的生成，以减少初始标记的时间<br>-XX:-ParallelRefProcEnabled    使用多线程处理上文中所说的在重新标记阶段对引用的处理<br>-XX:G1SummarizeRSetStatsPeriod=<n>    设置n次垃圾回收后，打印Rsets的总结性报告。<br>-XX:GCTimeRatio=<n>    设置GC吞吐量。GC总共应该使用的时间是1 / (1 + n)，这个参数会影响不同年龄代尺寸的增长。<br>-XX:G1HeapRegionSize    设置区域的大小</p>
<h4 id="参考文章："><a href="#参考文章：" class="headerlink" title="参考文章："></a>参考文章：</h4><ol>
<li><a href="https://www.jianshu.com/p/fd18fa1d09d2">Java 9中的GC调优基础</a></li>
</ol>
]]></content>
      <tags>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title>Future 取消异常机制</title>
    <url>/blogs/java-future-cancelexception-timeoutexception.html</url>
    <content><![CDATA[<h1 id="Future-CancellationException"><a href="#Future-CancellationException" class="headerlink" title="Future CancellationException"></a>Future CancellationException</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢 ~~</p>
<p>参考文章</p>
<p><a href="https://www.coder.work/article/5533506">java - TimeoutException和CancellationException之间的区别
</a></p>
]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>Lambda表达式的原理</title>
    <url>/blogs/java-lambda-principle.html</url>
    <content><![CDATA[<h1 id="Lambda表达式的原理"><a href="#Lambda表达式的原理" class="headerlink" title="Lambda表达式的原理"></a>Lambda表达式的原理</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢 ~~</p>
<p>Lambda表达式声明的地方会生成一个invokedynamic指令，同时编译器生成一个对应的引导方法（Bootstrap Method）。</p>
<p>❏ 第一次执行invokedynamic指令时，会调用对应的引导方法（BootstrapMethod），该引导方法会调用LambdaMetafactory.metafactory方法动态生成内部类。</p>
<p>❏ 引导方法会返回一个动态调用CallSite对象，这个CallSite会最终调用实现了Runnable接口的内部类。</p>
<p>❏ Lambda表达式中的内容会被编译成静态方法，前面动态生成的内部类会直接调用该静态方法。</p>
<p>❏ 真正执行lambda调用的还是用invokeinterface指令。</p>
<p>为什么Java 8的Lambda表达式要基于invokedynamic指令来实现呢？</p>
<p>Oracle的开发者专门写了一篇文章介绍了Java 8Lambda设计时的考虑以及实现方法。<br>文中提到Lambda表达式可以通过内部类、method handle、dynamic proxies等方式实现，但是这些方法各有优劣。实现Lambda表达式需要达成两个目标，为未来的优化提供最大的灵活性，且能保持类文件字节码格式的稳定。使用invokedynamic可以很好地兼顾这两个目标。invokedynamic与之前四个invoke指令最大的不同就在于它把方法分派的逻辑从虚拟机层面下放到程序语言。Lambda表达式采用的方式并不是在编译期间生成匿名内部类，而是提供一个稳定的字节码二进制表示规范，对用户而言看到的只有invokedynamic这样一个非常简单的指令。用invokedynamic来实现把方法翻译的逻辑隐藏在JDK的实现中，后续想替换实现方式非常简单，只用修改LambdaMetafactory.metafactory里面的逻辑就可以了。这种方法把Lambda翻译的策略由编译期间推迟到运行时，未来的JDK会怎样实现Lambda表达式可能还会有变化。</p>
]]></content>
      <tags>
        <tag>lambda</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习 - 激活函数</title>
    <url>/blogs/ai-activation-function.html</url>
    <content><![CDATA[<h1 id="机器学习-激活函数"><a href="#机器学习-激活函数" class="headerlink" title="机器学习 - 激活函数"></a>机器学习 - 激活函数</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢~~</p>
<h5 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h5>]]></content>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>jvm - java - 内存模型</title>
    <url>/blogs/java-memory-module.html</url>
    <content><![CDATA[<h1 id="Java-虚拟机内存模型"><a href="#Java-虚拟机内存模型" class="headerlink" title="Java 虚拟机内存模型"></a>Java 虚拟机内存模型</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢~~</p>
<h2 id="一-组成"><a href="#一-组成" class="headerlink" title="一. 组成"></a>一. 组成</h2><h3 id="1-程序计数器"><a href="#1-程序计数器" class="headerlink" title="1.  程序计数器"></a>1.  程序计数器</h3><p>程序计数器是一个很小的内存区域，不再 RAM 上，而是直接划在 CPU 上。JVM 在解释字节码（.class）文件时，存储当前线程执行的字节码行号，只是一种概念模型，各种 JVM 所采用的方法不一样。字节码解释工作时，就是通过改变程序计数器的值来去下一条要执行的指令，分支，循环，跳转、线程恢复等基础功能都是依赖此技术区完成的。</p>
<p>由于 Java 虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的，在任何一个确定的时刻，一个处理器（对于多核处理器来说是一个内核）只会执行一条线程中的指令。因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程之间的计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。</p>
<p>如果线程正在执行的是一个 Java 方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是 Natvie 方法，这个计数器值则为空（Undefined）。此内存区域是唯一一个在 Java 虚拟机规范中没有规定任何 OutOfMemoryError 情况的区域。</p>
<h3 id="2-JVM-栈"><a href="#2-JVM-栈" class="headerlink" title="2.JVM 栈"></a>2.JVM 栈</h3><p>与程序计数器一样，Java 虚拟机栈（Java Virtual Machine Stacks）也是线程私有的，<br>它的生命周期与线程相同。虚拟机栈描述的是 Java 方法执行的内存模型：每个方法被执<br>行的时候都会同时创建一个栈帧（Stack Frame）用于存储局部变量表、操作栈、动态<br>链接、方法出口等信息。每一个方法被调用直至执行完成的过程，就对应着一个栈帧在<br>虚拟机栈中从入栈到出栈的过程。</p>
<p>经常有人把Java 内存区分为堆内存（Heap）和栈内存（Stack），这种分法比较粗<br>糙，Java 内存区域的划分实际上远比这复杂。这种划分方式的流行只能说明大多数程序<br>员最关注的、与对象内存分配关系最密切的内存区域是这两块。其中所指的“堆”在后<br>面会专门讲述，而所指的“栈”就是现在讲的虚拟机栈，或者说是虚拟机栈中的局部变<br>量表部分。</p>
<p>局部变量表存放了编译期可知的各种基本数据类型（boolean、byte、char、short、int、<br>float、long、double）、对象引用（reference 类型，它不等同于对象本身，根据不同的虚拟机实现，它可能是一个指向对象起始地址的引用指针，也可能指向一个代表对象的句柄或<br>者其他与此对象相关的位置）和returnAddress 类型（指向了一条字节码指令的地址）。<br>其中64 位长度的long 和double 类型的数据会占用2 个局部变量空间（Slot），其余<br>的数据类型只占用1 个。局部变量表所需的内存空间在编译期间完成分配，当进入一个<br>方法时，这个方法需要在帧中分配多大的局部变量空间是完全确定的，在方法运行期间<br>不会改变局部变量表的大小。</p>
<p>在Java 虚拟机规范中，对这个区域规定了两种异常状况：如果线程请求的栈深度大<br>于虚拟机所允许的深度，将抛出StackOverflowError 异常；如果虚拟机栈可以动态扩展<br>（当前大部分的Java 虚拟机都可动态扩展，只不过Java 虚拟机规范中也允许固定长度的<br>虚拟机栈），当扩展时无法申请到足够的内存时会抛出OutOfMemoryError 异常。</p>
<h3 id="3-本地方法栈"><a href="#3-本地方法栈" class="headerlink" title="3. 本地方法栈"></a>3. 本地方法栈</h3><p>本地方法栈（Native Method Stacks）与虚拟机栈所发挥的作用是非常相似的，其<br>区别不过是虚拟机栈为虚拟机执行Java 方法（也就是字节码）服务，而本地方法栈则<br>是为虚拟机使用到的Native 方法服务。虚拟机规范中对本地方法栈中的方法使用的语<br>言、使用方式与数据结构并没有强制规定，因此具体的虚拟机可以自由实现它。甚至<br>有的虚拟机（譬如Sun HotSpot 虚拟机）直接就把本地方法栈和虚拟机栈合二为一。<br>与虚拟机栈一样，本地方法栈区域也会抛出StackOverflowError 和OutOfMemoryError<br>异常。</p>
<h3 id="4-堆"><a href="#4-堆" class="headerlink" title="4. 堆"></a>4. 堆</h3><p>对于大多数应用来说，Java 堆（Java Heap）是Java 虚拟机所管理的内存中最大的<br>一块。Java 堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的<br>唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。这一点在Java 虚<br>拟机规范中的描述是：所有的对象实例以及数组都要在堆上分配①，但是随着JIT 编译器<br>的发展与逃逸分析技术的逐渐成熟，栈上分配、标量替换②优化技术将会导致一些微妙<br>的变化发生，所有的对象都分配在堆上也渐渐变得不是那么“绝对”了。<br>Java 堆是垃圾收集器管理的主要区域，因此很多时候也被称做“GC 堆”（Garbage<br>Collected Heap，幸好国内没翻译成“垃圾堆”）。如果从内存回收的角度看，由于现在<br>收集器基本都是采用的分代收集算法，所以Java 堆中还可以细分为：新生代和老年代；<br>再细致一点的有Eden 空间、From Survivor 空间、To Survivor 空间等。如果从内存分配<br>的角度看，线程共享的Java 堆中可能划分出多个线程私有的分配缓冲区（Thread Local<br>Allocation Buffer，TLAB）。不过，无论如何划分，都与存放内容无关，无论哪个区域，<br>存储的都仍然是对象实例，进一步划分的目的是为了更好地回收内存，或者更快地分配<br>内存。在本章中，我们仅仅针对内存区域的作用进行讨论，Java 堆中的上述各个区域的<br>分配和回收等细节将会是下一章的主题。</p>
<p>根据Java 虚拟机规范的规定，Java 堆可以处于物理上不连续的内存空间中，只要<br>逻辑上是连续的即可，就像我们的磁盘空间一样。在实现时，既可以实现成固定大小<br>的，也可以是可扩展的，不过当前主流的虚拟机都是按照可扩展来实现的（通过-Xmx<br>和-Xms 控制）。如果在堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出<br>OutOfMemoryError 异常。</p>
<h3 id="运行时常量"><a href="#运行时常量" class="headerlink" title="运行时常量"></a>运行时常量</h3><p>运行时常量池（Runtime Constant Pool）是方法区的一部分。Class 文件中除了有<br>类的版本、字段、方法、接口等描述等信息外，还有一项信息是常量池（Constant Pool<br>Table），用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后存放<br>到方法区的运行时常量池中。</p>
<p>Java 虚拟机对Class 文件的每一部分（自然也包括常量池）的格式都有严格的规<br>定，每一个字节用于存储哪种数据都必须符合规范上的要求，这样才会被虚拟机认可、<br>装载和执行。但对于运行时常量池，Java 虚拟机规范没有做任何细节的要求，不同的<br>提供商实现的虚拟机可以按照自己的需要来实现这个内存区域。不过，一般来说，除<br>了保存Class 文件中描述的符号引用外，还会把翻译出来的直接引用也存储在运行时常<br>量池中。</p>
<p>运行时常量池相对于Class 文件常量池的另外一个重要特征是具备动态性，Java 语<br>言并不要求常量一定只能在编译期产生，也就是并非预置入Class 文件中常量池的内容<br>才能进入方法区运行时常量池，运行期间也可能将新的常量放入池中，这种特性被开发<br>人员利用得比较多的便是String 类的intern() 方法。</p>
<p>既然运行时常量池是方法区的一部分，自然会受到方法区内存的限制，当常量池无<br>法再申请到内存时会抛出OutOfMemoryError 异常</p>
<h3 id="5-方法区"><a href="#5-方法区" class="headerlink" title="5. 方法区"></a>5. 方法区</h3><h3 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h3><p>直接内存（Direct Memory）并不是虚拟机运行时数据区的一部分，也不是Java<br>虚拟机规范中定义的内存区域，但是这部分内存也被频繁地使用，而且也可能导致<br>OutOfMemoryError 异常出现，所以我们放到这里一起讲解。<br>在JDK 1.4 中新加入了NIO（New Input/Output）类，引入了一种基于通道（Channel）<br>与缓冲区（Buffer）的I/O 方式，它可以使用 Native 函数库直接分配堆外内存，然<br>后通过一个存储在 Java 堆里面的 DirectByteBuffer 对象作为这块内存的引用进行<br>操作。这样能在一些场景中显著提高性能，因为避免了在 Java 堆和 Native 堆中来<br>回复制数据。</p>
<p>显然，本机直接内存的分配不会受到 Java 堆大小的限制，但是，既然是内存，则<br>肯定还是会受到本机总内存（包括 RAM 及 SWAP 区或者分页文件）的大小及处理器<br>寻址空间的限制。服务器管理员配置虚拟机参数时，一般会根据实际内存设置 -Xmx<br>等参数信息，但经常会忽略掉直接内存，使得各个内存区域的总和大于物理内存限制<br>（包括物理上的和操作系统级的限制），从而导致动态扩展时出现 OutOfMemoryError<br>异常。</p>
<p>逻辑内存模型我们已经看到了，那当我们建立一个对象的时候是怎么进行访问的呢？<br>在 Java 语言中，对象访问是如何进行的？对象访问在 Java 语言中无处不在，是最普通的程序行为，但即使是最简单的访问，也会却涉及 Java 栈、Java 堆、方法区这三个最重要内存区<br>域之间的关联关系，如下面的这句代码：</p>
<pre class=" language-Java"><code class="language-Java">Object obj = new Object();</code></pre>
<p>假设这句代码出现在方法体中，那 <code>Object obj</code> 这部分的语义将会反映到 Java 栈<br>的本地变量表中，作为一个 reference 类型数据出现。而 <code>new Object()</code>这部分的语义<br>将会反映到 Java 堆中，形成一块存储了 Object 类型所有实例数据值（Instance Data，对<br>象中各个实例字段的数据）的结构化内存，根据具体类型以及虚拟机实现的对象内存布<br>局（Object Memory Layout）的不同，这块内存的长度是不固定的。另外，在 Java 堆中<br>还必须包含能查找到此对象类型数据（如对象类型、父类、实现的接口、方法等）的地<br>址信息，这些类型数据则存储在方法区中。</p>
<p>由于 reference 类型在 Java 虚拟机规范里面只规定了一个指向对象的引用，并没有<br>定义这个引用应该通过哪种方式去定位，以及访问到 Java 堆中的对象的具体位置，因此<br>不同虚拟机实现的对象访问方式会有所不同，主流的访问方式有两种：使用句柄和直接<br>指针。</p>
<p>如果使用句柄访问方式，Java 堆中将会划分出一块内存来作为句柄池，reference<br>中存储的就是对象的句柄地址，而句柄中包含了对象实例数据和类型数据各自的<br>具体地址信息，如下图所示。</p>
<p>如果使用直接指针访问方式，Java 堆对象的布局中就必须考虑如何放置访问类型<br>数据的相关信息，reference 中直接存储的就是对象地址，如下图所示</p>
<p>这两种对象的访问方式各有优势，使用句柄访问方式的最大好处就是 reference 中存<br>储的是稳定的句柄地址，在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只<br>会改变句柄中的实例数据指针，而 reference 本身不需要被修改。<br>使用直接指针访问方式的最大好处就是速度更快，它节省了一次指针定位的时间开<br>销，由于对象的访问在 Java 中非常频繁，因此这类开销积少成多后也是一项非常可观的</p>
<p>执行成本。就本书讨论的主要虚拟机 Sun HotSpot 而言，它是使用第二种方式进行对象访问的，但从整个软件开发的范围来看，各种语言和框架使用句柄来访问的情况也十分常见。</p>
<p>下面我们来看几个示例</p>
<h2 id="Test"><a href="#Test" class="headerlink" title="Test"></a>Test</h2><h2 id="Others"><a href="#Others" class="headerlink" title="Others"></a>Others</h2><p><a href="https://www.cnblogs.com/fubaizhaizhuren/p/4976839.html">https://www.cnblogs.com/fubaizhaizhuren/p/4976839.html</a></p>
<p><a href="https://blog.csdn.net/anjoyandroid/article/details/78609971">https://blog.csdn.net/anjoyandroid/article/details/78609971</a></p>
]]></content>
      <tags>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title>java-features-stream 底层原理</title>
    <url>/blogs/java-stream-principle.html</url>
    <content><![CDATA[<h1 id="Java-Stream-底层原理"><a href="#Java-Stream-底层原理" class="headerlink" title="Java Stream 底层原理"></a>Java Stream 底层原理</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢~~</p>
<p>Stream 并行流 使用条件</p>
<ul>
<li>独立：每个元素的计算都不依赖或影响任何其他元素的计算</li>
<li>无干扰：功能（function）执行的时候不会修改基础的数据源</li>
<li>无状态</li>
</ul>
<p>Stream 并行流底层使用的是 fork/join 框架。我们可以自定义并行流的最大线程数。</p>
]]></content>
      <tags>
        <tag>Java 基础</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解 AQS</title>
    <url>/blogs/java-thread-aqs.html</url>
    <content><![CDATA[<h1 id="深入理解-AQS"><a href="#深入理解-AQS" class="headerlink" title="深入理解 AQS"></a>深入理解 AQS</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢 ~~</p>
<blockquote>
<p>抽象队列同步器 <code>AbstractQuenedSynchronizer</code>。是除了 <code>java</code> 自带的 <code>synchronized</code> 关键字之外的锁机制。</p>
</blockquote>
<h5 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h5><p>如果请求的共享资源空闲，则将当前线程置位工作线程，共享资源设置为锁定状态。<br>如果请求的共享资源别占用，则使用一套阻塞等待，以及唤醒分配的锁机制。这个机制由 AQS 的 CLH 队列保证，即将暂时不使用的线程<br>放入队列中。</p>
<blockquote>
<p>CLH（Craig，Landin，and Hagersten）队列是一个虚拟的双向队列，虚拟的双向队列即不存在队列实例，仅存在节点之间的关联关系。</p>
</blockquote>
<blockquote>
<p><code>AQS</code> 就是基于 <code>CLH</code> 队列，用 <code>volatile</code> 修饰共享变量 <code>state</code>，线程通过 <code>CAS</code> 去改变状态符，成功则获取锁成功，失败则进入等待队列，等待被唤醒。</p>
</blockquote>
<p>实现了 AQS 的锁有：</p>
<ul>
<li>自旋锁</li>
<li>互斥锁</li>
<li>读写锁</li>
<li>信号量</li>
<li>栅栏</li>
</ul>
<p>AQS  通过调用 Unsafe 类的 CAS 来保证原子性。</p>
<p>AQS </p>
<h5 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h5><ul>
<li><p><a href="https://segmentfault.com/a/1190000017372067">深入分析AQS实现原理</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s?__biz=MzU3OTc1MDM1Mg==&mid=2247495050&idx=1&sn=9c3b9bd08267309e823c0067f183afe0&chksm=fd63fd35ca147423f268b4416f89424c4d61541a5086e96f58b2c169230744d0c37fa2f0ce64&scene=21#wechat_redirect">Java并发编程：什么是JDK内置并发框架AQS</a></p>
</li>
<li><p><a href="https://xie.infoq.cn/article/05516b2a11d576b74e49df634">Java 并发编程：AQS 的原子性如何保证</a></p>
</li>
<li><p><a href="https://segmentfault.com/a/1190000017372067">(九)深入分析AQS实现原理</a></p>
</li>
<li><p><a href="https://blog.csdn.net/mulinsen77/article/details/84583716">AQS详解（面试）</a></p>
</li>
</ul>
]]></content>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>多线程 - 原子类</title>
    <url>/blogs/java-thread-atomic.html</url>
    <content><![CDATA[<h1 id="多线程-原子类"><a href="#多线程-原子类" class="headerlink" title="多线程 - 原子类"></a>多线程 - 原子类</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢 ~~</p>
<p>Atomic 类底层使用的是 CAS </p>
<p>UnSafe 类</p>
<p>AtomicStampedReference 类使用的 使用的是 时间版本号</p>
<p>除了比较值外 还加入了 时间版本号的比较。</p>
<h5 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h5><ul>
<li><p><a href="http://ifeve.com/atomic-operation/">聊聊并发（五）原子操作的实现原理</a></p>
</li>
<li><p><a href="https://www.cnblogs.com/scuwangjun/p/9098057.html">AtomicInteger的原理</a></p>
</li>
</ul>
]]></content>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解多线程 - 自旋锁</title>
    <url>/blogs/java-thread-auto-lock.html</url>
    <content><![CDATA[<h1 id="深入理解多线程-自旋锁"><a href="#深入理解多线程-自旋锁" class="headerlink" title="深入理解多线程 - 自旋锁"></a>深入理解多线程 - 自旋锁</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢 ~~</p>
<h5 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h5><ul>
<li><a href="https://blog.csdn.net/qq_34337272/article/details/81252853?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-1.pc_relevant_default&spm=1001.2101.3001.4242.2&utm_relevant_index=3">面试必备之深入理解自旋锁</a></li>
</ul>
]]></content>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>并发编程 - CAS</title>
    <url>/blogs/java-thread-cas.html</url>
    <content><![CDATA[<h1 id="并发编程-CAS"><a href="#并发编程-CAS" class="headerlink" title="并发编程 - CAS"></a>并发编程 - CAS</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢 ~~</p>
<h4 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h4><ul>
<li><a href="https://segmentfault.com/a/1190000015239603">并发编程—CAS（Compare And Swap）</a></li>
</ul>
]]></content>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>java-thread-close</title>
    <url>/blogs/java-thread-close.html</url>
    <content><![CDATA[<h1 id="深入理解多线程-如何优雅关闭线程"><a href="#深入理解多线程-如何优雅关闭线程" class="headerlink" title="深入理解多线程 - 如何优雅关闭线程"></a>深入理解多线程 - 如何优雅关闭线程</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢 ~~</p>
<p>线程是一段运行中的代码，我们不能终止在运行中的代码，因为如果我们强制关闭，那么线程中所使用的所有资源，例如文件描述符，网络连接等都不能正常关闭。Java 中的 destory 和 stop 函数都是官方明确不建议使用的。</p>
<p>合理的关闭办法是，让其运行完（也就是函数执行完毕）。干净的释放掉所有资源，然后退出。如果是一个不断循环运行的线程，就需要用到线程间的通信机制，让主线程通知其退出。</p>
<h3 id="1-轻量级阻塞和重量级阻塞"><a href="#1-轻量级阻塞和重量级阻塞" class="headerlink" title="1. 轻量级阻塞和重量级阻塞"></a>1. 轻量级阻塞和重量级阻塞</h3><p>能够被中断的阻塞称为轻量级阻塞，对应的线程状态是 <code>WAITING</code> 或者 <code>TIMED_WAITING</code>。而像 synchronized 这中不能被终端的阻塞称为重量级阻塞。对应的状态是 BLOCKED。</p>
<p>thread.interrupted() 相对于给线程发送了一个唤醒的信号，所以如果线程此时恰好处于 WAITING 或者 TIMED_WAITING 状态，就会抛出一个 InterruptedException，并且线程被唤醒。而如果<br>线程此时并没有被阻塞，则线程什么都不会做。但在后续，线程可以判断自己是否收到过其他线程发来的终端信号，然后做一些对应的处理。</p>
<p>thread.isInterrupted() 与 Thread.interrupted() 都可以用来判断是否收到过终端信息，前者是非静态函数，后者是静态函数。二者的区别在于，前者只读取中断状态，后者不仅读取中断状态，还会重置中断标志位。</p>
]]></content>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 多线程 Condition 理解</title>
    <url>/blogs/java-thread-condition.html</url>
    <content><![CDATA[<h1 id="Java-多线程-Condition-理解"><a href="#Java-多线程-Condition-理解" class="headerlink" title="Java 多线程 Condition 理解"></a>Java 多线程 Condition 理解</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢 ~~</p>
<h5 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h5><ul>
<li><a href="https://blog.csdn.net/weixin_38308374/article/details/113797862">java8 Lock中Condition的await/signal原理详解</a></li>
</ul>
]]></content>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解多线程 - 核心线程数的确定</title>
    <url>/blogs/java-thread-core-number-define.html</url>
    <content><![CDATA[<h1 id="深入理解多线程-核心线程数的确定"><a href="#深入理解多线程-核心线程数的确定" class="headerlink" title="深入理解多线程 - 核心线程数的确定"></a>深入理解多线程 - 核心线程数的确定</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢 ~~</p>
<h5 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h5><ul>
<li><a href="https://www.cnblogs.com/dennyzhangdd/p/6909771.html">根据 CPU 数确定核心线程数</a></li>
</ul>
]]></content>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 多线程 CountDownLatch</title>
    <url>/blogs/java-thread-countdownlatch.html</url>
    <content><![CDATA[<h1 id="Java-多线程-CountDownLatch"><a href="#Java-多线程-CountDownLatch" class="headerlink" title="Java 多线程 CountDownLatch"></a>Java 多线程 CountDownLatch</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢 ~~</p>
<h5 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h5><ul>
<li><a href="https://blog.csdn.net/qq_38293564/article/details/80557355">Java并发编程之CountDownLatch详解</a></li>
</ul>
]]></content>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解 Java 多线程 Join</title>
    <url>/blogs/java-thread-join.html</url>
    <content><![CDATA[<h1 id="深入理解-Java-多线程-Join"><a href="#深入理解-Java-多线程-Join" class="headerlink" title="深入理解 Java 多线程 Join"></a>深入理解 Java 多线程 Join</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢 ~~</p>
<p>当前线程需要等待之前的线程执行完成后，才能继续运行。</p>
<p>Join 可以阻塞的本质是，底层源码会最终调用 Object wait 方法。 方法 wait 是被 synchronize 修饰的，锁为  this。<br>wait/notifyall</p>
<h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><ul>
<li><a href="https://segmentfault.com/a/1190000017255019">(四)Thread.join的作用和原理</a></li>
</ul>
]]></content>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>java-thread-lock</title>
    <url>/blogs/java-thread-lock.html</url>
    <content><![CDATA[<h1 id="java-thread-lock"><a href="#java-thread-lock" class="headerlink" title="java-thread-lock"></a>java-thread-lock</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢 ~~</p>
]]></content>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解 Java 多线程</title>
    <url>/blogs/java-thread-introduce.html</url>
    <content><![CDATA[<h1 id="深入理解-Java-多线程"><a href="#深入理解-Java-多线程" class="headerlink" title="深入理解 Java 多线程"></a>深入理解 Java 多线程</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢 ~~</p>
<h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><ol>
<li><a href="http://zqhxuyuan.github.io/2017/10/25/Java-Threads/">图解 Java 多线程</a></li>
</ol>
]]></content>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>多线程-semaphore</title>
    <url>/blogs/java-thread-semaphore.html</url>
    <content><![CDATA[<h1 id="多线程-semaphore"><a href="#多线程-semaphore" class="headerlink" title="多线程-semaphore"></a>多线程-semaphore</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢 ~~</p>
<h5 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h5><ul>
<li><a href=""></a></li>
</ul>
]]></content>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解 Java 多线程 - LockSupport</title>
    <url>/blogs/java-thread-locksupport.html</url>
    <content><![CDATA[<h1 id="深入理解-Java-多线程-LockSupport"><a href="#深入理解-Java-多线程-LockSupport" class="headerlink" title="深入理解 Java 多线程 - LockSupport"></a>深入理解 Java 多线程 - LockSupport</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢 ~~</p>
<h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><ol>
<li><a href="https://xie.infoq.cn/article/610a1a56ad372645e1c5036dc">【Java 技术之旅】从底层分析 LockSupport 原理机制</a></li>
</ol>
]]></content>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 多线程 Start</title>
    <url>/blogs/java-thread-start.html</url>
    <content><![CDATA[<h1 id="Java-多线程-Start"><a href="#Java-多线程-Start" class="headerlink" title="Java 多线程 Start"></a>Java 多线程 Start</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢 ~~</p>
<p>线程的 创建</p>
<p>Java 创建线程后必须调用 Start 方法。start 方法会调用 本地方法 start0()。该方法会调用虚拟机启动一个本地线程，本地线程会调用</p>
<p>线程的终止</p>
<p>不推荐使用 Thread.stop() 因为该方法不会保证资源被正常回收。使用 Thread 的中断机制。</p>
<p>当前系统创建线程的方法创建一个线程，创建的线程执行后会进行函数回调，调用 run 方法执行业务逻辑。</p>
<h5 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h5><ul>
<li><a href="https://segmentfault.com/a/1190000017255007">(三)从jvm层面了解线程的启动和停止</a></li>
</ul>
]]></content>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解 Java 多线程 - synchronized</title>
    <url>/blogs/java-thread-synchronized.html</url>
    <content><![CDATA[<h1 id="深入理解-Java-多线程-synchronized"><a href="#深入理解-Java-多线程-synchronized" class="headerlink" title="深入理解 Java 多线程 - synchronized"></a>深入理解 Java 多线程 - synchronized</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>ReentrantLock 独有的功能</p>
<p>1.<code>ReenTrantLock</code> 可以指定是公平锁还是非公平锁。而 <code>synchronized</code> 只能是非公平锁。所谓的公平锁就是先等待的线程先获得锁。</p>
<p>2.<code>ReenTrantLock</code> 提供了一个 <code>Condition</code>（条件）类，用来实现分组唤醒需要唤醒的线程们，而不是像 <code>synchronized</code> 要么随机唤醒一个线程要么唤醒全部线程。</p>
<p>3.<code>ReenTrantLock</code> 提供了一种能够中断等待锁的线程的机制，通过 <code>lock.lockInterruptibly()</code> 来实现这个机制。</p>
<p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢 ~~</p>
<h5 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h5><ul>
<li><p><a href="https://segmentfault.com/a/1190000022904663">深度分析：锁升级过程和锁状态，看完这篇你就懂了！</a></p>
</li>
<li><p><a href="https://www.cnblogs.com/javastack/p/12787771.html">Synchronized 与 ReentrantLock 的区别！</a></p>
</li>
<li><p><a href="https://segmentfault.com/a/1190000017255044">(五)Synchronized原理分析</a></p>
</li>
</ul>
]]></content>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 多线程状态</title>
    <url>/blogs/java-thread-status.html</url>
    <content><![CDATA[<h1 id="Java-多线程状态"><a href="#Java-多线程状态" class="headerlink" title="Java 多线程状态"></a>Java 多线程状态</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢 ~~</p>
<p>多线程的状态</p>
<p>new runnable blocked waiting time_waiting termined</p>
<h5 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h5><ul>
<li><p><a href="https://segmentfault.com/a/1190000017252672">(一)线程的发展历史</a></p>
</li>
<li><p><a href="https://www.cnblogs.com/lifegoeson/p/13516019.html">java线程的五大状态，阻塞状态详解</a></p>
</li>
</ul>
]]></content>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>java-thread-threadlocal</title>
    <url>/blogs/java-thread-threadlocal.html</url>
    <content><![CDATA[<h1 id="深入理解-java-多线程-ThreadLocal"><a href="#深入理解-java-多线程-ThreadLocal" class="headerlink" title="深入理解 java 多线程 - ThreadLocal"></a>深入理解 java 多线程 - ThreadLocal</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢 ~~</p>
<blockquote>
<p>ThreadLocal是通过线程隔离的方式防止任务在共享资源上产生冲突, 线程本地存储是一种自动化机制，可以为使用相同变量的每个不同线程都创建不同的存储。</p>
</blockquote>
<p>相关问题</p>
<ol>
<li>什么是ThreadLocal? 用来解决什么问题的? </li>
<li>说说你对ThreadLocal的理解 </li>
<li>为什么ThreadLocal会造成内存泄露? 如何解决 </li>
<li>还有哪些使用ThreadLocal的应用场景? </li>
<li>ThreadLocal是如何实现线程隔离的? </li>
<li>ThreadLocal 原理</li>
</ol>
<p><code>ThreadLocal</code> 是一个将在多线程中为每一个线程创建单独的变量副本的类; 当使用 <code>ThreadLocal</code> 来维护变量时,<code>ThreadLocal</code> 会为每个线程创建单独的变量副本, 避免因多线程操作共享变量而导致的数据不一致的情况。</p>
<h5 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h5><ul>
<li><a href="https://www.cnblogs.com/bingxinshuo/p/11503601.html">深入理解 ThreadLocal </a></li>
</ul>
]]></content>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解 Java 线程池 - 实战</title>
    <url>/blogs/java-thread-threadpool.html</url>
    <content><![CDATA[<h1 id="深入理解-Java-线程池-实战"><a href="#深入理解-Java-线程池-实战" class="headerlink" title="深入理解 Java 线程池 - 实战"></a>深入理解 Java 线程池 - 实战</h1><h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 PR 谢谢~~</p>
<h4 id="为什么需要线程池"><a href="#为什么需要线程池" class="headerlink" title="为什么需要线程池"></a>为什么需要线程池</h4><p>我们知道创建线程的常用方式就是 new Thread()，而每一次new Thread()都会重新创建一个线程，而线程的创建和销毁都需要耗时的，不仅会消耗系统资源，还会降低系统的稳定性。在 jdk1.5 的 JUC 包中有一个 Executors，他能使我们创建的线程得到复用，不会频繁的创建和销毁线程。</p>
<p>合理的使用线程池可以带来以下几个好处：</p>
<ol>
<li>降低资源消耗。</li>
</ol>
<blockquote>
<p>通过重复利用已创建的线程，降低线程创建和销毁造成的消耗。</p>
</blockquote>
<ol start="2">
<li>提高响应速度。</li>
</ol>
<blockquote>
<p>当任务到达时，任务可以不需要等到线程创建就能立即执行。</p>
</blockquote>
<ol start="3">
<li>增加线程的可管理性。</li>
</ol>
<blockquote>
<p>线程是稀缺资源，使用线程池可以进行统一分配，调优和监控。</p>
</blockquote>
<h2 id="一-Java-线程池详解"><a href="#一-Java-线程池详解" class="headerlink" title="一. Java 线程池详解"></a>一. Java 线程池详解</h2><p><img src="https://pic3.zhimg.com/80/v2-10a39f5ab6ff4780007537e2e73ee106_1440w.jpg"></p>
<ul>
<li>corePoolSize 核心线程池大小</li>
<li>maximumPoolSize 线程池允许的最大线程数</li>
<li>keepAliveTime 线程池没有任务时存活的最长时间</li>
<li>unit 存活时间的单位</li>
<li>workQueue 阻塞队列</li>
<li>threadFactory 线程工厂</li>
<li>handler 线程饱和策略</li>
</ul>
<h3 id="1-corePoolSize："><a href="#1-corePoolSize：" class="headerlink" title="1.corePoolSize："></a>1.<strong>corePoolSize</strong>：</h3><p>线程池的核心池大小，在创建线程池之后，线程池默认没有任何线程。当有任务过来时，才会去创建线程并执行任务。直到创建的线程数量达到 corePoolSize。之后，再有任务进来时，就会被放入队列中。corePoolSize 表示允许线程池中允许同时运行的最大线程数。</p>
<p>如果执行了线程池的 prestartAllCoreThread() 方法，线程池会提前创建并启动所有核心线程。</p>
<h3 id="2-maximumPoolSize："><a href="#2-maximumPoolSize：" class="headerlink" title="2.maximumPoolSize："></a>2.<strong>maximumPoolSize</strong>：</h3><p>线程池允许的最大线程数，他表示最大能创建多少个线程。maximunPoolSize 肯定是大于等于 corePoolSize。</p>
<h3 id="3-keepAliveTime："><a href="#3-keepAliveTime：" class="headerlink" title="3. keepAliveTime："></a>3. <strong>keepAliveTime</strong>：</h3><p>表示线程没有任务时，最多保持多久然后停止。默认情况下，只有线程池中的线程数大于 corePoolSize 时，keepAliveTime 才会起作用。即，当线程池中的线程数大于 corePoolSize 并且一个线程空闲时间达到了 keepAliveTime 时，那么就是会 shutdown。</p>
<h3 id="4-Unit："><a href="#4-Unit：" class="headerlink" title="4. Unit："></a>4. <strong>Unit</strong>：</h3><p>keepAliveTime 的单位。</p>
<h3 id="5-workQueue："><a href="#5-workQueue：" class="headerlink" title="5. workQueue："></a>5. <strong>workQueue</strong>：</h3><p>一个阻塞队列，用来存储等待执行的任务，当线程池中的线程数超过它的 corePoolSize 时，线程会进入阻塞队列进行阻塞等待。通过 workQueue，线程池实现了阻塞功能。</p>
<h3 id="6-threadFactory："><a href="#6-threadFactory：" class="headerlink" title="6. threadFactory："></a>6. <strong>threadFactory</strong>：</h3><p>线程工厂，用来创建线程。</p>
<h3 id="7-handler："><a href="#7-handler：" class="headerlink" title="7. handler："></a>7. <strong>handler</strong>：</h3><p>表示拒绝处理任务时的策略。</p>
<h2 id="可选择的阻塞队列-BlockingQueue-详解"><a href="#可选择的阻塞队列-BlockingQueue-详解" class="headerlink" title="可选择的阻塞队列 BlockingQueue 详解"></a>可选择的阻塞队列 BlockingQueue 详解</h2><p>主要有3种类型的BlockingQueue：</p>
<h3 id="1-无界队列"><a href="#1-无界队列" class="headerlink" title="1. 无界队列"></a>1. 无界队列</h3><p>队列大小无限制，常用的为无界的 <code>LinkedBlockingQueue</code>，使用该队列做为阻塞队列时要尤其当心，当任务耗时较长时可能会导致大量新任务在队列中堆积最终导致 OOM。阅读代码发现，<code>Executors.newFixedThreadPool</code> 采用就是 <code>LinkedBlockingQueue</code>，而楼主踩到的就是这个坑，当QPS很高，发送数据很大，大量的任务被添加到这个无界 <code>LinkedBlockingQueue</code> 中，导致 cpu 和内存飙升服务器挂掉。</p>
<h3 id="2-有界队列"><a href="#2-有界队列" class="headerlink" title="2. 有界队列"></a>2. 有界队列</h3><p>常用的有两类，一类是遵循 FIFO 原则的队列如 <code>ArrayBlockingQueue</code>与有界的 <code>LinkedBlockingQueue</code>，另一类是优先级队列如 <code>PriorityBlockingQueue</code>。<code>PriorityBlockingQueue</code> 中的优先级由任务的 <code>Comparator</code> 决定。<br>使用有界队列时队列大小需和线程池大小互相配合，线程池较小有界队列较大时可减少内存消耗，降低 cpu 使用率和上下文切换，但是可能会限制系统吞吐量。</p>
<h3 id="3-同步移交队列"><a href="#3-同步移交队列" class="headerlink" title="3. 同步移交队列"></a>3. 同步移交队列</h3><p>如果不希望任务在队列中等待而是希望将任务直接移交给工作线程，可使用 <code>SynchronousQueue</code> 作为等待队列。<code>SynchronousQueue</code> 不是一个真正的队列，而是一种线程之间移交的机制。要将一个元素放入 <code>SynchronousQueue</code> 中，必须有另一个线程正在等待接收这个元素。只有在使用无界线程池或者有饱和策略时才建议使用该队列。</p>
<h3 id="4-优先级队列"><a href="#4-优先级队列" class="headerlink" title="4. 优先级队列"></a>4. 优先级队列</h3><p>PriorityBlockingQueue</p>
<h3 id="5-延迟队列"><a href="#5-延迟队列" class="headerlink" title="5. 延迟队列"></a>5. 延迟队列</h3><p>DelayQueue</p>
<h3 id="6-无界阻塞队列"><a href="#6-无界阻塞队列" class="headerlink" title="6. 无界阻塞队列"></a>6. 无界阻塞队列</h3><p>LinkedTransfetQueue</p>
<h3 id="7-链表结构的双向阻塞队列"><a href="#7-链表结构的双向阻塞队列" class="headerlink" title="7. 链表结构的双向阻塞队列"></a>7. 链表结构的双向阻塞队列</h3><p>LinkedBlockingQueue</p>
<p>可选择的饱和策略RejectedExecutionHandler详解</p>
<h2 id="任务拒绝策略"><a href="#任务拒绝策略" class="headerlink" title="任务拒绝策略"></a>任务拒绝策略</h2><h3 id="1-AbortPolicy-中止策略"><a href="#1-AbortPolicy-中止策略" class="headerlink" title="1. AbortPolicy 中止策略"></a>1. AbortPolicy 中止策略</h3><p>该策略是默认饱和策略。</p>
<pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">rejectedExecution</span><span class="token punctuation">(</span>Runnable r<span class="token punctuation">,</span> ThreadPoolExecutor e<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RejectedExecutionException</span><span class="token punctuation">(</span><span class="token string">"Task "</span> <span class="token operator">+</span> r<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">" rejected from "</span> <span class="token operator">+</span> e<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre>
<p>使用该策略时在饱和时会抛出RejectedExecutionException（继承自RuntimeException），调用者可捕获该异常自行处理。</p>
<h3 id="2-DiscardPolicy-抛弃策略"><a href="#2-DiscardPolicy-抛弃策略" class="headerlink" title="2. DiscardPolicy 抛弃策略"></a>2. DiscardPolicy 抛弃策略</h3><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">rejectedExecution</span><span class="token punctuation">(</span>Runnable r<span class="token punctuation">,</span> ThreadPoolExecutor e<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre>
<p>如代码所示，不做任何处理直接抛弃任务</p>
<h3 id="3-DiscardOldestPolicy-抛弃旧任务策略"><a href="#3-DiscardOldestPolicy-抛弃旧任务策略" class="headerlink" title="3. DiscardOldestPolicy 抛弃旧任务策略"></a>3. DiscardOldestPolicy 抛弃旧任务策略</h3><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">rejectedExecution</span><span class="token punctuation">(</span>Runnable r<span class="token punctuation">,</span> ThreadPoolExecutor e<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>e<span class="token punctuation">.</span><span class="token function">isShutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
        e<span class="token punctuation">.</span><span class="token function">getQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        e<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre>
<p>如代码，先将阻塞队列中的头元素出队抛弃，再尝试提交任务。如果此时阻塞队列使用 <code>PriorityBlockingQueue</code> 优先级队列，将会导致优先级最高的任务被抛弃，因此不建议将该种策略配合优先级队列使用。</p>
<h3 id="4-CallerRunsPolicy-调用者运行"><a href="#4-CallerRunsPolicy-调用者运行" class="headerlink" title="4. CallerRunsPolicy 调用者运行"></a>4. CallerRunsPolicy 调用者运行</h3><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">rejectedExecution</span><span class="token punctuation">(</span>Runnable r<span class="token punctuation">,</span> ThreadPoolExecutor e<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>e<span class="token punctuation">.</span><span class="token function">isShutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
        r<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre>
<p>既不抛弃任务也不抛出异常，直接运行任务的run方法，换言之将任务回退给调用者来直接运行。使用该策略时线程池饱和后将由调用线程池的主线程自己来执行任务，因此在执行任务的这段时间里主线程无法再提交新任务，从而使线程池中工作线程有时间将正在处理的任务处理完成。</p>
<h2 id="Java-提供的四种常用线程池解析"><a href="#Java-提供的四种常用线程池解析" class="headerlink" title="Java 提供的四种常用线程池解析"></a>Java 提供的四种常用线程池解析</h2><p>   既然楼主踩坑就是使用了 JDK 的默认实现，那么再来看看这些默认实现到底干了什么，封装了哪些参数。简而言之 Executors 工厂方法Executors.newCachedThreadPool() 提供了无界线程池，可以进行自动线程回收；Executors.newFixedThreadPool(int) 提供了固定大小线程池，内部使用无界队列；Executors.newSingleThreadExecutor() 提供了单个后台线程。</p>
<p>详细介绍一下上述四种线程池。</p>
<h3 id="1-newCachedThreadPool"><a href="#1-newCachedThreadPool" class="headerlink" title="1. newCachedThreadPool"></a>1. newCachedThreadPool</h3><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">public</span> <span class="token keyword">static</span> ExecutorService <span class="token function">newCachedThreadPool</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> Integer<span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">,</span> 60L<span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">SynchronousQueue</span><span class="token operator">&lt;</span>Runnable<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre>
<p>在 <code>newCachedThreadPool</code> 中如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。<br>初看该构造函数时我有这样的疑惑：核心线程池为0，那按照前面所讲的线程池策略新任务来临时无法进入核心线程池，只能进入 <code>SynchronousQueue</code> 中进行等待，而SynchronousQueue的大小为1，那岂不是第一个任务到达时只能等待在队列中，直到第二个任务到达发现无法进入队列才能创建第一个线程？<br>这个问题的答案在上面讲SynchronousQueue时其实已经给出了，要将一个元素放入SynchronousQueue中，必须有另一个线程正在等待接收这个元素。因此即便SynchronousQueue一开始为空且大小为1，第一个任务也无法放入其中，因为没有线程在等待从SynchronousQueue中取走元素。因此第一个任务到达时便会创建一个新线程执行该任务。</p>
<h3 id="2-newFixedThreadPool"><a href="#2-newFixedThreadPool" class="headerlink" title="2. newFixedThreadPool"></a>2. newFixedThreadPool</h3><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">public</span> <span class="token keyword">static</span> ExecutorService <span class="token function">newFixedThreadPool</span><span class="token punctuation">(</span>int nThreads<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
<span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span>nThreads<span class="token punctuation">,</span> nThreads<span class="token punctuation">,</span>
0L<span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>MILLISECONDS<span class="token punctuation">,</span>
<span class="token keyword">new</span> <span class="token class-name">LinkedBlockingQueue</span><span class="token operator">&lt;</span>Runnable<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre>
<p>看代码一目了然了，线程数量固定，使用无限大的队列。再次强调，楼主就是踩的这个无限大队列的坑。</p>
<h3 id="3-newScheduledThreadPool"><a href="#3-newScheduledThreadPool" class="headerlink" title="3. newScheduledThreadPool"></a>3. newScheduledThreadPool</h3><p>创建一个定长线程池，支持定时及周期性任务执行。</p>
<p>public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) {<br>return new ScheduledThreadPoolExecutor(corePoolSize);<br>}</p>
<p>在来看看 <code>ScheduledThreadPoolExecutor()</code>的构造函数</p>
<pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">public</span> <span class="token function">ScheduledThreadPoolExecutor</span><span class="token punctuation">(</span>int corePoolSize<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
<span class="token keyword">super</span><span class="token punctuation">(</span>corePoolSize<span class="token punctuation">,</span> Integer<span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> NANOSECONDS<span class="token punctuation">,</span>
<span class="token keyword">new</span> <span class="token class-name">DelayedWorkQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre>
<p>ScheduledThreadPoolExecutor的父类即ThreadPoolExecutor，因此这里各参数含义和上面一样。值得关心的是DelayedWorkQueue这个阻塞对列，在上面没有介绍，它作为静态内部类就在ScheduledThreadPoolExecutor中进行了实现。简单的说，DelayedWorkQueue是一个无界队列，它能按一定的顺序对工作队列中的元素进行排列。</p>
<h3 id="4-newSingleThreadExecutor"><a href="#4-newSingleThreadExecutor" class="headerlink" title="4. newSingleThreadExecutor"></a>4. newSingleThreadExecutor</h3><p>创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。</p>
<pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">public</span> <span class="token keyword">static</span> ScheduledExecutorService <span class="token function">newSingleThreadScheduledExecutor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
<span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">DelegatedScheduledExecutorService</span>
<span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ScheduledThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre>
<p>首先 new了一个线程数目为 1 的 <code>ScheduledThreadPoolExecutor</code>，再把该对象传入 <code>DelegatedScheduledExecutorService</code> 中，看看 <code>DelegatedScheduledExecutorService</code> 的实现代码：</p>
<pre class=" language-javascript"><code class="language-javascript"><span class="token function">DelegatedScheduledExecutorService</span><span class="token punctuation">(</span>ScheduledExecutorService executor<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
<span class="token keyword">super</span><span class="token punctuation">(</span>executor<span class="token punctuation">)</span><span class="token punctuation">;</span>
e <span class="token operator">=</span> executor<span class="token punctuation">;</span>
<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre>
<p>在看看它的父类</p>
<pre class=" language-javascript"><code class="language-javascript"><span class="token function">DelegatedExecutorService</span><span class="token punctuation">(</span>ExecutorService executor<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
e <span class="token operator">=</span> executor<span class="token punctuation">;</span>
<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre>
<p>其实就是使用装饰模式增强了 <code>ScheduledExecutorService</code>（1）的功能，不仅确保只有一个线程顺序执行任务，也保证线程意外终止后会重新创建一个线程继续执行任务。</p>
<h5 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h5><ul>
<li><p><a href="https://xie.infoq.cn/article/d0120c6e1518cec1da65cd31f">深入 Java 线程池：从设计思想到源码解读</a></p>
</li>
<li><p><a href="https://blog.csdn.net/u010412719/article/details/52132613">《Java线程池》：任务拒绝策略</a></p>
</li>
<li><p><a href="https://tech.meituan.com/2020/04/02/java-pooling-pratice-in-meituan.html">Java线程池实现原理及其在美团业务中的实践</a></p>
</li>
</ul>
]]></content>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>java-thread-volatile</title>
    <url>/blogs/java-thread-volatile.html</url>
    <content><![CDATA[<h1 id="并发编程-深入理解-volatile"><a href="#并发编程-深入理解-volatile" class="headerlink" title="并发编程 - 深入理解 volatile"></a>并发编程 - 深入理解 volatile</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢 ~~</p>
<blockquote>
<p>可见性</p>
<p>防止指令重排序</p>
</blockquote>
<p>Java 内存模型中定义的 8 种工作内存与主内存之间的原子操作</p>
<ol>
<li>lock( 锁定 )：作用于主内存的变量，把一个变量标识为一条线程独占的状态。</li>
<li>unlock（解锁）：作用于主内存的变量，把一个处于锁定的变量释放出来，释放变量才可以被其他线程锁定。</li>
<li>read（读取）：作用于主内存的变量，把一个变量的值从主内存传输到线程的工作内存中，以便随后的load动作使用。</li>
<li>load（载入）：作用于**<em>工作内存**</em>的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中。</li>
<li>use（使用）：作用于**<em>工作内**</em>存种的变量，它把工作内存中一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用到变量的值的字节码指令时将会执行这个操作。</li>
<li>assign（赋值）：作用于**<em>工作内存**</em>中的变量，它把一个从执行引擎接收到的值赋给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。</li>
<li>store（存储）：作用于**<em>工作内存**</em>的变量，它把工作内存中一个变量的值传送到主内存中，以便随后的write操作使用</li>
<li>write（写入）：作用于主内存的变量，它把store操作从工作内存中得到的值放入主内存的变量中。</li>
</ol>
<h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><p>那么 Volatile 是如何来保证可见性的呢？在 x86 处理器下通过工具获取 JIT 编译器生成的汇编指令来看看对 Volatile 进行写操作 CPU 会做什么事情。</p>
<p>Java 代码：</p>
<pre class=" language-javascript"><code class="language-javascript">instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//instance 是 volatile 变量</span></code></pre>
<p>汇编代码：</p>
<pre class=" language-shell"><code class="language-shell">0x01a3de1d: movb $0x0,0x1104800(%esi);

0x01a3de24: lock addl $0x0,(%esp);</code></pre>
<p>有 volatile 变量修饰的共享变量进行写操作的时候会多第二行汇编代码，通过查 IA-32 架构软件开发者手册可知，lock 前缀的指令在多核处理器下会引发了两件事情。</p>
<ul>
<li>将当前处理器缓存行的数据会写回到系统内存。</li>
<li>这个写回内存的操作会引起在其他 CPU 里缓存了该内存地址的数据无效。</li>
</ul>
<h4 id="1-Lock-前缀指令会引起处理器缓存回写到内存"><a href="#1-Lock-前缀指令会引起处理器缓存回写到内存" class="headerlink" title="1. Lock 前缀指令会引起处理器缓存回写到内存"></a>1. Lock 前缀指令会引起处理器缓存回写到内存</h4><p>Lock 前缀指令导致在执行指令期间，声言处理器的 LOCK# 信号。在多处理器环境中，LOCK# 信号确保在声言该信号期间，处理器可以独占使用任何共享内存。（因为它会锁住总线，导致其他 CPU 不能访问总线，不能访问总线就意味着不能访问系统内存），但是在最近的处理器里，LOCK＃信号一般不锁总线，而是锁缓存，毕竟锁总线开销比较大。在 8.1.4 章节有详细说明锁定操作对处理器缓存的影响，对于 Intel486 和 Pentium 处理器，在锁操作时，总是在总线上声言 LOCK#信号。但在 P6 和最近的处理器中，如果访问的内存区域已经缓存在处理器内部，则不会声言 LOCK#信号。相反地，它会锁定这块内存区域的缓存并回写到内存，并使用缓存一致性机制来确保修改的原子性，此操作被称为“缓存锁定”，缓存一致性机制会阻止同时修改被两个以上处理器缓存的内存区域数据。</p>
<h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a href="https://juejin.cn/post/6844903607062659079">https://juejin.cn/post/6844903607062659079</a></p>
<p><a href="https://juejin.cn/post/6844903510480257037#heading-5">https://juejin.cn/post/6844903510480257037#heading-5</a></p>
]]></content>
      <tags>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 可变参数</title>
    <url>/blogs/java-variable-parameter.html</url>
    <content><![CDATA[<h2 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h2><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢~~</p>
<p>Java 要求实参和形参的数量和类型必须一致，而形参的数目是在方法定义时就已经确定了。重载允许我们扩展参数的类型和数目，但如果需求不同的内容过多，就会产生过多的重载方法。</p>
<p>在这种情况下，我们可以用数组来包裹多个参数，然后将其作为参数进行传递。</p>
<p>在不确定方法需要处理的对象的数量时可以使用可变长参数，会使得方法调用更简单，无需手动创建数组 new T[]{…}。与“数组包裹”的方法相比，真正的实参个数可变的方法，在调用时更为简单，含义也更清楚，但存在自身的限制。</p>
<h3 id="函数签名"><a href="#函数签名" class="headerlink" title="函数签名"></a>函数签名</h3><pre class=" language-text"><code class="language-text">public void test(Integer... args)</code></pre>
<p> 只要在一个形参的“类型”与“参数名”之间加上三个连续的“.”（即“…”，英文里的句中省略号），就可以让它和不确定个实参相匹配。而一个带有这样的形参的方法，就是一个实参个数可变的方法。</p>
<h4 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h4><ol>
<li>不定项参数必须放在参数列表最后一个</li>
<li>不定项参数只能有一个（多个，必然有一个不是最后一个）。</li>
<li>重载时，运行优先级问题。(系统优先匹配确定参数，然后匹配不确定参数)</li>
<li><strong>不定参数会被 Java 转型成数组，所以本质上是一个二维数组</strong></li>
<li>与数组包裹方法相比，存在泛型不可用。</li>
<li>自动装箱和自动拆箱问题</li>
</ol>
<pre class=" language-java"><code class="language-java"><span class="token number">3</span><span class="token punctuation">.</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">method</span><span class="token punctuation">(</span>String <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">method</span><span class="token punctuation">(</span>String s1<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">method</span><span class="token punctuation">(</span>String s1<span class="token punctuation">,</span>String s2<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
    <span class="token function">method</span><span class="token punctuation">(</span><span class="token string">"test1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>              <span class="token comment" spellcheck="true">// invoke method(String s1)</span>
    <span class="token function">method</span><span class="token punctuation">(</span><span class="token string">"test1"</span><span class="token punctuation">,</span><span class="token string">"test2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// invoke method(String s1,String s2);</span>
<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre>
<pre class=" language-java"><code class="language-java"><span class="token number">4</span><span class="token punctuation">.</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">method</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>args<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">method</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span> </code></pre>
<p>因为可变参数最后会被编译成数组，所以不能同时存在。可变参数兼容数组，反之不成立。</p>
<pre class=" language-java"><code class="language-java"><span class="token number">5</span><span class="token punctuation">.</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span>T<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> args<span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// compile failure</span>

<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span>T <span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
     List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> integers <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
         integers<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
                 <span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span>integer <span class="token operator">-</span><span class="token operator">></span> integer <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">)</span>
                 <span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span>Collectors<span class="token punctuation">.</span><span class="token function">toList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                 <span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>integer <span class="token operator">-</span><span class="token operator">></span> System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>integer<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// compile successfully</span></code></pre>
<p>6.</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> args<span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span>INteger <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> args<span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">//Invoke</span>
<span class="token function">test</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">test</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token comment" spellcheck="true">// Above of all,compile failure</span></code></pre>
<ol start="7">
<li><p>可变参数不可以与泛型一起使用，会导致 “generic array creation” 错误。</p>
</li>
<li><p>避免带有可变长度的方法重写。</p>
</li>
<li><p>重写带有可变参数的方法。</p>
</li>
</ol>
<pre class=" language-Java"><code class="language-Java">Class Base&#123;
    public void print(String... args)&#123;
        System.out.println("Base----Test");
    &#125;
&#125;

Class Sub extends Base&#123;
    @Override
    public void print(String [] args)&#123;
        System.out.println("Sub-----Test");
    &#125;
&#125;
class variableParameters()&#123;

     public static void main(String [] args)&#123;
         Base base = new Sub();
         base.println("hello"); //pass

         Sub sub = new Sub();
         sub.println("hello"); //error
     &#125;
 &#125;
</code></pre>
<p>base 对象将子类对象做了向上转型，形参列表是由父类决定的，所以可以通过。而 sub 调用自身复写的方法，参数类型不匹配也不会父类去匹配，所以导致类型不匹配错误。</p>
<ol start="10">
<li>Object… 参数问题</li>
</ol>
<pre class=" language-Java"><code class="language-Java">public void test(Object... args)&#123;
    System.out.println(args.length);
&#125;

test(new String[]&#123;"1","2","3"&#125;);//3
test(100,new String[]&#123;"1","2"&#125;);//2
test(new Integer[]&#123;1,2,3&#125;)//3
test(100,new Integer[]&#123;1,2&#125;)//2
test(1,2,3);//3
test(new int[](1,2,3));//1
</code></pre>
<p>int[] 无法转型为 Object[] ,只会被当成一个数组对象。Integer[] 可以转型为 Object[],可以成为一个对象数组。</p>
<ol start="11">
<li>反射方法调用时的注意事项</li>
</ol>
<pre class=" language-Java"><code class="language-Java">public class Test()&#123;
    public static void test(String... args)&#123;
        System.out.println(args.length);
    &#125;

    public static void main(String [] args)&#123;
        String [] varArgs =new String[]&#123;"a","b"&#125;;
        try&#123;
            Method method = Test.class.getmethod("test",String[].class);
            // Object invoke(Object obj,Object...args);
            method.invoke(null,varArgs);// varArgs.length =2 error
            method.invoke(null,(Object[])varArgs);// String[]  转换为 Object[],varArgs.length =2.error.
            method.invoke(null,(Object) varArgs);// 将整个 String [] 转换为 Object，varArgs.length= 1，right.
            method.invoke(null,new Object[]&#123;varArgs&#125;);//Object[] 长度为 1，right。等价于第三个方法调用。
        &#125;catch(Exception e)&#123;
            e.printStackTrace();
        &#125;
    &#125;
&#125;</code></pre>
<ol start="11">
<li>调用的参数也可以是 0(等价于空数组)</li>
</ol>
<pre class=" language-Java"><code class="language-Java">test();</code></pre>
]]></content>
      <tags>
        <tag>Java 基础</tag>
      </tags>
  </entry>
  <entry>
    <title>多线程 yield</title>
    <url>/blogs/java-thread-yield.html</url>
    <content><![CDATA[<h1 id="多线程-yield"><a href="#多线程-yield" class="headerlink" title="多线程 yield"></a>多线程 yield</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢 ~~</p>
<h5 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h5><ul>
<li><a href=""></a></li>
</ul>
]]></content>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 新版本特性</title>
    <url>/blogs/java-version-new-feature.html</url>
    <content><![CDATA[<h1 id="Java-新版本特性"><a href="#Java-新版本特性" class="headerlink" title="Java 新版本特性"></a>Java 新版本特性</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢 ~~</p>
<p>Java 11 新特性</p>
<ul>
<li><p> Var </p>
<blockquote>
<p>语法糖，编译器会确定对应的变量类型。</p>
</blockquote>
</li>
<li><p>字符串加强</p>
<blockquote>
<p>字符串类型新增了 API</p>
</blockquote>
</li>
<li><p>集合加强</p>
<blockquote>
<p>部分集合新增了 of 和 copy 函数，此时创建的集合为不可变集合，不能进行新增，删除，插入等操作。</p>
</blockquote>
</li>
</ul>
<ul>
<li><p>Stream 增强</p>
</li>
<li><p>Optional 增强</p>
</li>
<li><p>InputStrem 增强</p>
<blockquote>
<p>新增 transfor 函数，可以直接将 inputstream 输入到 outputstream</p>
</blockquote>
</li>
</ul>
<p>Java 13<br>switch 优化更新，增加 yield 关键字用于返回结果。<br>ZGC 支持将未使用的内存归还操作系统<br>引入了文本块，可以使用 “”” 三个引号表示文本块，<br>Java 14<br>instanceof 语法简化，可以直接给对象赋值：<br>引入 Record，类似于枚举类型，具有 Lombok 功能，可以自动生成构造器、equals、getter 等方法。<br>放弃 CMS</p>
<p>Java 15<br>引入 hidden class<br>String.substring 优化，如果长度为 0，返回 null<br>引入 Sealed class<br>Java 16<br>Stream新增toList方法<br>提供jpackage<br>java.time 根据时段获取时间</p>
<h5 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h5><ul>
<li><p><a href="https://mp.weixin.qq.com/s/4zUtQPUn5LYw43IRLm0Dwg">Java 10 实战第 1 篇：局部变量类型推断</a></p>
</li>
<li><p><a href="https://segmentfault.com/a/1190000016537503">Java 11 正式发布，这 8 个逆天新特性教你写出更牛逼的代码</a></p>
</li>
<li><p><a href="https://segmentfault.com/a/1190000021199668">Elasticsearch系列—并发控制及乐观锁实现原理</a></p>
</li>
</ul>
]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM 类加载器原理</title>
    <url>/blogs/jvm-classloader.html</url>
    <content><![CDATA[<h1 id="JVM-类加载器原理"><a href="#JVM-类加载器原理" class="headerlink" title="JVM 类加载器原理"></a>JVM 类加载器原理</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢 ~~</p>
<p>JVM设计者把类加载阶段中的“通过’类全名’来获取定义此类的二进制字节流”这个动作放到Java虚拟机外部去实现，以便让应用程序自己决定如何去获取所需要的类。实现这个动作的代码模块称为“类加载器”。</p>
<p>我们不能自己实现 String 类。尽管我们可以破坏双亲委派机制，自己定义一个 class 来加载，但是实际上 JVM 的实现中已经制定了 像 String 这样的类，<br>必须由 BootStrap 来加载，而BootStrap 是虚拟机的加载器，所以最终还是会调用 java.lang.String 这个类。</p>
<h5 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h5><ul>
<li><p><a href="https://juejin.cn/post/6844903564804882445#heading-5">Java类加载机制（全套）</a></p>
</li>
<li><p><a href="https://blog.csdn.net/riemann_/article/details/87653648">自定义一个java.lang.String类，这个类是否可以被类加载器加载？为什么</a></p>
</li>
</ul>
]]></content>
      <tags>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解 JVM - CMS  垃圾回收器</title>
    <url>/blogs/jvm-cms-gc-collection.html</url>
    <content><![CDATA[<h1 id="深入理解-JVM-CMS-垃圾回收器"><a href="#深入理解-JVM-CMS-垃圾回收器" class="headerlink" title="深入理解 JVM - CMS  垃圾回收器"></a>深入理解 JVM - CMS  垃圾回收器</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢 ~~</p>
<h5 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h5><ul>
<li><a href="https://www.cnblogs.com/aspirant/p/8663911.html">图解 CMS 垃圾回收机制原理，-阿里面试题</a></li>
</ul>
]]></content>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解诶 JVM - 逃逸分析</title>
    <url>/blogs/jvm-escape-analyse.html</url>
    <content><![CDATA[<h1 id="深入理解诶-JVM-逃逸分析"><a href="#深入理解诶-JVM-逃逸分析" class="headerlink" title="深入理解诶 JVM - 逃逸分析"></a>深入理解诶 JVM - 逃逸分析</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢~~</p>
<blockquote>
<p>JVM 中的优化技术</p>
</blockquote>
<h3 id="什么是逃逸？"><a href="#什么是逃逸？" class="headerlink" title="什么是逃逸？"></a>什么是逃逸？</h3><p>逃逸是指在某个方法之内创建的对象，除了在方法体之内被引用之外，还在方法体之外被其它变量引用到；这样带来的后果是在该方法执行完毕之后，该方法中创建的对象将无法被GC回收，由于其被其它变量引用。正常的方法调用中，方法体中创建的对象将在执行完毕之后，将回收其中创建的对象；故由于无法回收，即成为逃逸。</p>
<p>逃逸分析的基本行为就是分析对象动态作用域：当一个对象在方法中被定义后，它可能会被外部方法所引用。比如，作为调用参数传递到其他地方中，称为方法逃逸。</p>
<p>可以被外部线程访问到，比如赋值给类变量或可以在其他线程中访问的实例变量，称为线程逃逸。</p>
<p>如果可以证明一个对象不会逃逸到方法或线程外，那么这个变量可以进行一些高效的优化。</p>
<pre class=" language-Java"><code class="language-Java"> public static StringBuffer create(String a,String b)&#123;
      StringBuffer stringBuffer = new StringBuffer();
      stringBuffer.append(a);
      stringBuffer.append(b);
      return stringBuffer.toString();
 &#125;</code></pre>
<p>在不直接返回 <code>stringBuffer</code> 的情况下，StringBuffer 是不会逃逸出方法的。</p>
<pre class=" language-Java"><code class="language-Java"> public T t;

 public void methodA()&#123;
     T t1 = variableEscape)();
     methodB();
 &#125;

 public T variableEscapee()&#123;
     T t2 =new T();
     return t2;
 &#125;

 pulic void methodB()&#123;
     t=new T();
 &#125;</code></pre>
<p>方法 <code>variableEscape()</code> 的内部对象 t2 的引用返回给 <code>methodA</code> 方法中的变量 v1，<code>methdoB</code> 的内部对象赋值给了全局变量 t，这两种场景都发生了（引用）逃逸。</p>
<p>可以通过 JVM 参数设置开启逃逸分析：</p>
<pre class=" language-Java"><code class="language-Java"> -xx:+DoEscapeAnalysis</code></pre>
<h3 id="栈上分配"><a href="#栈上分配" class="headerlink" title="栈上分配"></a>栈上分配</h3><p>Java 对象是在堆上分配的，垃圾回收机制会回收堆上不再使用的对象，但筛选可回收对象以及整理内存都会消耗时间。如果通过逃逸分析可以确定对象不会逃逸出方法之外，那么就可以将对象分配在栈上，这样对象所占用的空间就会随着栈帧出栈而销毁，这样就减轻了垃圾回收的压力。</p>
<p><strong>注意</strong>：栈上分配受制于栈空间大小。自我迭代等对空间有较大需求的操作会导致栈溢出。</p>
<h4 id="1-同步消除"><a href="#1-同步消除" class="headerlink" title="1. 同步消除"></a>1. 同步消除</h4><p>逃逸分析可以判断某个对象是否始终只被一个线程访问，如果只被一个线程访问，那么对该对象的同步操作就可以转化成没有同步保护的操作，可以提高并发和性能。</p>
<h4 id="2-标量替换"><a href="#2-标量替换" class="headerlink" title="2. 标量替换"></a>2. 标量替换</h4><p>JVM 中的原始数据类型（基础类型和引用类型等）都不能在进一步分解，它们成为标量。如果一个对象可以继续分解，那么它就成为聚合量，Java 中的<strong>对象</strong>是典型的聚合量。如果逃逸分析证明一个对象不会被外部访问，且该对象可分解，那么程序执行时，就可以直接创建若干个被该方法使用到的成员变量来代替。拆分后的变量可以被单独分享和优化，可以各自分别在栈帧和寄存器上分配空间，原本的对象就无需整体分配空间了。</p>
<h4 id="3-锁消除"><a href="#3-锁消除" class="headerlink" title="3. 锁消除"></a>3. 锁消除</h4><pre class=" language-Java"><code class="language-Java"> public static void alloc()&#123;
     byte[] a = new byte[50];
     synchronized(a)&#123;
         b[0]=1;
     &#125;
 &#125;

 public static void main(String [] args)&#123;
    long b = System.curentTimeMillis();
    for(int i =0;i<10000;i++)&#123;
        alloc();
    &#125;
    long c = System.currentTimeMillis();
    System.out.println(c-b);
 &#125;</code></pre>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h3><p>JVM 为对象分配的空间，并不一定都在堆上，有可能分配在栈上，也可能两者都不在。具体情况由 JVM 自行优化。但逃逸分析存在时间消耗，所以性能提升并不明显。</p>
]]></content>
      <tags>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解 JVM 垃圾回收算法 - CMS</title>
    <url>/blogs/jvm-gc-cms.html</url>
    <content><![CDATA[<h1 id="深入理解-JVM-垃圾回收算法-CMS"><a href="#深入理解-JVM-垃圾回收算法-CMS" class="headerlink" title="深入理解 JVM 垃圾回收算法 - CMS"></a>深入理解 JVM 垃圾回收算法 - CMS</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢 ~~</p>
<h4 id="CMS-触发回收的机制"><a href="#CMS-触发回收的机制" class="headerlink" title="CMS 触发回收的机制"></a>CMS 触发回收的机制</h4><ol>
<li><p>老年代的利用率达到阀值，默认是 92%。</p>
</li>
<li><p>永久代的使用率达到阀值，默认是 92 %</p>
</li>
<li><p>晋升担保失败</p>
<blockquote>
<p>老年代会确认是否可以容纳新生代的全部对象以及老年代现有的对象，如果不可以的话，就会触发 GC。</p>
</blockquote>
</li>
<li><p>如果没有设置 UseCMSInitiatingOccupancyOnly，虚拟机会根据收集的数据决定是否触发（线上环境建议带上这个参数，不然会加大问题排查的难度）</p>
</li>
</ol>
<h5 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h5><ul>
<li><a href="https://www.cnblogs.com/aspirant/p/8663911.html">图解 CMS 垃圾回收机制原理，-阿里面试题</a></li>
</ul>
]]></content>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解垃圾回收器 G1</title>
    <url>/blogs/jvm-gc-g1.html</url>
    <content><![CDATA[<h1 id="深入理解垃圾回收器-G1"><a href="#深入理解垃圾回收器-G1" class="headerlink" title="深入理解垃圾回收器 G1"></a>深入理解垃圾回收器 G1</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢 ~~</p>
<p>G1 - 新生代回收</p>
<p>G1 新生代回收，是并行回收，一旦发生新生代回收，就会导致整个新生代被回收。即 YGC（Young GC），G1 与其他回收器不同的是</p>
<ul>
<li><p>G1会根据预测时间动态地改变新生代的大小 </p>
</li>
<li><p>G1老生代的垃圾回收方式与其他JVM垃圾回收器对老生代处理有着极大的不同。G1老生代的回收不会为了释放老生代的空间而对整个老生代进行回收。相反，在任意时刻只有一部分老生代分区会被回收，并且这部分老生代分区将在下一次增量回收时与所有的新生代分区一起被回收，这就是我们所说的混合回收（Mixed GC）。在选择老生代分区时，优先考虑垃圾多的分区。</p>
</li>
</ul>
<h3 id="回收流程"><a href="#回收流程" class="headerlink" title="回收流程"></a>回收流程</h3><ol>
<li><p>初始标记子阶段、</p>
</li>
<li><p>并发标记子阶段、</p>
</li>
<li><p>再标记子阶段</p>
</li>
<li><p>清理子阶段。</p>
</li>
</ol>
<h5 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h5><ul>
<li><a href="https://www.cnblogs.com/Benjious/p/10304799.html">JVM(四) G1 收集器工作原理介绍 </a></li>
</ul>
]]></content>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>jvm-gc-oop</title>
    <url>/blogs/jvm-gc-oop.html</url>
    <content><![CDATA[<h1 id="JVM-OOP"><a href="#JVM-OOP" class="headerlink" title="JVM  OOP"></a>JVM  OOP</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢 ~~</p>
<h5 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h5><ul>
<li><a href="https://www.iteye.com/blog/dsxwjhf-2201685">JVM 之 OopMap 和 RememberedSet</a></li>
</ul>
]]></content>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM-垃圾回收-三色标记算法</title>
    <url>/blogs/jvm-gc-san-se-biao-ji.html</url>
    <content><![CDATA[<h1 id="JVM-垃圾回收-三色标记算法"><a href="#JVM-垃圾回收-三色标记算法" class="headerlink" title="JVM-垃圾回收-三色标记算法"></a>JVM-垃圾回收-三色标记算法</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢 ~~</p>
<p>JVM 中使用该标记算法的有 CMS  G1</p>
<p>但是 对存在 多标 漏标（浮动垃圾）</p>
<p>解决方案：CMS 增加引用环节<br>        G1 使用 SATB</p>
<h5 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h5><ul>
<li><a href="https://juejin.cn/post/6862668022025453576">JVM-垃圾回收-三色标记算法</a></li>
</ul>
]]></content>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>jvm-gc-shenandoah</title>
    <url>/blogs/jvm-gc-shenandoah.html</url>
    <content><![CDATA[<h1 id="jvm-gc-shenandoah"><a href="#jvm-gc-shenandoah" class="headerlink" title="jvm-gc-shenandoah"></a>jvm-gc-shenandoah</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢 ~~</p>
<h5 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h5><ul>
<li><a href=""></a></li>
</ul>
]]></content>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>jvm-gc-zgc</title>
    <url>/blogs/jvm-gc-zgc.html</url>
    <content><![CDATA[<h1 id="Java-虚拟机-ZGC-简介"><a href="#Java-虚拟机-ZGC-简介" class="headerlink" title="Java 虚拟机 ZGC 简介"></a>Java 虚拟机 ZGC 简介</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢~~</p>
<p>查看 Jdk 使用的 GC</p>
<pre class=" language-java"><code class="language-java">java <span class="token operator">-</span>XX<span class="token operator">:</span><span class="token operator">+</span>PrintCommandLineFlags <span class="token operator">-</span>version</code></pre>
<p>ZGC 特点：</p>
<ol>
<li>暂停时间不超过 10</li>
</ol>
<p>ZGC  新增了两项技术</p>
<ul>
<li>着色指针</li>
<li>读屏障</li>
</ul>
]]></content>
      <tags>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解 JVM GC roots</title>
    <url>/blogs/jvm-gc-roots.html</url>
    <content><![CDATA[<h1 id="深入理解-JVM-GC-roots"><a href="#深入理解-JVM-GC-roots" class="headerlink" title="深入理解 JVM GC roots"></a>深入理解 JVM GC roots</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢 ~~</p>
<h3 id="安全点"><a href="#安全点" class="headerlink" title="安全点"></a>安全点</h3><p>安全点是指一些特殊位置（一段禁止访问的内存，代码访问到此处时，会促使当前线程进入阻塞），当代码执行到特殊位置时，此时的虚拟机状态是安全可控的。<br>虚拟机可以通过 VM 线程找到活跃对象（通过一开始创建的 oopMap），检查并更新 Mutator。</p>
<h4 id="进入安全点方式"><a href="#进入安全点方式" class="headerlink" title="进入安全点方式"></a>进入安全点方式</h4><ol>
<li><p>G1 并发线程进行安全点</p>
</li>
<li><p>解释线程进入安全点</p>
</li>
<li><p>编译线程进入安全点</p>
</li>
<li><p>正在执行本地代码的线程进入安全点</p>
</li>
</ol>
<h5 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h5><ul>
<li><p><a href="https://juejin.cn/post/6952376918855385125">JVM技术之旅-GCRoots定位及Mutator线程中断</a></p>
</li>
<li><p><a href="https://www.jianshu.com/p/e68a422c93cb">【jvm学习笔记八】G1-线程中的安全点</a></p>
</li>
<li><p><a href="https://segmentfault.com/a/1190000039300766">SATB的一些理解</a></p>
</li>
</ul>
]]></content>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM 简介</title>
    <url>/blogs/jvm-introduce.html</url>
    <content><![CDATA[<h1 id="JVM-简介"><a href="#JVM-简介" class="headerlink" title="JVM 简介"></a>JVM 简介</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢 ~~</p>
<h4 id="方法区回收规则"><a href="#方法区回收规则" class="headerlink" title="方法区回收规则"></a>方法区回收规则</h4><p>方法区存储内容是否需要回收的判断可就不一样咯。方法区主要回收的内容有：废弃常量和无用的类。对于废弃常量也可通过引用的可达性来判断，但是对于无用的类则需要同时满足下面 3 个条件：</p>
<ul>
<li><p>该类所有的实例都已经被回收，也就是 <code>Java</code> 堆中不存在该类的任何实例；</p>
</li>
<li><p>加载该类的 <code>ClassLoader</code> 已经被回收；</p>
</li>
<li><p>该类对应的 <code>java.lang.Class</code> 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</p>
</li>
</ul>
<h5 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h5><ul>
<li><p><a href="https://blog.csdn.net/qq_41701956/article/details/81664921">Java虚拟机（JVM）你只要看这一篇就够了！</a></p>
</li>
<li><p><a href="https://www.cnblogs.com/aspirant/p/8662690.html">JVM的垃圾回收机制 总结(垃圾收集、回收算法、垃圾回收器)</a></p>
</li>
</ul>
]]></content>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解 JVM 内存结构</title>
    <url>/blogs/jvm-memory-instruct.html</url>
    <content><![CDATA[<h1 id="深入理解-JVM-内存结构"><a href="#深入理解-JVM-内存结构" class="headerlink" title="深入理解 JVM 内存结构"></a>深入理解 JVM 内存结构</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢 ~~</p>
<h5 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h5><ul>
<li><a href="https://zhuanlan.zhihu.com/p/68145978">JVM系列（1）java8的内存结构</a></li>
</ul>
]]></content>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解 jvm - JIT 即时编译器</title>
    <url>/blogs/jvm-jit.html</url>
    <content><![CDATA[<h1 id="深入理解-jvm-JIT-即时编译器"><a href="#深入理解-jvm-JIT-即时编译器" class="headerlink" title="深入理解 jvm - JIT 即时编译器"></a>深入理解 jvm - JIT 即时编译器</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢~~</p>
<p>JVM 及时编译 JIT</p>
<h2 id="C1"><a href="#C1" class="headerlink" title="C1"></a>C1</h2><h2 id="C2"><a href="#C2" class="headerlink" title="C2"></a>C2</h2><h2 id="分层编译"><a href="#分层编译" class="headerlink" title="分层编译"></a>分层编译</h2><ol>
<li><p>第 0 层：程序解释执行，默认开启性能监控功能（Profiling），如果不开启，可触发第二层编译；</p>
</li>
<li><p>第 1 层：可称为 C1 编译，将字节码编译为本地代码，进行简单、可靠的优化，不开启 Profiling；</p>
</li>
<li><p>第 2 层：也称为 C1 编译，开启 Profiling，仅执行带方法调用次数和循环回边执行次数 profiling 的 C1 编译；</p>
</li>
<li><p>第 3 层：也称为 C1 编译，执行所有带 Profiling 的 C1 编译；</p>
</li>
<li><p>第 4 层：可称为 C2 编译，也是将字节码编译为本地代码，但是会启用一些编译耗时较长的优化，甚至会根据性能监控信息进行一些不可靠的激进优化。</p>
</li>
</ol>
]]></content>
      <tags>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解 JVM 内存模型</title>
    <url>/blogs/jvm-memory-model.html</url>
    <content><![CDATA[<h1 id="深入理解-JVM-内存模型"><a href="#深入理解-JVM-内存模型" class="headerlink" title="深入理解 JVM 内存模型"></a>深入理解 JVM 内存模型</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢 ~~</p>
<h5 id="一-定义"><a href="#一-定义" class="headerlink" title="一. 定义"></a>一. 定义</h5><p><code>JMM</code> 即  Java 内存模型，并不是实质上存在的，它是一个约定或者规范。对数据的处理，必须从主内存加载至线程工作内存中。<br>处理完毕后，需要将工作内存中的数据刷回至主内存。</p>
<p>JMM 处理的是共享数据的 原子性，有序性，可见性。</p>
<h4 id="工作内存"><a href="#工作内存" class="headerlink" title="工作内存"></a>工作内存</h4><p>对于一个实例对象中的成员方法而言，如果方法中包括本地变量是基本数据类型（boolean、type、short、char、int、long、float、double），将直接存储在工作内存的帧栈中，而对象实例将存储在主内存（共享数据区域，堆）中。但对于实例对象的成员变量，不管它是基本数据类型或者包装类型（Integer、Double等）还是引用类型，都会被存储到堆区。至于 static 变量以及类本身相关信息将会存储在主内存中。</p>
<p>数据同步的原子操作</p>
<p>lock（锁定）：作用于主内存的变量，把一个变量标记为一个线程独占状态；<br>unlock（解锁）：作用于主内存的变量，把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定；<br>read（读取）：作用于主内存的变量，把一个变量值从主内存传输到线程的工作内存中，以后随后的load工作使用；<br>load（载入）：作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量；<br>use（使用）：作用于工作内存的变量，把工作内存中的一个变量值传递给执行引擎；<br>assign（赋值）：作用于工作内存的变量，它把一个从执行引擎接收到的值赋给工作内存的变量；<br>store（存储）：作用于工作内存的变量，把工作内存中的一个变量的值传送到主内存中，以便随后的write的操作；<br>wirte（写入）：作用于工作内存的变量，它把store操作从工作内存中的一个变量值传送到主内存的变量中。<br>如果要把一个变量从主内存中复制到工作内存中，就需要按顺序地执行 read 和 load 操作；<br>如果把变量从工作内存中同步到主内存中，就需要按顺序地执行 store 和 write 操作。</p>
<p>同步规则分析</p>
<p>同步规则分析</p>
<p>不允许一个线程无原因地（没有发生任何 assign 操作）把数据从工作内存同步回主内存中；<br>一个新的变量只能在主内存中诞生，不允许在工作内存中直接使用一个未被初始化（load 或者 assign）的变量。即就是对一个变量实施 use 和 store 操作之前，必须先自行 assign 和 load 操作；<br>一个变量在同一时刻只允许一条线程对其进行 lock 操作，但 lock 操作可不被同一线程重复执行多次，多次执行 lock 后，只有执行相同次数 unlock 操作，变量才会被解锁。lock 和 unlock 必须成对出现；<br>如果对一个变量执行 lock 操作，将会清空工作内存中此变量的值，在执行引擎使用变量之前需要重新执行 load 或 assign 操作初始化变量的值；<br>如果一个变量事先没有被 lock 操作锁定，则不允许对它执行 unlock 操作；也不允许去 unlock 一个被其他线程锁定的变量；<br>对一个变量执行 unlock 操作之前，必须先把此变量同步到主内存中（执行store 和 write 操作）。</p>
<p>原子性</p>
<p>可见性</p>
<p>有序性</p>
<p>缓存一致性问题</p>
<p>指令重排序问题</p>
<p>为了保证 CPU 运算单元的利用率，CPU 会对指令进行乱序优化。处理器会将乱序执行的指令在计算后进行重组。保证该执行结果和顺序执行一直。如果 CUP 中存在一个指令的计算依赖另一个指令的计算，那么</p>
<h5 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h5><ul>
<li><p><a href="https://segmentfault.com/a/1190000037799975">一文读懂Java内存模型(JMM)及volatile关键字</a></p>
</li>
<li><p><a href="https://zhuanlan.zhihu.com/p/29881777">Java内存模型（JMM）总结</a></p>
</li>
</ul>
]]></content>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>jvm-parameter-command</title>
    <url>/blogs/jvm-parameter-command.html</url>
    <content><![CDATA[<h2 id="JVM-Command"><a href="#JVM-Command" class="headerlink" title="JVM-Command"></a>JVM-Command</h2><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢~~</p>
<h3 id="内存相关"><a href="#内存相关" class="headerlink" title="内存相关"></a><strong>内存相关</strong></h3><ol>
<li>表示设置 JVM 启动内存的最小值为 20M，必须以 M 为单位：</li>
</ol>
<pre class=" language-Java"><code class="language-Java">-Xms20M</code></pre>
<ol start="2">
<li>表示设置 JVM 启动内存的最大值为 20M，必须以 M 为单位。将 -Xmx 和 -Xms 设置为一样可以避免 JVM 内存自动扩展。打的项目 -Xmx 和 -Xms 一般设置为 10G 20G 或者更大。</li>
</ol>
<pre class=" language-Java"><code class="language-Java">-Xmx20M</code></pre>
<ol start="3">
<li>表示输出虚拟机中 GC 的详细情况：</li>
</ol>
<pre class=" language-Java"><code class="language-Java">-verbose:gc</code></pre>
<ol start="4">
<li>表示可以设置虚拟机栈的大小为 128 K</li>
</ol>
<pre class=" language-java"><code class="language-java"><span class="token operator">-</span>Xss128k</code></pre>
<ol start="5">
<li>表示设置本地方法栈的大小为 128 k。但 HotSpot 并不区分虚拟机栈和本地方方法栈，因此对于 HotSpot 来说这个参数是无效的：</li>
</ol>
<pre class=" language-Java"><code class="language-Java">-Xoss128k</code></pre>
<ol start="6">
<li><p>表示 JVM 初始分配的永久代的最大容量，必须以 M 为单位，大部分情况下这个参数默认为 64 M。</p>
<p>```Java</p>
</li>
</ol>
<p>-XX:PermSize=10M</p>
<pre><code>
7. 表示 JVM 允许分配的永久代的最大容量，必须以 M 为单位，大部分情况下这个参数默认为 64 M

```Java
-XX:MaxPermSize=10M</code></pre>
<h3 id="垃圾回收管理"><a href="#垃圾回收管理" class="headerlink" title="垃圾回收管理"></a>垃圾回收管理</h3><ol>
<li><p>表示关闭 JVM 对类的垃圾回收</p>
<p>```Java</p>
</li>
</ol>
<p>-Xnoclassgc</p>
<pre><code>
2. 表示可以看到每次 GC 前后堆内存布局

```Java
-XX:+PrintHeapAtGC</code></pre>
<ol start="3">
<li>在控制台打印 GC 信息</li>
</ol>
<pre class=" language-Java"><code class="language-Java">-XX:+PrintGC</code></pre>
<ol start="4">
<li>表示在控制台打印 GC 的具体细节</li>
</ol>
<pre class=" language-Java"><code class="language-Java">-XX:PrintGCDetails</code></pre>
<ol start="5">
<li><p>表示让 JVM 使用 G1 垃圾收集器</p>
<p>```Java</p>
</li>
</ol>
<p>-XX:+UseG1GC</p>
<pre><code>
6. 表示年轻代的大小

``` Java
-Xmn</code></pre>
<ol start="7">
<li>设置年轻代（包括 Eden 和两个 Survivor 区）与年老代的比值（除去持久代）。设置为 4，则年轻代与年老代所占比值为 1：4，年轻代占整个堆栈的 1/5</li>
</ol>
<pre class=" language-Java"><code class="language-Java">-XX:NewRatio=4</code></pre>
<ol start="8">
<li>设置年轻代中 Eden 区与 Survivor 区的大小比值。设置为 4，则两个 Survivor 区与一个 Eden 区的比值为 2:4，则一个 Survivor 区占整个年轻代的1/6</li>
</ol>
<pre class=" language-Java"><code class="language-Java">-XX:SurvivorRatio=4</code></pre>
]]></content>
      <tags>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title>jvm-reference-types</title>
    <url>/blogs/jvm-reference-types.html</url>
    <content><![CDATA[<h1 id="JVM-四种引用类型"><a href="#JVM-四种引用类型" class="headerlink" title="JVM 四种引用类型"></a>JVM 四种引用类型</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢~~</p>
<p>本文实践代码可以参阅 <a href="https://github.com/Starriers/CodeCombat">CodeCombat</a> 的 <a href="https://github.com/Starriers/CodeCombat/tree/master/JVM/src/main/java/org/starrier/codecombat">JVM</a>。</p>
<h3 id="1-强引用"><a href="#1-强引用" class="headerlink" title="1. 强引用"></a>1. 强引用</h3><p>强引用是程序中一般使用的引用类型，强引用的对象是可触及的，不会被回收。相对的，弱引用，软引用，虚引用的对象是可触及的，在一定情况下，是可以被回收的。</p>
<pre class=" language-Java"><code class="language-Java">StringBuffer str = new StringBuffer("Hello World");</code></pre>
<p>以上代码中，局部变量 str 将被分配在栈上，而对象 StringBuffer 实例对象将被分配在堆上。局部变量 str 指向 StringBuffer 实例所在的堆空间，通过 str 可以操作该实例，那么 str 就是 StringBuffer 实例的强引用。</p>
<p>如果此时再进行</p>
<pre class=" language-java"><code class="language-java">StringBuffer str1 <span class="token operator">=</span> str<span class="token punctuation">;</span></code></pre>
<p>那么 str 所指向的对象也将被 str1 所指向，同时在局部变量表上会分配空间存放 str1 变量。此时，StringBuffer 实例就有两个引用。对引用进行 “==” 操作时，表示比较对象所指向的堆空间是否相同，不表示量操作数所指向的对象是否想等。</p>
<p><strong>特点</strong>：</p>
<ol>
<li>强引用可以直接访问目标对象</li>
<li>强引用所指向的对象在任何时候都不会被系统回收，虚拟机宁愿抛出 OOM 异常，也不会回收强引用所指向的对象。</li>
<li>强引用可能导致内存泄露。</li>
</ol>
<h3 id="2-软引用"><a href="#2-软引用" class="headerlink" title="2. 软引用"></a>2. 软引用</h3><p>如果一个对象只具有软引用，在内存足够的情况下，垃圾回收区不会回收它，如果内存空间不足，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可用来实现内敏感的告诉缓存。</p>
<p>软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收，JVM 就会把这个软引用加入到与之关联的引用队列中。</p>
<h3 id="3-弱引用"><a href="#3-弱引用" class="headerlink" title="3. 弱引用"></a>3. 弱引用</h3><p>弱引用与软引用的区别：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描所管辖的内存区域时，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程，因此不一定会很快发现那些只具有弱引用的对象。</p>
<p>弱引用对象可以和一个引用队列一起使用，如果弱引用所引用的对象被垃圾回收，JVM 就会把这个弱引用加入到与之关联的引用队列中。</p>
<h3 id="4-虚引用"><a href="#4-虚引用" class="headerlink" title="4. 虚引用"></a>4. 虚引用</h3><p>如果一个对象仅持有虚引用，那么它和没有任何引用一样，在任何时候都可能被垃圾回收。虚引用主要用来跟踪对象被垃圾回收的活动。虚引用与弱引用和软引用的区别在于：虚引用必须和引用队列一起使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象后，将这个虚引用加入引用队列，以通知应用程序对象的回收情况。</p>
<p><strong>注意</strong></p>
<p>软引用和弱引用都适合用来保存那些可有可无的缓存数据。如果这么做，当系统内存不足时，这些缓存就会被回收，不会导致内存溢出。而当内存资源充足时，这些缓存数据有可以存在相当长的时间，从而起到加速系统的作用。</p>
]]></content>
      <tags>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM - SATB 算法</title>
    <url>/blogs/jvm-satb.html</url>
    <content><![CDATA[<h1 id="JVM-SATB-算法"><a href="#JVM-SATB-算法" class="headerlink" title="JVM - SATB 算法"></a>JVM - SATB 算法</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢 ~~</p>
<p>增量式垃圾回收</p>
<p>三色标记算法</p>
<h5 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h5><ul>
<li><a href=""></a></li>
</ul>
]]></content>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>jvm-tools-jconsole</title>
    <url>/blogs/jvm-tools-jconsole.html</url>
    <content><![CDATA[<h1 id="JVM-jconsole"><a href="#JVM-jconsole" class="headerlink" title="JVM - jconsole"></a>JVM - jconsole</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢 ~~</p>
<p>是一个用java写的GUI程序，用来监控VM，并可监控远程的VM</p>
<p>服务器端配置，远程调控是如下配置：在服务端启动时添加如下参数：</p>
<p>-Dcom.sun.management.jmxremote.port=22801</p>
<p>-Dcom.sun.management.jmxremote.pwd.file=jmxremote.pwd</p>
<p>-Dcom.sun.management.jmxremote.ssl=false</p>
<p>-Dcom.sun.management.jmxremote.authenticate=false</p>
<p>在相同目录下创建文件jmxremote.pwd，并填写用户名和密码</p>
]]></content>
      <tags>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title>Java JVM  tools 简介</title>
    <url>/blogs/jvm-tools-introduce.html</url>
    <content><![CDATA[<h1 id="Java-JVM-tools-简介"><a href="#Java-JVM-tools-简介" class="headerlink" title="Java JVM  tools 简介"></a>Java JVM  tools 简介</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢~~</p>
<h2 id="Java-JVM-工具"><a href="#Java-JVM-工具" class="headerlink" title="Java JVM 工具"></a>Java JVM 工具</h2><h2 id="1-jps"><a href="#1-jps" class="headerlink" title="1. jps"></a>1. jps</h2><h2 id="2-jstack"><a href="#2-jstack" class="headerlink" title="2. jstack"></a>2. jstack</h2><h2 id="3-jstat"><a href="#3-jstat" class="headerlink" title="3. jstat"></a>3. jstat</h2><h2 id="4-jmap"><a href="#4-jmap" class="headerlink" title="4. jmap"></a>4. jmap</h2><h2 id="5-jhat"><a href="#5-jhat" class="headerlink" title="5. jhat"></a>5. jhat</h2><h2 id="6-jvisualvm"><a href="#6-jvisualvm" class="headerlink" title="6. jvisualvm"></a>6. jvisualvm</h2><h2 id="7-jconsole"><a href="#7-jconsole" class="headerlink" title="7. jconsole"></a>7. jconsole</h2><h2 id="8-jconsole"><a href="#8-jconsole" class="headerlink" title="8. jconsole"></a>8. jconsole</h2><h2 id="9-Memory-Analyzer"><a href="#9-Memory-Analyzer" class="headerlink" title="9. Memory Analyzer"></a>9. Memory Analyzer</h2><h2 id="系统相关工具"><a href="#系统相关工具" class="headerlink" title="系统相关工具"></a>系统相关工具</h2><h3 id="1-top"><a href="#1-top" class="headerlink" title="1. top"></a>1. top</h3><blockquote>
<p>查看系统负载，以及系统资源情况</p>
</blockquote>
<h3 id="2-ps"><a href="#2-ps" class="headerlink" title="2. ps"></a>2. ps</h3><blockquote>
<p>查看系统进程命令</p>
</blockquote>
<h3 id="3-netstat"><a href="#3-netstat" class="headerlink" title="3. netstat"></a>3. netstat</h3><blockquote>
<p>网络端口统计</p>
</blockquote>
<h3 id="4-df-du"><a href="#4-df-du" class="headerlink" title="4. df,du"></a>4. df,du</h3><blockquote>
<p>磁盘文件查看命令，</p>
</blockquote>
<h2 id="其他工具"><a href="#其他工具" class="headerlink" title="其他工具"></a>其他工具</h2><h3 id="1-grep"><a href="#1-grep" class="headerlink" title="1. grep"></a>1. grep</h3><h3 id="2-find"><a href="#2-find" class="headerlink" title="2. find"></a>2. find</h3><h3 id="3-tail"><a href="#3-tail" class="headerlink" title="3. tail"></a>3. tail</h3><h3 id="4-less-more-cat"><a href="#4-less-more-cat" class="headerlink" title="4. less,more,cat"></a>4. less,more,cat</h3><h3 id="5-awk"><a href="#5-awk" class="headerlink" title="5. awk"></a>5. awk</h3><h3 id="6-sed"><a href="#6-sed" class="headerlink" title="6. sed"></a>6. sed</h3><blockquote>
<p>文本替换工具</p>
</blockquote>
]]></content>
      <tags>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title>jvm-tools-jmap</title>
    <url>/blogs/jvm-tools-jmap.html</url>
    <content><![CDATA[<h1 id="Java-VM-工具-JStack"><a href="#Java-VM-工具-JStack" class="headerlink" title="Java VM 工具 - JStack"></a>Java VM 工具 - JStack</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢 ~~</p>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>显示java进程内存使用的相关信</p>
<h4 id="1-jmap-pid"><a href="#1-jmap-pid" class="headerlink" title="1. jmap pid"></a>1. jmap pid</h4><p>打印内存使用的摘要信息</p>
<h4 id="2-jmap-–heap-pid"><a href="#2-jmap-–heap-pid" class="headerlink" title="2. jmap –heap pid"></a>2. jmap –heap pid</h4><p>java heap信息</p>
<h4 id="3-jmap-histo-live"><a href="#3-jmap-histo-live" class="headerlink" title="3. jmap -histo:live"></a>3. jmap -histo:live</h4><p>统计对象count ，live表示在使用</p>
<h4 id="4-jmap-histopid-gt-mem-txt"><a href="#4-jmap-histopid-gt-mem-txt" class="headerlink" title="4. jmap -histopid &gt;mem.txt"></a>4. jmap -histopid &gt;mem.txt</h4><p>打印比较简单的各个有多少个对象占了多少内存的信息，一般重定向的文件</p>
<h4 id="5-jmap-dump-format-b-file-mem-dat-pid"><a href="#5-jmap-dump-format-b-file-mem-dat-pid" class="headerlink" title="5. jmap -dump:format=b,file= mem.dat pid"></a>5. jmap -dump:format=b,file= mem.dat pid</h4><p>将内存使用的详细情况输出到mem.dat 文件</p>
]]></content>
      <tags>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title>jvm-tools-jstack</title>
    <url>/blogs/jvm-tools-jstack.html</url>
    <content><![CDATA[<h1 id="Java-VM-工具-JStack"><a href="#Java-VM-工具-JStack" class="headerlink" title="Java VM 工具 - JStack"></a>Java VM 工具 - JStack</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢 ~~</p>
<p>jstack – 如果java程序崩溃生成core文件，jstack工具可以用来获得core文件的java stack和native stack的信息，从而可以轻松地知道java程序是如何崩溃和在程序何处发生问题。</p>
<p>jstack工具还可以附属到正在运行的java程序中，看到当时运行的java程序的java stack和native stack的信息</p>
<p>jstack [-l] <pid>        连接正在运行的进程</p>
<p>jstack -F [-m] [-l] <pid> 连接挂起的进程</p>
<p>jstack [-m] [-l] <executable> <core> 连接core文件</p>
<p>jstack [-m] [-l] [server_id@]<remote server IP or hostname> 连接远程服务器</p>
]]></content>
      <tags>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title>jvm-tools-jstat</title>
    <url>/blogs/jvm-tools-jstat.html</url>
    <content><![CDATA[<h1 id="jvm-tools-jstat"><a href="#jvm-tools-jstat" class="headerlink" title="jvm-tools-jstat"></a>jvm-tools-jstat</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢 ~~</p>
<h3 id="介绍："><a href="#介绍：" class="headerlink" title="介绍："></a>介绍：</h3><h5 id="一个极强的监视VM内存工具。可以用来监视VM内存内的各种堆和非堆的大小及其内存使用"><a href="#一个极强的监视VM内存工具。可以用来监视VM内存内的各种堆和非堆的大小及其内存使用" class="headerlink" title="一个极强的监视VM内存工具。可以用来监视VM内存内的各种堆和非堆的大小及其内存使用"></a>一个极强的监视VM内存工具。可以用来监视VM内存内的各种堆和非堆的大小及其内存使用</h5><h5 id="1-jstat-class-pid"><a href="#1-jstat-class-pid" class="headerlink" title="1. jstat -class pid:"></a>1. jstat -class pid:</h5><p>显示加载class的数量，及所占空间等信息。</p>
<h5 id="2-jstat-compiler-pid"><a href="#2-jstat-compiler-pid" class="headerlink" title="2. jstat -compiler pid:"></a>2. jstat -compiler pid:</h5><p>显示VM实时编译的数量等信息。</p>
<h5 id="3-jstat-gc-pid"><a href="#3-jstat-gc-pid" class="headerlink" title="3. jstat -gc pid:"></a>3. jstat -gc pid:</h5><p>可以显示gc的信息，查看gc的次数，及时间。其中最后五项，分别是young gc的次数，young gc的时间，full gc的次数，full gc的时间，gc的总时间。</p>
<h5 id="4-jstat-gccapacity"><a href="#4-jstat-gccapacity" class="headerlink" title="4. jstat -gccapacity:"></a>4. jstat -gccapacity:</h5><p>可以显示，VM内存中三代（young,old,perm）对象的使用和占用大小，如：PGCMN显示的是最小perm的内存使用量，PGCMX显示的是perm的内存最大使用量，PGC是当前新生成的perm内存占用量，PC是但前perm内存占用量。其他的可以根据这个类推， OC是old内纯的占用量。</p>
<h5 id="5-jstat-gcnew-pid"><a href="#5-jstat-gcnew-pid" class="headerlink" title="5. jstat -gcnew pid:"></a>5. jstat -gcnew pid:</h5><p>new对象的信息。</p>
<h5 id="6-jstat-gcnewcapacity-pid-new"><a href="#6-jstat-gcnewcapacity-pid-new" class="headerlink" title="6. jstat -gcnewcapacity pid:new"></a>6. jstat -gcnewcapacity pid:new</h5><p>对象的信息及其占用量。</p>
<h5 id="7-jstat-gcold-pid-old"><a href="#7-jstat-gcold-pid-old" class="headerlink" title="7. jstat -gcold pid:old"></a>7. jstat -gcold pid:old</h5><p>对象的信息。</p>
<h5 id="8-jstat-gcoldcapacity-pid-old"><a href="#8-jstat-gcoldcapacity-pid-old" class="headerlink" title="8. jstat -gcoldcapacity pid:old"></a>8. jstat -gcoldcapacity pid:old</h5><p>对象的信息及其占用量。</p>
<h5 id="9-jstat-gcpermcapacity-pid-perm"><a href="#9-jstat-gcpermcapacity-pid-perm" class="headerlink" title="9. jstat -gcpermcapacity pid: perm"></a>9. jstat -gcpermcapacity pid: perm</h5><p>对象的信息及其占用量。</p>
<h5 id="10-jstat-printcompilation-pid"><a href="#10-jstat-printcompilation-pid" class="headerlink" title="10. jstat -printcompilation pid:"></a>10. jstat -printcompilation pid:</h5><p>当前VM执行的信息。</p>
]]></content>
      <tags>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title>k8s-components</title>
    <url>/blogs/k8s-components.html</url>
    <content><![CDATA[<h1 id="Kubernents-components-简介"><a href="#Kubernents-components-简介" class="headerlink" title="Kubernents - components 简介"></a>Kubernents - components 简介</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢~~</p>
<p>K8s 集群组件</p>
<table>
<thead>
<tr>
<th>组件名称</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>etcd</td>
<td>一个高可用的 KV 存储和服务发现系统</td>
</tr>
<tr>
<td>flannel</td>
<td>实现跨主机的容器网络通信</td>
</tr>
<tr>
<td>kube-apiServer</td>
<td>提供 k8s 集群的 API 调用</td>
</tr>
<tr>
<td>kube-controller-manager</td>
<td>确保集群服务</td>
</tr>
<tr>
<td>kubelet</td>
<td>调度容器，分配到 Node</td>
</tr>
<tr>
<td>kube-proxy</td>
<td>提供网络代理服务</td>
</tr>
</tbody></table>
]]></content>
      <tags>
        <tag>DevOps</tag>
      </tags>
  </entry>
  <entry>
    <title>linux-cat</title>
    <url>/blogs/linux-cat.html</url>
    <content><![CDATA[<h2 id="Linux-cat"><a href="#Linux-cat" class="headerlink" title="Linux cat"></a>Linux cat</h2><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢~~</p>
<p>命令的用途是连接文件或标准输入并打印，这个命令常用来显示文件内容，或者将几个文件连接起来显示，或者从标准输入读取内容并显示，它常与重定向符号配合使用。</p>
]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>数据写入磁盘过程</title>
    <url>/blogs/linux-data-write.html</url>
    <content><![CDATA[<h1 id="数据写入磁盘过程"><a href="#数据写入磁盘过程" class="headerlink" title="数据写入磁盘过程"></a>数据写入磁盘过程</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢 ~~</p>
<h5 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h5><ul>
<li><a href="https://blog.csdn.net/Toxic07/article/details/52169251">字符串从内存写入到磁盘的过程中到底发生了什么（一）</a></li>
</ul>
]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解 Linux 内存管理</title>
    <url>/blogs/linux-memory-manage-basic.html</url>
    <content><![CDATA[<h1 id="深入理解-Linux-内存管理"><a href="#深入理解-Linux-内存管理" class="headerlink" title="深入理解 Linux 内存管理"></a>深入理解 Linux 内存管理</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢 ~~</p>
<h5 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h5><ul>
<li><a href=""></a></li>
</ul>
]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 内存管理基础</title>
    <url>/blogs/linux-memory-manage.html</url>
    <content><![CDATA[<h1 id="Linux-内存管理基础"><a href="#Linux-内存管理基础" class="headerlink" title="Linux 内存管理基础"></a>Linux 内存管理基础</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢 ~~</p>
<h5 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h5><ul>
<li><a href="https://www.jianshu.com/p/6a22052b49c9">内存管理基础</a></li>
</ul>
]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>linux-menu</title>
    <url>/blogs/linux-menu.html</url>
    <content><![CDATA[<h1 id="Linux-目录简介"><a href="#Linux-目录简介" class="headerlink" title="Linux - 目录简介"></a>Linux - 目录简介</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢~~</p>
<table>
<thead>
<tr>
<th></th>
<th>可分享的（shareable）</th>
<th>不可分享的</th>
</tr>
</thead>
<tbody><tr>
<td>不可变的（static）</td>
<td>/usr(软件放置处)</td>
<td>/etc (配置文件)</td>
</tr>
<tr>
<td></td>
<td>/opt（第三方软件）</td>
<td>/boot（开机及内核文件）</td>
</tr>
</tbody></table>
<p>：根目录，一般根目录下只存放目录，不要存放件，/etc、/bin、/dev、/lib、/sbin应该和根目录放置在一个分区中</p>
<p>img</p>
<p>/bin: /usr/bin: 可执行二进制文件的目录，如常用的命令ls、tar、mv、cat等。</p>
<p>/boot：放置linux系统启动时用到的一些文件。/boot/vmlinuz 为 linux 的内核文件，以及 /boot/gurb。建议单独分区，分区大小100M即可</p>
<p>/dev：存放linux系统下的设备文件，访问该目录下某个文件，相当于访问某个设备，常用的是挂载光驱 mount /dev/cdrom /mnt。</p>
<p>/etc：系统配置文件存放的目录，不建议在此目录下存放可执行文件，重要的配置文件有 /etc/inittab、/etc/fstab、/etc/init.d、/etc/X11、/etc/sysconfig、/etc/xinetd.d修改配置文件之前记得备份。</p>
<p>注：/etc/X11 存放与 x windows 有关的设置。</p>
<p>/home：系统默认的用户家目录，新增用户账号时，用户的家目录都存放在此目录下，<del>表示当前用户的家目录，</del>edu 表示用户 edu 的家目录。建议单独分区，并设置较大的磁盘空间，方便用户存放数据</p>
<p>/lib: /usr/lib: /usr/local/lib：系统使用的函数库的目录，程序在执行过程中，需要调用一些额外的参数时需要函数库的协助，比较重要的目录为 /lib/modules。</p>
<p>/lost+fount：系统异常产生错误时，会将一些遗失的片段放置于此目录下，通常这个目录会自动出现在装置目录下。如加载硬盘于 /disk 中，此目录下就会自动产生目录 /disk/lost+found</p>
<p>/mnt: /media：光盘默认挂载点，通常光盘挂载于 /mnt/cdrom 下，也不一定，可以选择任意位置进行挂载。</p>
<p>/opt：给主机额外安装软件所摆放的目录。如：FC4使用的Fedora 社群开发软件，如果想要自行安装新的 KDE 桌面软件，可以将该软件安装在该目录下。以前的 Linux 系统中，习惯放置在 /usr/local 目录下</p>
<p>/proc：此目录的数据都在内存中，如系统核心，外部设备，网络状态，由于数据都存放于内存中，所以不占用磁盘空间，比较重要的目录有 /proc/cpuinfo、/proc/interrupts、/proc/dma、/proc/ioports、/proc/net/* 等。</p>
<p>/root：系统管理员root的家目录，系统第一个启动的分区为 /，所以最好将 /root和 /放置在一个分区下。</p>
<p>/sbin: /usr/sbin: /usr/local/sbin：放置系统管理员使用的可执行命令，如fdisk、shutdown、mount 等。与 /bin 不同的是，这几个目录是给系统管理员 root使用的命令，一般用户只能”查看”而不能设置和使用。</p>
<p>/tmp：一般用户或正在执行的程序临时存放文件的目录,任何人都可以访问,重要数据不可放置在此目录下</p>
<p>/srv：服务启动之后需要访问的数据目录，如 www 服务需要访问的网页数据存放在 /srv/www 内。</p>
<p>/usr：应用程序存放目录，/usr/bin 存放应用程序，/usr/share 存放共享数据，/usr/lib 存放不能直接运行的，却是许多程序运行所必需的一些函数库文件。/usr/local: 存放软件升级包。/usr/share/doc: 系统说明文件存放目录。/usr/share/man: 程序说明文件存放目录，使用 man ls 时会查询 /usr/share/man/man1/ls.1.gz 的内容建议单独分区，设置较大的磁盘空间</p>
<p>/var：放置系统执行过程中经常变化的文件，如随时更改的日志文件 /var/log，/var/log/message：所有的登录文件存放目录，/var/spool/mail：邮件存放的目录，/var/run:程序或服务启动后，其PID存放在该目录下。建议单独分区，设置较大的磁盘空间</p>
<p>一切皆文件<br>Linux 对数据文件(.mp3、.bmp)，程序文件(.c、.h、*.o)，设备文件（LCD、触摸屏、鼠标），网络文件( socket ) 等的管理都抽象为文件，使用统一的方式方法管理。</p>
<p>文件分类：</p>
<p>1）普通文件( 数据文件 )</p>
<p>普通文件是用于存放数据、程序等信息的文件，一般都长期地存放在外存储器（磁盘）中。普通文件又分为文本文件和二进制文件。</p>
<p>2）目录文件</p>
<p>目录文件是文件系统中一个目录所包含的目录项所组成的文件。</p>
<p>3）设备文件</p>
<p>设备文件是用于为操作系统与设备提供连接的一种文件。在Linux系统中将设备作为文件来处理，操作设备就像是操作普通文件一样。每一个设备对应一个设备文件，存放在 /dev 目录中。</p>
<p>5）链接文件</p>
<p>似于 windows 下的快捷方式，链接又可以分为软链接（符号链接）和硬链接。</p>
<p>6）管道文件</p>
<p>管道文件主要用于在进程间传递数据的一种特殊文件。</p>
<p>7）套接口文件</p>
<p>主要用于不同计算机间网络通信的一种特殊文件。</p>
<p>img</p>
]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>linux-mysql</title>
    <url>/blogs/linux-mysql.html</url>
    <content><![CDATA[<h1 id="Linux-环境下-MySQL-数据库操作"><a href="#Linux-环境下-MySQL-数据库操作" class="headerlink" title="Linux 环境下 MySQL 数据库操作"></a>Linux 环境下 MySQL 数据库操作</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢~~</p>
<p>导出数据库</p>
<p>scp</p>
<p><code>scp username@ip:mysql 路径/x.tar.gz ./</code></p>
<p>cd ~ </p>
<pre class=" language-sql"><code class="language-sql">mysqldump <span class="token operator">-</span>u databaseusername <span class="token operator">-</span>p databaseName <span class="token operator">></span> x<span class="token punctuation">.</span>sql</code></pre>
<p>scp  username@ip:path ./</p>
<p>Note: </p>
<ul>
<li>username 为服务器用户名</li>
<li>ip 为服务器公网 IP，存在 domain 时，可以使用 domain 替代</li>
<li>./ 可以修改，当前意义为，存储在当前目录下</li>
</ul>
<p>MySQL command import</p>
<pre class=" language-sql"><code class="language-sql">source path<span class="token operator">/</span>x<span class="token punctuation">.</span>sql</code></pre>
]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 下文件的打包与压缩</title>
    <url>/blogs/linux-package.html</url>
    <content><![CDATA[<h1 id="Linux-下文件的打包与压缩"><a href="#Linux-下文件的打包与压缩" class="headerlink" title="Linux 下文件的打包与压缩"></a>Linux 下文件的打包与压缩</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢~~</p>
<table>
<thead>
<tr>
<th>工具</th>
<th>文件扩展名</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>bzip2</td>
<td>.bz2</td>
<td>采用 Burrows-Wheeler 块排序文本压缩算法和霍夫曼编码</td>
</tr>
<tr>
<td>compress</td>
<td>.Z</td>
<td>原始的 Unix 文件压缩工具，逐渐消失中</td>
</tr>
<tr>
<td>gzip</td>
<td>.gz</td>
<td>GUN 压缩工具，用 Lempel-Ziv 编码</td>
</tr>
<tr>
<td>zip</td>
<td>.zip</td>
<td>Win 上的 PKZIP 工具的 unix 实现</td>
</tr>
</tbody></table>
<h2 id="bzip2"><a href="#bzip2" class="headerlink" title="bzip2"></a>bzip2</h2><ol>
<li>bzip2</li>
</ol>
<blockquote>
<ol>
<li>bzip2 用于压缩文件</li>
<li>bzcat 用来显示压缩文本文件内容</li>
<li>bunzip2 用来解压缩 .bz2 文件</li>
<li>bzip2recover 用来尝试恢复损坏的压缩文件</li>
</ol>
</blockquote>
<ol start="2">
<li>bzcat</li>
</ol>
<blockquote>
<p>用来显示压缩的文本文件内容</p>
</blockquote>
<ol start="3">
<li>bunzip2</li>
</ol>
<blockquote>
<p>用来解压缩 .bz2 文件</p>
</blockquote>
<h3 id="tar"><a href="#tar" class="headerlink" title="tar"></a>tar</h3><table>
<thead>
<tr>
<th>功能</th>
<th>全名</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>-A</td>
<td>–concatenate</td>
<td>将一个已有 tar 归档文件追加到另一个已有 tar 归档文件</td>
</tr>
<tr>
<td>-c</td>
<td>–create</td>
<td>创建一个新的 tar 归档文件</td>
</tr>
</tbody></table>
<h2 id="归档"><a href="#归档" class="headerlink" title="归档"></a>归档</h2><pre class=" language-linux"><code class="language-linux"> tar
      c  创建
      f  指定归档文件名称
      t  显示归档文件中的内容
      r  向归档文件中添加文件
      --get 取出单个文件
      --delete 删除单个文件
      x   取出归档文件中的所有内容
      -C  指定解档目录
      -z  gz 格式压缩
      -j  bz2 格式压缩
      -J  xz 格式压缩</code></pre>
<h2 id="压缩"><a href="#压缩" class="headerlink" title="压缩"></a>压缩</h2><ol>
<li>gz</li>
<li>gzip etc.tar  压缩成 gz 格式</li>
<li>gunzip etc。tar.gz 压缩成 gz 格式压缩包</li>
<li>tar zcf etc.tar.gz /etc 把文件归档为 tar 并压缩成 gz （将打包和压缩合并成一步）</li>
<li>tar zxf etc.tar.gz 解压并解档 gz 格式压缩包（将打包解压到当前目录）</li>
</ol>
<pre><code>--gzip bin.tar  （将打包好的 bin.tar 压缩成 gz 格式，压缩完成后，之前的打包消失）</code></pre>
]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 服务器的最大连接数</title>
    <url>/blogs/linux-tcp-connect-number.html</url>
    <content><![CDATA[<h1 id="Linux-服务器的最大连接数"><a href="#Linux-服务器的最大连接数" class="headerlink" title="Linux 服务器的最大连接数"></a>Linux 服务器的最大连接数</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢 ~~</p>
<p>进程每打开一个文件（linux下一切皆文件，包括socket），都会消耗一定的内存资源。linux系统出于安全角度的考虑，在多个位置都限制了可打开的文件描述符的数量，包括系统级、用户级、进程级。</p>
<p>系统级：当前系统可打开的最大数量，通过fs.file-max参数可修改<br>用户级：指定用户可打开的最大数量，修改/etc/security/limits.conf<br>进程级：单个进程可打开的最大数量，通过fs.nr_open参数可修改</p>
<p>只建立连接，不发送，不接受，对 CPU 的消耗较少，只有一开始的握手会消耗。但维持 TCP 连接，需要创建文件对象。</p>
<p>发送接收数据时，需要新建数据缓冲区，会增加内存开销。接收缓冲区大小可以配置。</p>
]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>linux-top</title>
    <url>/blogs/linux-top.html</url>
    <content><![CDATA[<h1 id="linux-top"><a href="#linux-top" class="headerlink" title="linux-top"></a>linux-top</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢 ~~</p>
]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解 MDC</title>
    <url>/blogs/mdc.html</url>
    <content><![CDATA[<h1 id="深入理解-MDC"><a href="#深入理解-MDC" class="headerlink" title="深入理解 MDC"></a>深入理解 MDC</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢 ~~</p>
<h5 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h5><ul>
<li><a href="https://juejin.cn/post/6844904132478763022">MDC是什么鬼？用法、源码一锅端</a></li>
</ul>
]]></content>
      <tags>
        <tag>mdc</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解微服务配置中心 - Nacos</title>
    <url>/blogs/mic-config-nacos.html</url>
    <content><![CDATA[<h1 id="深入理解微服务配置中心-Nacos"><a href="#深入理解微服务配置中心-Nacos" class="headerlink" title="深入理解微服务配置中心 - Nacos"></a>深入理解微服务配置中心 - Nacos</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢 ~~</p>
<h5 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h5><ul>
<li><a href="https://www.jianshu.com/p/38b5452c9fec">Nacos 配置中心原理分析</a></li>
</ul>
]]></content>
      <tags>
        <tag>微服务</tag>
      </tags>
  </entry>
  <entry>
    <title>事件</title>
    <url>/blogs/middle-event-menu.html</url>
    <content><![CDATA[<h1 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢 ~~</p>
<h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a href="https://www.cnblogs.com/shoren/p/eventBus_springEvent.html">https://www.cnblogs.com/shoren/p/eventBus_springEvent.html</a></p>
]]></content>
      <tags>
        <tag>middle</tag>
      </tags>
  </entry>
  <entry>
    <title>文章目录 - 理论 - 中间件</title>
    <url>/blogs/middle-intruduct.html</url>
    <content><![CDATA[<h1 id="目录-理论-中间件"><a href="#目录-理论-中间件" class="headerlink" title="目录 - 理论 -  中间件"></a>目录 - 理论 -  中间件</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢~~</p>
<h2 id="一-缓存中间件"><a href="#一-缓存中间件" class="headerlink" title="一. 缓存中间件"></a>一. 缓存中间件</h2><h3 id="1-Redis"><a href="#1-Redis" class="headerlink" title="1. Redis"></a>1. Redis</h3><ul>
<li><a href="https://starrier.starrier.org/2021/01/12/redis-lua/">深入理解 redis-lua</a></li>
<li><a href="https://starrier.starrier.org/2021/01/12/redis-hyperloglog/">深入理解 redis-hyperloglog</a></li>
<li><a href="">深入理解 主从复制</a></li>
<li><a href="">深入理解 redis 内存模型</a></li>
</ul>
<h2 id="二-容器技术"><a href="#二-容器技术" class="headerlink" title="二. 容器技术"></a>二. 容器技术</h2><h3 id="1-Docker"><a href="#1-Docker" class="headerlink" title="1. Docker"></a>1. Docker</h3><h3 id="2-Kubernetes"><a href="#2-Kubernetes" class="headerlink" title="2. Kubernetes"></a>2. Kubernetes</h3><h2 id="三-NoSQL-数据库"><a href="#三-NoSQL-数据库" class="headerlink" title="三. NoSQL 数据库"></a>三. NoSQL 数据库</h2><h2 id="1-ElasticSearch"><a href="#1-ElasticSearch" class="headerlink" title="1. ElasticSearch"></a>1. ElasticSearch</h2><h2 id="四-Spring-Framework"><a href="#四-Spring-Framework" class="headerlink" title="四. Spring Framework"></a>四. Spring Framework</h2><h3 id="spring"><a href="#spring" class="headerlink" title="spring"></a>spring</h3><h1 id="Machine-Learning"><a href="#Machine-Learning" class="headerlink" title="Machine Learning"></a>Machine Learning</h1><p>-<a href="">梯度下降</a></p>
<h2 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h2><ul>
<li><a href="https://starrier.starrier.org/blogs/utils-git-commit-revert.html">使用 git-convert 回滚已经提交的 commit</a></li>
<li><a href="https://starrier.starrier.org/blogs/git-rest.html">使用 git-reset 进行版本</a></li>
<li><a href="https://starrier.starrier.org/blogs/utils-git-commit-author.html">git-commit 修改提交的 commit 信息 author</a></li>
<li><a href="https://starrier.starrier.org/blogs/utils-git-commit-refactor.html">git-commit 已提交 commit 记录的重写</a></li>
<li><a href=""></a></li>
<li><a href=""></a></li>
</ul>
]]></content>
      <tags>
        <tag>中间件 - 文章目录</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习算法 - 深入理解 Embedding</title>
    <url>/blogs/ml-algorithm-embedding.html</url>
    <content><![CDATA[<h1 id="机器学习算法-深入理解-Embedding"><a href="#机器学习算法-深入理解-Embedding" class="headerlink" title="机器学习算法 - 深入理解 Embedding"></a>机器学习算法 - 深入理解 Embedding</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢~~</p>
]]></content>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习算法 - Gradient Boosting 梯度提升</title>
    <url>/blogs/ml-algorithm-gradient-boosting.html</url>
    <content><![CDATA[<h1 id="机器学习算法-梯度提升-Gradient-Boosting"><a href="#机器学习算法-梯度提升-Gradient-Boosting" class="headerlink" title="机器学习算法 - 梯度提升 - Gradient Boosting"></a>机器学习算法 - 梯度提升 - Gradient Boosting</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢~~</p>
]]></content>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>ml-gan</title>
    <url>/blogs/ml-gan.html</url>
    <content><![CDATA[<h1 id="机器学习-GAN-简介"><a href="#机器学习-GAN-简介" class="headerlink" title="机器学习 - GAN -简介"></a>机器学习 - GAN -简介</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢~~</p>
]]></content>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>消息队列 - 介绍</title>
    <url>/blogs/mq-introduce.html</url>
    <content><![CDATA[<h1 id="消息队列-介绍"><a href="#消息队列-介绍" class="headerlink" title="消息队列 - 介绍"></a>消息队列 - 介绍</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢 ~~</p>
<h2 id="消息队列介绍"><a href="#消息队列介绍" class="headerlink" title="消息队列介绍"></a>消息队列介绍</h2><h2 id="消息队列类型"><a href="#消息队列类型" class="headerlink" title="消息队列类型"></a>消息队列类型</h2><h3 id="1-RocketMQ"><a href="#1-RocketMQ" class="headerlink" title="1. RocketMQ"></a>1. RocketMQ</h3><ol>
<li><p><a href="">深入理解 RocketMQ 路由机制</a></p>
</li>
<li><p><a href="">深入理解 RocketMQ 消息发送</a></p>
</li>
<li><p><a href="">深入理解 RocketMQ 消息存储</a></p>
</li>
<li><p><a href="">深入理解 RocketMQ 消息消费</a></p>
</li>
<li><p><a href="">深入理解 RocketMQ 消息过滤</a></p>
</li>
<li><p><a href="">深入理解 RocketMQ 消息主从同步 (HA)</a></p>
</li>
<li><p><a href="">深入理解 RocketMQ 消息事务机制</a></p>
</li>
<li><p><a href="">深入理解 RocketMQ 负载均衡</a></p>
</li>
<li><p><a href="">深入理解消息队列 MQ 消息积压</a></p>
</li>
<li><p><a href="">深入理解消息队列 MQ 重复消费</a></p>
</li>
<li><p><a href="">深入理解消息队列 MQ 消息丢失</a></p>
</li>
<li><p><a href="">深入理解消息队列 MQ 消息冥等</a></p>
</li>
<li><p><a href="">深入理解消息队列 MQ 消息事务</a></p>
</li>
</ol>
<h3 id="2-ZeroMQ"><a href="#2-ZeroMQ" class="headerlink" title="2. ZeroMQ"></a>2. ZeroMQ</h3>]]></content>
      <tags>
        <tag>消息中间件</tag>
      </tags>
  </entry>
  <entry>
    <title>消息队列 消息堆积</title>
    <url>/blogs/mq-message-accumulation.html</url>
    <content><![CDATA[<h1 id="消息队列-消息堆积"><a href="#消息队列-消息堆积" class="headerlink" title="消息队列 消息堆积"></a>消息队列 消息堆积</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢 ~~</p>
<h5 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h5><ul>
<li><p><a href="https://blog.csdn.net/WATXZDN/article/details/116652142?spm=1001.2101.3001.6661.1&utm_medium=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~Rate-1.pc_relevant_default&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~Rate-1.pc_relevant_default&utm_relevant_index=1">RocketMQ 消息堆积处理方案</a></p>
</li>
<li><p><a href="https://time.geekbang.org/column/article/113401">消息积压了该如何处理</a></p>
</li>
</ul>
]]></content>
      <tags>
        <tag>mq</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解 RabbitMQ 简介</title>
    <url>/blogs/mq-rabbitmq-introduce.html</url>
    <content><![CDATA[<h1 id="深入理解-RabbitMQ-简介"><a href="#深入理解-RabbitMQ-简介" class="headerlink" title="深入理解 RabbitMQ 简介"></a>深入理解 RabbitMQ 简介</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢 ~~</p>
<h5 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h5><ul>
<li><a href="https://blog.csdn.net/cd_yourheart/article/details/108230264#:~:text=RabbitMQ%E6%98%AF%E4%B8%80%E4%B8%AA%E5%BC%80%E6%BA%90%E7%9A%84,%E7%9A%84%E8%B4%9F%E8%BD%BD%E4%BB%A5%E5%8F%8A%E5%BB%B6%E6%97%B6%E3%80%82">RabbitMQ工作原理</a></li>
</ul>
]]></content>
      <tags>
        <tag>RabbitMQ</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解 RocketMQ 消费者</title>
    <url>/blogs/mq-rocketmq-consumer.html</url>
    <content><![CDATA[<h1 id="深入理解-RocketMQ-消费者"><a href="#深入理解-RocketMQ-消费者" class="headerlink" title="深入理解 RocketMQ 消费者"></a>深入理解 RocketMQ 消费者</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢 ~~</p>
<h3 id="重复消费问题"><a href="#重复消费问题" class="headerlink" title="重复消费问题"></a>重复消费问题</h3><p>如何解决重复消费问题 </p>
<p>消费端引入 冥等机制。消费者在进行消息消费的时候，先查看对应的 messageId 是否已经被处理过。</p>
<p>重试机制</p>
<p>默认会重试 16 次，重试的时间可以通过配置文件配置。重试 16 次之后仍然失败，对应消息就会进入到死信队列。是否处理死信队列由对应的业务场景决定。</p>
<p>乱序问题</p>
<ol>
<li><p>让需要保证消费顺序的 MQ 发送到同一个 Consumer Group</p>
</li>
<li><p>SUSPEND_CURRENT_QUEUE_A_MOMENT 状态的使用。</p>
</li>
</ol>
<h5 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h5><ul>
<li><a href="https://zhuanlan.zhihu.com/p/290886627">探索RocketMQ的重复消费和乱序问题</a></li>
</ul>
]]></content>
      <tags>
        <tag>MQ</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解 RocketMQ 生产者</title>
    <url>/blogs/mq-rocketmq-producer.html</url>
    <content><![CDATA[<h1 id="深入理解-RocketMQ-生产者"><a href="#深入理解-RocketMQ-生产者" class="headerlink" title="深入理解 RocketMQ 生产者"></a>深入理解 RocketMQ 生产者</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢 ~~</p>
<p>生产者消息发送的方式</p>
<ol>
<li>同步（默认发送方式，超时 3s）</li>
</ol>
<p>RocketMQ 发送消息后，当前线程阻塞，直到消费者返回消息。</p>
<ol start="2">
<li>异步</li>
</ol>
<p>RocketMQ 发送消息后，会注册一个回调函数，消费者返回消费状态后，会启用新的线程处理。</p>
<ol start="3">
<li>单向</li>
</ol>
<p>RocketMQ 发送消息后，当前线程结束。不用关注消费者对消息的处理状态。</p>
<p>生产者可以发送的消息类型</p>
<ul>
<li>事务消息</li>
<li>延迟消息</li>
<li>顺序消息</li>
</ul>
<p>消息发送的基本流程</p>
<ul>
<li>验证消息</li>
<li>查找路由</li>
<li>消息发送（包含异常处理机制）</li>
</ul>
<p>消息长度验证</p>
<p>批量消息发送</p>
<p>将同一主题的多条消息一起打包发送到消息服务端。</p>
<p>消息队列负载机制</p>
<p>生产者在发送消息前，如果本地路由表中不存在对应的 topic 路由信息，就会向 NameServer 发送一次请求，更新本地路由表信息。同时，<br>本地路由表每 30s 更新一次路由表信息。</p>
<p>消息发送异常机制</p>
<p>消息发送的两个高可用手段</p>
<ul>
<li>重试</li>
<li>broker 规避：如果每次消息发送时，对应的 broker 产生了错误，那么在某一段时间内，当前 broker 的消息队列就不会在被使用。</li>
</ul>
<h5 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h5><ul>
<li><a href="https://segmentfault.com/a/1190000018234735">RocketMQ生产者消息篇</a></li>
</ul>
]]></content>
      <tags>
        <tag>MQ</tag>
      </tags>
  </entry>
  <entry>
    <title>RocketMQ 协议</title>
    <url>/blogs/mq-rocketmq-protocol.html</url>
    <content><![CDATA[<h1 id="RocketMQ-协议"><a href="#RocketMQ-协议" class="headerlink" title="RocketMQ 协议"></a>RocketMQ 协议</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢 ~~</p>
<h5 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h5><ul>
<li><a href=""></a></li>
</ul>
]]></content>
      <tags>
        <tag>RocketMQ</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解 RocketMQ 拉推模型 - Pull 模型</title>
    <url>/blogs/mq-rocketmq-pull-push-model.html</url>
    <content><![CDATA[<h1 id="深入理解-RocketMQ-拉推模型-Pull-模型"><a href="#深入理解-RocketMQ-拉推模型-Pull-模型" class="headerlink" title="深入理解 RocketMQ 拉推模型 - Pull 模型"></a>深入理解 RocketMQ 拉推模型 - Pull 模型</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢 ~~</p>
<h5 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h5><ul>
<li><a href="https://blog.csdn.net/hollis_chuang/article/details/108480421?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-0.pc_relevant_paycolumn_v3&spm=1001.2101.3001.4242.1&utm_relevant_index=2">消息队列之推还是拉，RocketMQ 和 Kafka是如何做的？</a></li>
</ul>
]]></content>
      <tags>
        <tag>mq</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解 RocketMQ 存储原理</title>
    <url>/blogs/mq-rocketmq-store-principle.html</url>
    <content><![CDATA[<h1 id="深入理解-RocketMQ-存储原理"><a href="#深入理解-RocketMQ-存储原理" class="headerlink" title="深入理解 RocketMQ 存储原理"></a>深入理解 RocketMQ 存储原理</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢 ~~</p>
]]></content>
      <tags>
        <tag>RocketMQ</tag>
      </tags>
  </entry>
  <entry>
    <title>mq-rocket-transaction-in-action</title>
    <url>/blogs/mq-rocketmq-transaction-in-action.html</url>
    <content><![CDATA[<h1 id="RocketMQ-事务整合-SpringCloud-实战"><a href="#RocketMQ-事务整合-SpringCloud-实战" class="headerlink" title="RocketMQ 事务整合 SpringCloud 实战"></a>RocketMQ 事务整合 SpringCloud 实战</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢 ~~</p>
]]></content>
      <tags>
        <tag>消息中间件</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解 RocketMQ 事务原理 - 实战</title>
    <url>/blogs/mq-rocketmq-transaction.html</url>
    <content><![CDATA[<h1 id="深入理解-RocketMQ-事务原理-实战"><a href="#深入理解-RocketMQ-事务原理-实战" class="headerlink" title="深入理解 RocketMQ 事务原理 - 实战"></a>深入理解 RocketMQ 事务原理 - 实战</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢~~</p>
<p>事务消费前后 使用 redis 来保障，选择 mysql 的唯一索引 + redis 的 setNx 来看<br>当前数据是否被消费。</p>
]]></content>
      <tags>
        <tag>消息中间件</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解 RocketMQ 零拷贝</title>
    <url>/blogs/mq-rocketmq-zero-copy.html</url>
    <content><![CDATA[<h1 id="深入理解-RocketMQ-零拷贝"><a href="#深入理解-RocketMQ-零拷贝" class="headerlink" title="深入理解 RocketMQ 零拷贝"></a>深入理解 RocketMQ 零拷贝</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢 ~~</p>
<h5 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h5><ul>
<li><a href="https://www.jianshu.com/p/fe28b4cfe7a3">RocketMq中零拷贝</a></li>
</ul>
<p>正常的数据读写，需要调用 Read 和 Write 函数。</p>
<p>零拷贝的关键技术</p>
<ul>
<li>mmap 结合 write</li>
<li>sendFile </li>
</ul>
<p>RocketMQ 采用的是 sendFile 结合 write</p>
<pre class=" language-java"><code class="language-java">FileChannel<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>MapMode<span class="token punctuation">.</span>READ_WRITE<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> fileSize<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
]]></content>
      <tags>
        <tag>RocketMQ</tag>
      </tags>
  </entry>
  <entry>
    <title>消息中间件 - ZeroMQ -简介</title>
    <url>/blogs/mq-zeromq-introduce.html</url>
    <content><![CDATA[<h1 id="消息中间件-ZeroMQ-简介"><a href="#消息中间件-ZeroMQ-简介" class="headerlink" title="消息中间件 - ZeroMQ -简介"></a>消息中间件 - ZeroMQ -简介</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢 ~~</p>
<p>ZeroMQ（简称ZMQ）是一个基于消息队列的多线程网络库，其对套接字类型、连接处理、帧、甚至路由的底层细节进行抽象，提供跨越多种传输协议的套接字。</p>
<p>ZMQ是网络通信中新的一层，介于应用层和传输层之间（按照TCP/IP划分），其是一个可伸缩层，可并行运行，分散在分布式系统间。</p>
<p>ZMQ不是单独的服务，而是一个嵌入式库，它封装了网络通信、消息队列、线程调度等功能，向上层提供简洁的API，应用程序通过加载库文件，调用API函数来实现高性能网络通信。</p>
<h2 id="消息模型"><a href="#消息模型" class="headerlink" title="消息模型"></a>消息模型</h2><p>ZeroMQ将消息通信分成4种模型，分别是一对一结对模型（Exclusive-Pair）、请求回应模型（Request-Reply）、发布订阅模型（Publish-Subscribe）、推拉模型（Push-Pull）。这4种模型总结出了通用的网络通信模型，在实际中可以根据应用需要，组合其中的2种或多种模型来形成自己的解决方案。</p>
<h3 id="1-一对一结对模型"><a href="#1-一对一结对模型" class="headerlink" title="1. 一对一结对模型"></a>1. 一对一结对模型</h3><p>最简单的1:1消息通信模型，可以认为是一个TCP Connection，但是TCP Server只能接受一个连接。数据可以双向流动，这点不同于后面的请求回应模型。</p>
<h3 id="2-请求回应模型"><a href="#2-请求回应模型" class="headerlink" title="2.请求回应模型"></a>2.请求回应模型</h3><p>由请求端发起请求，然后等待回应端应答。一个请求必须对应一个回应，从请求端的角度来看是发-收配对，从回应端的角度是收-发对。跟一对一结对模型的区别在于请求端可以是1~N个。该模型主要用于远程调用及任务分配等。Echo服务就是这种经典模型的应用。</p>
<h3 id="3-发布订阅模型"><a href="#3-发布订阅模型" class="headerlink" title="3. 发布订阅模型"></a>3. 发布订阅模型</h3><p>发布端单向分发数据，且不关心是否把全部信息发送给订阅端。如果发布端开始发布信息时，订阅端尚未连接上来，则这些信息会被直接丢弃。订阅端未连接导致信息丢失的问题，可以通过与请求回应模型组合来解决。订阅端只负责接收，而不能反馈，且在订阅端消费速度慢于发布端的情况下，会在订阅端堆积数据。该模型主要用于数据分发。天气预报、微博明星粉丝可以应用这种经典模型。</p>
<h3 id="4-推拉模型"><a href="#4-推拉模型" class="headerlink" title="4. 推拉模型"></a>4. 推拉模型</h3><p>Server端作为Push端，而Client端作为Pull端，如果有多个Client端同时连接到Server端，则Server端会在内部做一个负载均衡，采用平均分配的算法，将所有消息均衡发布到Client端上。与发布订阅模型相比，推拉模型在没有消费者的情况下，发布的消息不会被消耗掉；在消费者能力不够的情况下，能够提供多消费者并行消费解决方案。该模型主要用于多任务并行。</p>
<h2 id="通信协议"><a href="#通信协议" class="headerlink" title="通信协议"></a>通信协议</h2><p>提供进程内、进程间、机器间、广播等四种通信协议。通信协议配置简单，用类似于URL形式的字符串指定即可，格式分别为inproc://、ipc://、tcp://、pgm://。ZeroMQ会自动根据指定的字符串解析出协议、地址、端口号等信息。</p>
]]></content>
      <tags>
        <tag>消息中间件</tag>
      </tags>
  </entry>
  <entry>
    <title>mybatis-actual-params-type</title>
    <url>/blogs/mybatis-actual-params-type.html</url>
    <content><![CDATA[<h1 id="MyBatis-实战-传参类型"><a href="#MyBatis-实战-传参类型" class="headerlink" title="MyBatis - 实战 - 传参类型"></a>MyBatis - 实战 - 传参类型</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢 ~~</p>
<h2 id="1-单个参数"><a href="#1-单个参数" class="headerlink" title="1. 单个参数"></a>1. 单个参数</h2><pre class=" language-java"><code class="language-java">   <span class="token comment" spellcheck="true">//接口方法</span>
   <span class="token keyword">int</span> <span class="token function">getAgeById</span><span class="token punctuation">(</span>Integer id<span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token comment" spellcheck="true">//xml映射文件</span>
   <span class="token operator">&lt;</span>select id<span class="token operator">=</span><span class="token string">"getAgeById"</span> resultType<span class="token operator">=</span><span class="token string">"Integer"</span><span class="token operator">></span>
   select age from user where user_id <span class="token operator">=</span> #<span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>id<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
   <span class="token operator">&lt;</span><span class="token operator">/</span>select<span class="token operator">></span>
</code></pre>
<h2 id="2-多个参数"><a href="#2-多个参数" class="headerlink" title="2. 多个参数"></a>2. 多个参数</h2><pre class=" language-xml"><code class="language-xml">   <span class="token comment" spellcheck="true">&lt;!--接口方法--></span>
   User login(@Param("username") String username, @Param("password") String password);
   <span class="token comment" spellcheck="true">&lt;!--xml映射文件--></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>select</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>login<span class="token punctuation">"</span></span> <span class="token attr-name">resultMap</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>BaseResultMap<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
    select
    *
    from user
    where username = #<span class="token entity" title="&#123;">&amp;#123;</span>username<span class="token entity" title="&#125;">&amp;#125;</span> and password = #<span class="token entity" title="&#123;">&amp;#123;</span>password<span class="token entity" title="&#125;">&amp;#125;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>select</span><span class="token punctuation">></span></span></code></pre>
<h2 id="3-数组参数"><a href="#3-数组参数" class="headerlink" title="3. 数组参数"></a>3. 数组参数</h2><pre class=" language-xml"><code class="language-xml">   <span class="token comment" spellcheck="true">&lt;!--接口方法--></span>
        ArrayList<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>User</span><span class="token punctuation">></span></span> selectByIds(Integer [] ids);
   <span class="token comment" spellcheck="true">&lt;!--xml映射文件--></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>select</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>selectByIds<span class="token punctuation">"</span></span> <span class="token attr-name">resultMap</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>BaseResultMap<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
        select
        *
        from user where id in
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>foreach</span> <span class="token attr-name">item</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>item<span class="token punctuation">"</span></span> <span class="token attr-name">index</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>index<span class="token punctuation">"</span></span> <span class="token attr-name">collection</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>array<span class="token punctuation">"</span></span> <span class="token attr-name">open</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>(<span class="token punctuation">"</span></span> <span class="token attr-name">separator</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>,<span class="token punctuation">"</span></span> <span class="token attr-name">close</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>)<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
            #<span class="token entity" title="&#123;">&amp;#123;</span>item<span class="token entity" title="&#125;">&amp;#125;</span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>foreach</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>select</span><span class="token punctuation">></span></span></code></pre>
<h2 id="4-List参数"><a href="#4-List参数" class="headerlink" title="4.List参数"></a>4.List参数</h2><pre class=" language-xml"><code class="language-xml"><span class="token comment" spellcheck="true">&lt;!--接口方法--></span>
ArrayList<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>User</span><span class="token punctuation">></span></span> selectByIds(List<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Integer</span><span class="token punctuation">></span></span> ids);
<span class="token comment" spellcheck="true">&lt;!--xml映射文件--></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>select</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>selectByIds<span class="token punctuation">"</span></span> <span class="token attr-name">resultMap</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>BaseResultMap<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
        Select
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>include</span> <span class="token attr-name">refid</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>Base_Column_List<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>
        from jria where ID in
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>foreach</span> <span class="token attr-name">item</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>item<span class="token punctuation">"</span></span> <span class="token attr-name">index</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>index<span class="token punctuation">"</span></span> <span class="token attr-name">collection</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>list<span class="token punctuation">"</span></span> <span class="token attr-name">open</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>(<span class="token punctuation">"</span></span> <span class="token attr-name">separator</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>,<span class="token punctuation">"</span></span> <span class="token attr-name">close</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>)<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
            #<span class="token entity" title="&#123;">&amp;#123;</span>item<span class="token entity" title="&#125;">&amp;#125;</span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>foreach</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>select</span><span class="token punctuation">></span></span></code></pre>
]]></content>
      <tags>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解 MyBatis - 缓存</title>
    <url>/blogs/mybatis-cache.html</url>
    <content><![CDATA[<h1 id="深入理解-MyBatis-缓存"><a href="#深入理解-MyBatis-缓存" class="headerlink" title="深入理解 MyBatis - 缓存"></a>深入理解 MyBatis - 缓存</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢 ~~</p>
<p>MyBaits 一级缓存<br>包名+函数名 进行 map 缓存，一旦设计到写入操作，比如 update 就会将缓存全部情况。<br>由于 MyBatis 无法确定是哪个缓存，所以就会将所有的操作置空。</p>
<p>一级缓存中，sqlSession 会有自己的缓存，不同的 sqlSession 不会共享缓存。</p>
<p>可以手动执行缓存清除</p>
<p><code>sqlSession.clearCache()</code></p>
<h5 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h5><ul>
<li><a href="https://zhuanlan.zhihu.com/p/464162932">Mybatis 一连串提问，被面试官吊打了！</a></li>
</ul>
]]></content>
      <tags>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title>MyBatis 缓存</title>
    <url>/blogs/mybatis-introduce.html</url>
    <content><![CDATA[<h1 id="MyBaits-缓存"><a href="#MyBaits-缓存" class="headerlink" title="MyBaits 缓存"></a>MyBaits 缓存</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢~~</p>
<blockquote>
<ol>
<li><a href="">MyBatis - 工具类 - ScriptRunner</a></li>
<li><a href="">MyBatis - 工具类 - SqlRunner</a></li>
<li><a href="">MyBatis - 工具类 - MetaObject</a></li>
<li><a href="">MyBatis - 工具类 - MetaClass</a></li>
<li><a href="">MyBatis - 工具类 - ObjectFactory</a></li>
<li><a href="">MyBatis - 工具类 - ProxyFactory</a></li>
<li><a href="">MyBatis - 核心组件 - Configuration</a></li>
<li><a href="">MyBatis - 核心组件 - Executor</a></li>
<li><a href="">MyBatis - 核心组件 - MappedStatement</a></li>
<li><a href="">MyBatis - 核心组件 - TypeHandler</a></li>
<li><a href="">MyBatis - 核心组件 - ParameterHandler</a></li>
<li><a href="">MyBatis - 核心组件 - ResultSetHandler</a></li>
<li><a href="">MyBatis - SqlSession - XPath</a></li>
<li><a href="">MyBatis - SqlSession - Configuration 创建过程</a></li>
<li><a href="">MyBatis - SqlSession - SqlSession 创建过程</a></li>
<li><a href="">MyBatis - SqlSession - Mapper 执行过程</a></li>
</ol>
</blockquote>
<p><code>MyBatis</code> 的一些关键特性（例如通过 <code>&lt;association&gt;</code> 和 <code>&lt;collection&gt;</code> 建立级联映射<br>避免循环引用（circular references）、加速重复嵌套查询等）都是基于 <code>MyBatis</code> 一级缓存实现的，而且 <code>MyBatis</code> 结果集映射相关代码重度依赖 <code>CacheKey</code>，所以目前 <code>MyBatis</code> 不支持关闭一级缓存。</p>
]]></content>
      <tags>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解 MyBatis - PooledDataSource</title>
    <url>/blogs/mybatis-pooled-data-source.html</url>
    <content><![CDATA[<h1 id="深入理解-MyBatis-PooledDataSource"><a href="#深入理解-MyBatis-PooledDataSource" class="headerlink" title="深入理解 MyBatis - PooledDataSource"></a>深入理解 MyBatis - PooledDataSource</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢~~</p>
<p>我们在进行数据库链接操作时，会通过 <code>JDBC</code>  的 <code>connection</code> 进行数据库操作。但是频繁的创建和销毁 <code>connection</code> 会影响执行效率。因此 <code>MyBatis</code> 中存在连接池技术</p>
<ul>
<li><code>pooled</code></li>
<li><code>unpooled</code> </li>
</ul>
<h3 id="PooledDataSource-分析"><a href="#PooledDataSource-分析" class="headerlink" title="PooledDataSource 分析"></a><code>PooledDataSource</code> 分析</h3><p>数据库基础配置以及事务的隔离级别</p>
<pre class=" language-java"><code class="language-java">
  <span class="token keyword">private</span> String driver<span class="token punctuation">;</span>
  <span class="token keyword">private</span> String url<span class="token punctuation">;</span>
  <span class="token keyword">private</span> String username<span class="token punctuation">;</span>
  <span class="token keyword">private</span> String password<span class="token punctuation">;</span>

  <span class="token keyword">private</span> Boolean autoCommit<span class="token punctuation">;</span>
  <span class="token keyword">private</span> Integer defaultTransactionIsolationLevel<span class="token punctuation">;</span></code></pre>
<p>初始化时，会加载并注册驱动</p>
<pre class=" language-java"><code class="language-java">  <span class="token keyword">static</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
    Enumeration<span class="token operator">&lt;</span>Driver<span class="token operator">></span> drivers <span class="token operator">=</span> DriverManager<span class="token punctuation">.</span><span class="token function">getDrivers</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>drivers<span class="token punctuation">.</span><span class="token function">hasMoreElements</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
      Driver driver <span class="token operator">=</span> drivers<span class="token punctuation">.</span><span class="token function">nextElement</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      registeredDrivers<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>driver<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> driver<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
  <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre>
<p>获取数据库的连接时，会调用以下方法</p>
<ol>
<li> 构造配置文件，用户名和密码，准备链接</li>
<li> 加载驱动，准备链接</li>
<li> 获取数据库连接</li>
<li> 对连接进行配置</li>
</ol>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UnpooledDataSource</span> <span class="token keyword">implements</span> <span class="token class-name">DataSource</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>

  <span class="token keyword">private</span> Connection <span class="token function">doGetConnection</span><span class="token punctuation">(</span>String username<span class="token punctuation">,</span> String password<span class="token punctuation">)</span> <span class="token keyword">throws</span> SQLException <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
    Properties props <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Properties</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>driverProperties <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
      props<span class="token punctuation">.</span><span class="token function">putAll</span><span class="token punctuation">(</span>driverProperties<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>username <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
      props<span class="token punctuation">.</span><span class="token function">setProperty</span><span class="token punctuation">(</span><span class="token string">"user"</span><span class="token punctuation">,</span> username<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>password <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
      props<span class="token punctuation">.</span><span class="token function">setProperty</span><span class="token punctuation">(</span><span class="token string">"password"</span><span class="token punctuation">,</span> password<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token function">doGetConnection</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>

  <span class="token keyword">private</span> Connection <span class="token function">doGetConnection</span><span class="token punctuation">(</span>Properties properties<span class="token punctuation">)</span> <span class="token keyword">throws</span> SQLException <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
    <span class="token function">initializeDriver</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    Connection connection <span class="token operator">=</span> DriverManager<span class="token punctuation">.</span><span class="token function">getConnection</span><span class="token punctuation">(</span>url<span class="token punctuation">,</span> properties<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">configureConnection</span><span class="token punctuation">(</span>connection<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> connection<span class="token punctuation">;</span>
  <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre>
<p>初始化驱动</p>
<pre class=" language-java"><code class="language-java">  <span class="token keyword">private</span> <span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">initializeDriver</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> SQLException <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>registeredDrivers<span class="token punctuation">.</span><span class="token function">containsKey</span><span class="token punctuation">(</span>driver<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
      Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> driverType<span class="token punctuation">;</span>
      <span class="token keyword">try</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>driverClassLoader <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
          driverType <span class="token operator">=</span> Class<span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span>driver<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">,</span> driverClassLoader<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">else</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
          driverType <span class="token operator">=</span> Resources<span class="token punctuation">.</span><span class="token function">classForName</span><span class="token punctuation">(</span>driver<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// DriverManager requires the driver to be loaded via the system ClassLoader.</span>
        <span class="token comment" spellcheck="true">// http://www.kfu.com/~nsayer/Java/dyn-jdbc.html</span>
        Driver driverInstance <span class="token operator">=</span> <span class="token punctuation">(</span>Driver<span class="token punctuation">)</span>driverType<span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        DriverManager<span class="token punctuation">.</span><span class="token function">registerDriver</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">DriverProxy</span><span class="token punctuation">(</span>driverInstance<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        registeredDrivers<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>driver<span class="token punctuation">,</span> driverInstance<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">SQLException</span><span class="token punctuation">(</span><span class="token string">"Error setting driver on UnpooledDataSource. Cause: "</span> <span class="token operator">+</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
  <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
</code></pre>
<p> 对链接进行配置，查看是否是自动提交，是否存在配置的事务隔离级别</p>
<pre class=" language-java"><code class="language-java">  <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">configureConnection</span><span class="token punctuation">(</span>Connection conn<span class="token punctuation">)</span> <span class="token keyword">throws</span> SQLException <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>autoCommit <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> autoCommit <span class="token operator">!=</span> conn<span class="token punctuation">.</span><span class="token function">getAutoCommit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
      conn<span class="token punctuation">.</span><span class="token function">setAutoCommit</span><span class="token punctuation">(</span>autoCommit<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>defaultTransactionIsolationLevel <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
      conn<span class="token punctuation">.</span><span class="token function">setTransactionIsolation</span><span class="token punctuation">(</span>defaultTransactionIsolationLevel<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
  <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
</code></pre>
]]></content>
      <tags>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title>mybatis-sql-inject</title>
    <url>/blogs/mybatis-sql-inject.html</url>
    <content><![CDATA[<h1 id="MyBatis-中的-SQL-注入"><a href="#MyBatis-中的-SQL-注入" class="headerlink" title="MyBatis 中的 SQL 注入"></a>MyBatis 中的 SQL 注入</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢 ~~</p>
<p>产生问题的是哪个情况</p>
<ul>
<li><p>模糊查询</p>
</li>
<li><p>in </p>
</li>
<li><p>order by</p>
</li>
</ul>
<h5 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h5><ul>
<li><a href="https://www.cnblogs.com/javastack/p/13277739.html">Mybatis 框架下 SQL 注入攻击的 3 种方式，真是防不胜防！ </a></li>
</ul>
]]></content>
      <tags>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解 MySQL ACID 原理</title>
    <url>/blogs/mysql-acid.html</url>
    <content><![CDATA[<h1 id="深入理解-MySQL-ACID-原理"><a href="#深入理解-MySQL-ACID-原理" class="headerlink" title="深入理解 MySQL ACID 原理"></a>深入理解 MySQL ACID 原理</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢 ~~</p>
<h5 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h5><ul>
<li><a href="https://www.cnblogs.com/kismetv/p/10331633.html">深入学习MySQL事务：ACID特性的实现原理 </a></li>
</ul>
]]></content>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL 基础知识</title>
    <url>/blogs/mysql-basic.html</url>
    <content><![CDATA[<h1 id="MySQL-基础知识"><a href="#MySQL-基础知识" class="headerlink" title="MySQL 基础知识"></a>MySQL 基础知识</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢 ~~</p>
<p>数据库 三大范式</p>
<p>唯一键：</p>
<p>唯一约束和联合唯一约束，实际上就是建立的索引。唯一键是索引的一种。UNIQUE Key。一张表允许同时存在多个唯一键。</p>
<p>唯一键删除语法：</p>
<pre class=" language-sql"><code class="language-sql"><span class="token keyword">alter</span> <span class="token keyword">table</span> 表名 <span class="token keyword">drop</span> <span class="token keyword">index</span> 唯一键名字<span class="token punctuation">;</span></code></pre>
<p>MySQL 主键不是严格自增的。</p>
<blockquote>
<p>当前仅讨论 InnoDB</p>
</blockquote>
<ol>
<li>5.7.0 及其之前的版本，自增主键值主要保存在内存中，一旦数据库发生重启，就会重新获取数据库当前最大的自增主键值到内存中</li>
<li>获取 AUTO_INCREMENT 时不会使用事务锁，并发的插入事务可能出现部分字段冲突导致插入失败；</li>
</ol>
<h5 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h5><ul>
<li><p><a href="https://www.cnblogs.com/xuan584521/p/6366541.html">MYSQL三大范式 </a></p>
</li>
<li><p><a href="https://blog.csdn.net/JavaCoder_juejue/article/details/82085285">mysql之列属性篇六之 —— 唯一键（unique）</a></p>
</li>
</ul>
]]></content>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解 MySQL 执行原理</title>
    <url>/blogs/mysql-execute-princciple.html</url>
    <content><![CDATA[<h1 id="深入理解-MySQL-执行原理"><a href="#深入理解-MySQL-执行原理" class="headerlink" title="深入理解 MySQL 执行原理"></a>深入理解 MySQL 执行原理</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢 ~~</p>
<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><h2 id="执行引擎"><a href="#执行引擎" class="headerlink" title="执行引擎"></a>执行引擎</h2><h5 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h5><ul>
<li><a href="https://blog.csdn.net/king13127/article/details/115527450">深入理解mysql-第三章 mysql处理请求流程</a></li>
</ul>
]]></content>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL 分库分表</title>
    <url>/blogs/mysql-fen-ku-fen-biao.html</url>
    <content><![CDATA[<h1 id="MySQL-分库分表"><a href="#MySQL-分库分表" class="headerlink" title="MySQL 分库分表"></a>MySQL 分库分表</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢 ~~</p>
<h5 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h5><ul>
<li><p><a href="https://segmentfault.com/a/1190000040852829">终于有人把分库分表写清楚了！！</a></p>
</li>
<li><p><a href=""></a></p>
</li>
</ul>
]]></content>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql-fuc-update-or-insert</title>
    <url>/blogs/mysql-fuc-update-or-insert.html</url>
    <content><![CDATA[<h1 id="MySQL-新增数据：如果存在则更新，否则就进行插入"><a href="#MySQL-新增数据：如果存在则更新，否则就进行插入" class="headerlink" title="MySQL 新增数据：如果存在则更新，否则就进行插入"></a>MySQL 新增数据：如果存在则更新，否则就进行插入</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢 ~~</p>
<ol>
<li>insert into 表名（） on duplicate key</li>
</ol>
<blockquote>
<p>DUPLICATE不会删除原有的记录。即：不会破坏索引。</p>
</blockquote>
<ol start="2">
<li>replace into</li>
</ol>
<blockquote>
<p>REPLACE INTO底层是先删除后插入数据，会破坏索引、重新维护索引，必须要有主键或者唯一索引，否则只是新增。</p>
</blockquote>
<h5 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h5><ul>
<li><a href=""></a></li>
</ul>
]]></content>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解 MySQL 间隙锁</title>
    <url>/blogs/mysql-gap-lock.html</url>
    <content><![CDATA[<h1 id="深入理解-MySQL-间隙锁"><a href="#深入理解-MySQL-间隙锁" class="headerlink" title="深入理解 MySQL 间隙锁"></a>深入理解 MySQL 间隙锁</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢 ~~</p>
<p>当我们在进行范围查询的时候，请求共享或排他锁的时候，MySQL 会对查询的区间进行加锁，及时对应区间可能没有数据也会被锁住。</p>
<blockquote>
<p>如果请求对一个不存在的记录进行加锁，MySQL 也会使用间隙锁（Next-key）</p>
</blockquote>
<p><strong>MySQL 中尽量不要使用 update 进行范围更新。</strong></p>
<h5 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h5><ul>
<li><a href="https://vegetable-chicken.blog.csdn.net/article/details/81030920?spm=1001.2101.3001.6650.1&utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~default-1.no_search_link&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~default-1.no_search_link&utm_relevant_index=2">间隙锁详解</a></li>
</ul>
]]></content>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL 索引失效</title>
    <url>/blogs/mysql-index-invalid.html</url>
    <content><![CDATA[<h1 id="MySQL-索引失效"><a href="#MySQL-索引失效" class="headerlink" title="MySQL 索引失效"></a>MySQL 索引失效</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢 ~~</p>
<h3 id="失效的场景"><a href="#失效的场景" class="headerlink" title="失效的场景"></a>失效的场景</h3><ul>
<li>不满足最左前缀原则</li>
<li>范围索引列没有放在最后</li>
<li>使用了 <code>select *</code></li>
<li>索引列上有计算</li>
<li>索引列上使用了函数</li>
<li>字符类型没有加引号</li>
<li>用了 is null 和 is not null 没有注意字段是否允许为空</li>
<li>like 查询左边有 %</li>
<li>使用 or 关键字时没注意</li>
</ul>
<h3 id="索引使用推荐"><a href="#索引使用推荐" class="headerlink" title="索引使用推荐"></a>索引使用推荐</h3><ul>
<li>优先使用唯一索引</li>
<li>为常用查询字段建索引</li>
<li>为排序，分组和联合查询字段建索引</li>
<li>一张表的索引不超过 5 个</li>
<li>表数据量少，可以不建立索引</li>
<li>尽量使用占用空间小的字段建索引</li>
<li>用 idx 或 unx 等前缀命名缩影</li>
<li>删除没用的索引</li>
</ul>
<p>参考文章</p>
<ul>
<li><a href="https://www.cnblogs.com/technologykai/articles/14172224.html">MYSQL索引失效的常见原因和如何用好索引</a>  </li>
</ul>
]]></content>
      <tags>
        <tag>MySQl</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL 索引</title>
    <url>/blogs/mysql-index.html</url>
    <content><![CDATA[<h1 id="MySQL-索引"><a href="#MySQL-索引" class="headerlink" title="MySQL 索引"></a>MySQL 索引</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢 ~~</p>
<h5 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h5><ul>
<li><a href="https://cloud.tencent.com/developer/article/1541265">聚簇索引与非聚簇索引（也叫二级索引）–最清楚的一篇讲解</a></li>
</ul>
]]></content>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解 MySQL - 聚簇索引和非聚簇索引</title>
    <url>/blogs/mysql-index-jucu-fei-jucu.html</url>
    <content><![CDATA[<h1 id="深入理解-MySQL-聚簇索引和非聚簇索引"><a href="#深入理解-MySQL-聚簇索引和非聚簇索引" class="headerlink" title="深入理解 MySQL - 聚簇索引和非聚簇索引"></a>深入理解 MySQL - 聚簇索引和非聚簇索引</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢 ~~</p>
<p>聚簇索引默认是主键，如果没有主键，InnoDB 会找一个非空的唯一索引来当聚簇索引，如果也没有<br>这样的索引，InnoDB 就会默认生成一个隐式的聚簇索引</p>
<p>在 MyISM 中，主键和辅助索引都一样，</p>
<h5 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h5><ul>
<li><a href="https://cloud.tencent.com/developer/article/1541265">聚簇索引与非聚簇索引（也叫二级索引）–最清楚的一篇讲解</a></li>
</ul>
]]></content>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解 MySQL 模糊搜索</title>
    <url>/blogs/mysql-fuzzy-query.html</url>
    <content><![CDATA[<h1 id="深入理解-MySQL-模糊搜索"><a href="#深入理解-MySQL-模糊搜索" class="headerlink" title="深入理解 MySQL 模糊搜索"></a>深入理解 MySQL 模糊搜索</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢 ~~</p>
<h5 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h5><ul>
<li><a href=""></a></li>
</ul>
]]></content>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL Innodb 数据结构</title>
    <url>/blogs/mysql-innodb-datastruct-introduce.html</url>
    <content><![CDATA[<h1 id="MySQL-Innodb-数据结构"><a href="#MySQL-Innodb-数据结构" class="headerlink" title="MySQL Innodb 数据结构"></a>MySQL Innodb 数据结构</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢 ~~</p>
<p>B+ 叶子节点保存数据，叶子节点都是像连的。</p>
<h5 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h5><ul>
<li><a href="https://blog.csdn.net/weixin_29563497/article/details/113284907">mysql为什么不用b树_MySQL用B+树(而不是B树)做索引的原因</a></li>
</ul>
]]></content>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL 文章目录</title>
    <url>/blogs/mysql-introduce.html</url>
    <content><![CDATA[<h1 id="MySQL-文章目录"><a href="#MySQL-文章目录" class="headerlink" title="MySQL 文章目录"></a>MySQL 文章目录</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢 ~~</p>
<ul>
<li><p><a href="">MySQL 基础知识</a></p>
</li>
<li><p><a href="">深入理解 MySQL 事务机制</a></p>
</li>
<li><p><a href="">深入理解 MySQL 日志系统</a></p>
</li>
<li><p><a href="">深入理解 MySQL 间隙锁</a></p>
</li>
<li><p><a href="">深入理解 MySQL 聚簇索引和非聚簇索引</a></p>
</li>
</ul>
<h5 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h5><ul>
<li><a href=""></a></li>
</ul>
]]></content>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL like 关键字</title>
    <url>/blogs/mysql-like.html</url>
    <content><![CDATA[<h1 id="MySQL-like-关键字"><a href="#MySQL-like-关键字" class="headerlink" title="MySQL like 关键字"></a>MySQL like 关键字</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢 ~~</p>
]]></content>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解 MySQL 日志类型</title>
    <url>/blogs/mysql-log-introduce.html</url>
    <content><![CDATA[<h1 id="深入理解-MySQL-日志类型"><a href="#深入理解-MySQL-日志类型" class="headerlink" title="深入理解 MySQL 日志类型"></a>深入理解 MySQL 日志类型</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢 ~~</p>
<h2 id="BinLog"><a href="#BinLog" class="headerlink" title="BinLog"></a>BinLog</h2><p>主要是用来做数据备份和数据恢复。</p>
<p>BinLog 中记录了数据的修改信息，针对 Insert，Update，Delete Truncat，不会记录 Select 因为 Select 没有对数据库进行修改。</p>
<p>因为我们查询数据库时，是通过数据库的搜索引擎来查找数据的，所以这个时候，我们搜索引擎就需要知道数据什么时候发生了变化，这个时候我们就可以通过<br>监听 BinLog 来追踪数据的变化状态。</p>
<p>Binlog 记录了表结构和表数据的变更。</p>
<p>默认是没有 binlog 的，需要配置开启</p>
<pre class=" language-editorconfig"><code class="language-editorconfig">server-id=1001 # 指定 server-id
log-bin=mysqlbin # 默认配置</code></pre>
<p>redolog 在引擎层，记录了物理改变<br>binlog 在Server 层。</p>
<p>redolog 顺序 IO解决写入的性能<br>change buffer 解决读的性能</p>
<p>binlog 默认是 Statement 只记录改变的语句。<br>row 模式记录数据变更前后</p>
<h2 id="RedoLog"><a href="#RedoLog" class="headerlink" title="RedoLog"></a>RedoLog</h2><p>MySQL 数据存储结构是页。会先查到数据所在的页，然后将其加载至缓存。</p>
<p>存在的问题：</p>
<p>如果在内存中，将数据进行了修改，这个时候 MySQL 挂了，由于还未将内存的数据变更同步到磁盘，那么这一次的修改就丢失。如果每次修改都直接落盘，<br>性能就会很低，因此引入了 RedoLog。</p>
<p>尽管 redolog 也要落盘，但是 redolog 是顺序IO(顺序IO 比 随机 IO 快)</p>
<p>用来保证数据的持久性。MySQL 最终将数据写入到磁盘上，但是会提供一个 buffer pool 用于存储数据，<br>buffer pool 满了或者会定时的将数据（数据脏页）持久化到磁盘上。</p>
<p>背景：</p>
<p>如果 MySQL 突然宕机了，但是此时页数据中的 修改还未提交，就会导致对应修改或新增数据的丢失，Redo Log 就是用于解决这个问题。</p>
<p>redolog 主要用户记录页数据的修改。</p>
<h2 id="UndoLog"><a href="#UndoLog" class="headerlink" title="UndoLog"></a>UndoLog</h2><p>主要用于数据的回滚和多版本并发控制（MVCC）</p>
<p>比如我们需要进行 insert 语句，就会生成相反的 delete 语句。</p>
<h5 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h5><ul>
<li><p><a href="https://blog.csdn.net/aiwangtingyun/article/details/108580918">【MySQL】之 binlog、undo log 和 redo log 详解</a></p>
</li>
<li><p><a href="https://cheng-dp.github.io/2019/05/09/mysql-tx-redo-undo/">MySQL事务实现及Redo Log和Undo Log详解</a></p>
</li>
</ul>
]]></content>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL - 主备一致</title>
    <url>/blogs/mysql-master-slave-consistency.html</url>
    <content><![CDATA[<h1 id="MySQL-主备一致"><a href="#MySQL-主备一致" class="headerlink" title="MySQL - 主备一致"></a>MySQL - 主备一致</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢 ~~</p>
<p>全局异常处理的设计</p>
<ol>
<li><p>业务逻辑正常异常</p>
</li>
<li><p>未知逻辑导致异常</p>
</li>
</ol>
<ol>
<li><p>如果是业务逻辑正常情况下，已知可能会产生的异常，有两种处理，要么直接 catch 处理（非全局，而是当前函数内部处理），要么往上抛，由框架层面 全局 catch，这时候，全局异常处理，如果已知<br>可能产生的异常是什么异常类型，可以自定义如何处理，如果不知道，则统一交由 Exception 顶级父类处理，设定这一类的统一异常信息返回结果</p>
</li>
<li><p>未知逻辑导致异常，同样分两种情况，</p>
</li>
</ol>
<ul>
<li>为了保证业务可以正常进行，对于这种情况，一般由当前业务内部处理，不往上抛，即不会经由全局异常处理。</li>
<li>在业务允许或者是设计正常的情况下，需要抛出，这个时候就需要由 全局异常处理。一般这种未知的 异常，全局异常很难定位具体类型，一般交由顶级父类 Exception 处理<br>如果知道可能潜在的异常，可以自行定义如何处理。</li>
</ul>
<p>总结</p>
<ol>
<li><p>一般情况下，为了保证用户的体验，异常的处理一般很少交由全局异常处理，这个时候的异常，一般由函数内部处理，返回空数据等返回值。<br>业务设计正常情况下，需要设计的异常是需要让用户感知的异常，这个时候设计的一般设计特定的类型返回值。</p>
</li>
<li><p>对于全局异常返回的设计，大部分情况下的设计都是针对未知，无法感知的异常，且会导致系统问题，为了保证系统正常运行而进行 catch 比如  内存问题，空指针问题等</p>
</li>
</ol>
]]></content>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解 MySQL 主从复制</title>
    <url>/blogs/mysql-master-slave-copy.html</url>
    <content><![CDATA[<h1 id="深入理解-MySQL-主从复制"><a href="#深入理解-MySQL-主从复制" class="headerlink" title="深入理解 MySQL 主从复制"></a>深入理解 MySQL 主从复制</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢 ~~</p>
]]></content>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL 锁分类</title>
    <url>/blogs/mysql-lock-introduce.html</url>
    <content><![CDATA[<h1 id="MySQL-锁分类"><a href="#MySQL-锁分类" class="headerlink" title="MySQL 锁分类"></a>MySQL 锁分类</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢 ~~</p>
<h5 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h5><ul>
<li><a href=""></a></li>
</ul>
]]></content>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解 MySQL MVCC</title>
    <url>/blogs/mysql-mvcc.html</url>
    <content><![CDATA[<h1 id="深入理解-MySQL-MVCC"><a href="#深入理解-MySQL-MVCC" class="headerlink" title="深入理解 MySQL MVCC"></a>深入理解 MySQL MVCC</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢 ~~</p>
<ol>
<li>三个隐藏的字段</li>
</ol>
<blockquote>
<p>1.一个 6字节的 DB_TRX_ID 字段 即:通常在其他文章中看到的 事务id</p>
<p>2.一个7字节的 DB_ROLL_PTR 字段 即:通常范围以回滚指针</p>
<p>3.一个 6字节的 DB_ROW_ID 字段, 该字段在当前事务自增,主要是确定当前数据id (本文章中不涉及该字段)</p>
</blockquote>
<ol start="2">
<li><p>Read-View</p>
</li>
<li><p>undo log（数据可视性原则）</p>
<blockquote>
<p>MySQL 底层通过比对 read-view 中的事务 ID 来判断 undo log 数据对当前事务的可见性。 </p>
</blockquote>
</li>
</ol>
<h5 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h5><ul>
<li><p><a href="https://cloud.tencent.com/developer/article/1450773">快速理解脏读、不可重复读、幻读和MVCC</a></p>
</li>
<li><p><a href="https://www.jianshu.com/p/20fa5703bd3e">MySql MVCC 机制底层原理</a></p>
</li>
</ul>
]]></content>
      <tags>
        <tag>MySQl</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL 调优 - Profile</title>
    <url>/blogs/mysql-optimize-profile.html</url>
    <content><![CDATA[<h1 id="MySQL-调优-Profile"><a href="#MySQL-调优-Profile" class="headerlink" title="MySQL 调优 - Profile"></a>MySQL 调优 - Profile</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢 ~~</p>
<p>profile此工具可用来查询SQL执行状态，System lock和Table lock 花多少时间等等，对定位一条语句的I/O消耗和CPU消耗 非常重要。(SQL 语句执行所消耗的最大两部分资源就是IO和CPU)</p>
<h2 id="开启"><a href="#开启" class="headerlink" title="开启"></a>开启</h2><pre class=" language-sql"><code class="language-sql">mysql<span class="token operator">></span> <span class="token keyword">set</span> profile<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span></code></pre>
<h2 id="profile-的参数"><a href="#profile-的参数" class="headerlink" title="profile 的参数"></a>profile 的参数</h2><table>
<thead>
<tr>
<th>类型</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>ALL</td>
<td>–显示所有的开销信息</td>
</tr>
<tr>
<td>BLOCK IO</td>
<td>–显示块IO相关开销</td>
</tr>
<tr>
<td>CONTEXT SWITCHES</td>
<td>–上下文切换相关开销</td>
</tr>
<tr>
<td>CPU</td>
<td>–显示CPU相关开销信息</td>
</tr>
<tr>
<td>IPC</td>
<td>–显示发送和接收相关开销信息</td>
</tr>
<tr>
<td>MEMORY</td>
<td>–显示内存相关开销信息</td>
</tr>
<tr>
<td>PAGE FAULTS</td>
<td>–显示页面错误相关开销信息</td>
</tr>
<tr>
<td>SOURCE</td>
<td>–显示和Source_function，Source_file，Source_line相关的开销信息</td>
</tr>
<tr>
<td>SWAPS</td>
<td>–显示交换次数相关开销的信息</td>
</tr>
</tbody></table>
<p>例如，想要查看cpu和io开销可以执行命令：<br>mysql&gt; SHOW profile CPU,BLOCK IO  FOR query 2;</p>
<h2 id="一般流程"><a href="#一般流程" class="headerlink" title="一般流程"></a>一般流程</h2><ol>
<li>set profiling=1; //打开profile分析</li>
<li>run your sql1;</li>
<li>run your sql2;</li>
<li>show profiles;    //查看sql1,sql2的语句分析</li>
<li>SHOW profile CPU,BLOCK IO  FOR query 1; //查看CPU、IO消耗</li>
<li>set profiling=0; //关闭profile分析</li>
</ol>
]]></content>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql-performance-schema</title>
    <url>/blogs/mysql-performance-schema.html</url>
    <content><![CDATA[<h1 id="MySQL-Performance-Schema"><a href="#MySQL-Performance-Schema" class="headerlink" title="MySQL - Performance Schema"></a>MySQL - Performance Schema</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢 ~~</p>
]]></content>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解 MySQL - 页结构</title>
    <url>/blogs/mysql-page-principle.html</url>
    <content><![CDATA[<h1 id="深入理解-MySQL-页结构"><a href="#深入理解-MySQL-页结构" class="headerlink" title="深入理解 MySQL - 页结构"></a>深入理解 MySQL - 页结构</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢 ~~</p>
<h5 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h5><ul>
<li><p><a href="https://blog.csdn.net/chuixue24/article/details/120266026">mysql原理一：innodb存储基本单位页结构及B+tree</a></p>
</li>
<li><p><a href="https://blog.csdn.net/king13127/article/details/115545972">深入理解mysql-第五章 InnoDB记录存储结构-页结构</a></p>
</li>
</ul>
]]></content>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL 查询缓存</title>
    <url>/blogs/mysql-query-cache.html</url>
    <content><![CDATA[<h1 id="MySQL-查询缓存"><a href="#MySQL-查询缓存" class="headerlink" title="MySQL 查询缓存"></a>MySQL 查询缓存</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢 ~~</p>
<p>如果开启了查询缓存。在进行 SQL查询的时候，MySQL 会先去内存中，查看之前是否查询过这条语句。<br>如果之前执行过，就会将执行结果缓存下来，以键值对的形势存储，key 是查询语句。value 是查询结果。</p>
<p>但是大多数情况下，查询缓存弊大于利。</p>
<p>因为对一个表进行的更新操作的时候，</p>
<h5 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h5><p>-<a href="https://mp.weixin.qq.com/s/_EXXmciNdgXswSVzKyO4xg">MySQL为什么取消了Query Cache</a></p>
]]></content>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解 MySQL binlog redolog</title>
    <url>/blogs/mysql-redolog-binlog.html</url>
    <content><![CDATA[<h1 id="深入理解-MySQL-binlog-redolog"><a href="#深入理解-MySQL-binlog-redolog" class="headerlink" title="深入理解 MySQL binlog redolog"></a>深入理解 MySQL binlog redolog</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢 ~~</p>
<h5 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h5><ul>
<li><a href="https://www.cnblogs.com/wupeixuan/p/11734501.html">MySQL 日志系统之 redo log 和 binlog </a></li>
</ul>
]]></content>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解 MySQL 事务机制</title>
    <url>/blogs/mysql-transacation.html</url>
    <content><![CDATA[<h1 id="深入理解-MySQL-事务机制"><a href="#深入理解-MySQL-事务机制" class="headerlink" title="深入理解 MySQL 事务机制"></a>深入理解 MySQL 事务机制</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢 ~~</p>
<p>数据库事务</p>
<p>ACID</p>
<h5 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a><strong>原子性</strong></h5><p>一个事务中的所有操作，要么全部成功，要么全部失败。如果事务中存在异常或者错误，所有操作就会回滚到事务执行之前的状态，就像事务没有执行一样。</p>
<h5 id="一致性"><a href="#一致性" class="headerlink" title="一致性"></a><strong>一致性</strong></h5><h5 id="隔离性"><a href="#隔离性" class="headerlink" title="隔离性"></a><strong>隔离性</strong></h5><p>事务与事务之间在操作同样的数据时，不要看见彼此所做的修改。只能看到数据被修改之前或者之后的状态。</p>
<h5 id="持久性"><a href="#持久性" class="headerlink" title="持久性"></a><strong>持久性</strong></h5><p>事务成功执行，所做的操作会被持久化，数据库重启后，仍然能恢复。</p>
<h5 id="脏读-修改"><a href="#脏读-修改" class="headerlink" title="脏读 修改"></a>脏读 修改</h5><p>读未提交，读到别人修改的内容。</p>
<h5 id="不可重复读-更新"><a href="#不可重复读-更新" class="headerlink" title="不可重复读 更新"></a>不可重复读 更新</h5><p>读到了 更新的内容</p>
<h5 id="幻读-插入"><a href="#幻读-插入" class="headerlink" title="幻读 插入"></a>幻读 插入</h5><h5 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h5><ul>
<li><p><a href="https://mp.weixin.qq.com/s/soZM_zsL7IBoZ2r5FyU_4g">@Transactional 注解失效的 8 大场景，看看你都遇到过几个？</a></p>
</li>
<li><p><a href="https://segmentfault.com/a/1190000040890911">MySQL事务的隔离级别与并发问题</a></p>
</li>
<li><p><a href="https://blog.csdn.net/h2604396739/article/details/86518943">幻读、间隙锁、行锁、next-key lock、加锁规则、间隙锁导致的死锁、隔离级别设置、for update的理解</a></p>
</li>
<li><p><a href="https://www.cnblogs.com/549294286/p/5433318.html">事务的隔离级别和mysql事务隔离级别修改</a></p>
</li>
</ul>
]]></content>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>minify-html 使用详解</title>
    <url>/blogs/npm-minify-html.html</url>
    <content><![CDATA[<h1 id="minify-html-使用详解"><a href="#minify-html-使用详解" class="headerlink" title="minify-html 使用详解"></a>minify-html 使用详解</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢~~</p>
<p>plugin GitHub 地址：<a href="https://github.com/kangax/html-minifier">minify-html</a></p>
<p><code>npm</code> 安装</p>
<pre class=" language-npm"><code class="language-npm">npm install html-minifier</code></pre>
]]></content>
      <tags>
        <tag>性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式 - 建造者模式</title>
    <url>/blogs/pattern-design-builder.html</url>
    <content><![CDATA[<h1 id="设计模式-建造者模式"><a href="#设计模式-建造者模式" class="headerlink" title="设计模式 - 建造者模式"></a>设计模式 - 建造者模式</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢~~</p>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>将一个复杂对象的构造与它的表示分离，使同样的构建过程可以创建不同的表示，这样的设计模式被称为建造者模式。</p>
<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ol>
<li>各个具体的建造者相互独立，有利于系统的扩展。</li>
<li>客户端不必知道产品内部的组成细节，便于控制细节风险。</li>
</ol>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ol>
<li>产品的组成部分必须相同，这限制了其使用范围。</li>
<li>如果产品的内部变化复杂，该模式会增加很多的建造者类。</li>
</ol>
<p>建造者模式和工厂模式的关注的不同，建造者模式注重零部件的组装过程，而工厂方法模式更注重零部件的创建过程，但两者可以结合使用。</p>
<h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><h3 id="产品角色"><a href="#产品角色" class="headerlink" title="产品角色"></a>产品角色</h3><p>他是包含多个组成部分的复杂对象，是由建造者来创建其各个组成部件。</p>
<h3 id="抽象建造者"><a href="#抽象建造者" class="headerlink" title="抽象建造者"></a>抽象建造者</h3><p>它是一个包含创建产品各个子部件的抽象方法的 接口，通常还包含一个返回复杂产品的方法。</p>
<h3 id="具体建造者"><a href="#具体建造者" class="headerlink" title="具体建造者"></a>具体建造者</h3><p>实现 Builder 接口，完成复杂产品的各个部件的具体创建方法。</p>
<h3 id="指挥者"><a href="#指挥者" class="headerlink" title="指挥者"></a>指挥者</h3><p>它调用建造者对象中的部件构造与装配方法完成复杂对象的创建，在指挥者中不涉及具体产品的信息。</p>
<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><ol>
<li>创建的对象较复杂，由多个部件构成，各部件面临着复杂的变化，但构件间的建造顺序是稳定的。</li>
<li>创建复杂对象的算法独立于该对象的组成部分已经它们的装配方式，即产品的构建过程和最终的表示是独立的。</li>
</ol>
<h3 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h3><p>建造者模式在应用过程中可以根据需要改变，如果创建的产品种类只有一种，只需要一个具体的建造者，这是可以省略掉抽象建造者，甚至可以忽略指挥者的角色。</p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2>]]></content>
      <tags>
        <tag>pattern-design</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式</title>
    <url>/blogs/pattern-design-prinpicle.html</url>
    <content><![CDATA[<h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢 ~~</p>
<h5 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h5><ul>
<li><a href="https://blog.csdn.net/weixin_43122090/article/details/105462226"></a></li>
</ul>
]]></content>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>性能基础 - 上线文切换 - 自愿与非自愿</title>
    <url>/blogs/performance-basic-context-switch.html</url>
    <content><![CDATA[<h1 id="性能基础-上线文切换-自愿与非自愿"><a href="#性能基础-上线文切换-自愿与非自愿" class="headerlink" title="性能基础 - 上线文切换 - 自愿与非自愿"></a>性能基础 - 上线文切换 - 自愿与非自愿</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢 ~~</p>
<blockquote>
<p>上下文切换，存在自愿切换与非自愿切换</p>
</blockquote>
<p>首先，得来说说什么是上下文切换（Context Swith），简单来说就是CPU在干着活呢，被打断了，于是从一个进程或线程切换到另一个进程或线程。当然在切换之前会保存当前正在运行的进程或线程的状态，以备切回来可以接着执行。</p>
<p>那CPU为什么要切换呢？有几种情况：</p>
<p>CPU不足。至于为什么不足，那情况就多了去了。<br>进程或线程自己需要切换。</p>
<p>典型的就是进程或线程自己要等待条件满足或这一段的活干完了，于是把CPU释放了。<br>针对第1种情况：我们得先知道为什么CPU不足。这里也分为两种情况：</p>
<pre><code>1.1 自己消耗的。

1.2 别人消耗的。</code></pre>
<p>针对1.1的情况，那就解决自身的问题。</p>
<p>针对1.2的情况，那就解决别人的问题。</p>
<p>针对第2种情况：那就必然是要分析自己进程或线程的问题了。</p>
]]></content>
      <tags>
        <tag>性能基础</tag>
      </tags>
  </entry>
  <entry>
    <title>performance-base-core-processor</title>
    <url>/blogs/performance-basic-core-processor.html</url>
    <content><![CDATA[<h1 id="性能基础-CPU、物理核、逻辑核概念与关系"><a href="#性能基础-CPU、物理核、逻辑核概念与关系" class="headerlink" title="性能基础 - CPU、物理核、逻辑核概念与关系"></a>性能基础 - CPU、物理核、逻辑核概念与关系</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢 ~~</p>
<h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><h5 id="1-CPU-CentralProcessingUnit"><a href="#1-CPU-CentralProcessingUnit" class="headerlink" title="1. CPU( CentralProcessingUnit):"></a>1. CPU( CentralProcessingUnit):</h5><p>中央处理单元，CPU不等于物理核，更不等于逻辑核。</p>
<h5 id="2-物理核-physical-core-processor"><a href="#2-物理核-physical-core-processor" class="headerlink" title="2. 物理核(physical core/processor):"></a>2. 物理核(physical core/processor):</h5><p>可以看的到的，真实的cpu核，有独立的电路元件以及L1,L2缓存，可以独立地执行指令。</p>
<h5 id="3-逻辑核-logical-core-processor，LCPU"><a href="#3-逻辑核-logical-core-processor，LCPU" class="headerlink" title="3. 逻辑核( logical core/processor，LCPU):"></a>3. 逻辑核( logical core/processor，LCPU):</h5><p>在同一个物理核内，逻辑层面的核。（比喻，像动画片一样，我们看到的“动画”，其实是一帧一帧静态的画面，24帧/s连起来就骗过了人类的眼睛，看起来像动起来一样。逻辑核也一样，物理核通过高速运算，让应用程序以为有两个cpu在运算）。</p>
<h5 id="4-超线程-Hyper-threading，-HT-："><a href="#4-超线程-Hyper-threading，-HT-：" class="headerlink" title="4. 超线程( Hyper-threading， HT)："></a>4. 超线程( Hyper-threading， HT)：</h5><p>超线程可以在一个逻辑核等待指令执行的间隔(等待从cache或内存中获取下一条指令)，把时间片分配到另一个逻辑核。高速在这两个逻辑核之间切换，让应用程序感知不到这个间隔，误认为自己是独占了一个核。</p>
<p>关系: 一个CPU可以有多个物理核。如果开启了超线程，一个物理核可以分成n个逻辑核，n为超线程的数量。</p>
<h2 id="逻辑CPU与虚拟CPU"><a href="#逻辑CPU与虚拟CPU" class="headerlink" title="逻辑CPU与虚拟CPU"></a>逻辑CPU与虚拟CPU</h2><p>虚拟 CPU 术语与逻辑 CPU 相当，但它增加了一定的细微差别：它在计算虚拟化方面更加框架化。它指的是从底层主机硬件映射到虚拟机的那些 cpus，可以是物理或逻辑 cpus，HT。通常，来自主机服务器的1个逻辑 cpu映射到虚拟机内的1个虚拟cpu，因此它们几乎是类似的术语。</p>
]]></content>
      <tags>
        <tag>性能基础</tag>
      </tags>
  </entry>
  <entry>
    <title>performance-interface-optimize</title>
    <url>/blogs/performance-interface-optimize.html</url>
    <content><![CDATA[<h1 id="性能优化-接口性能优化方法"><a href="#性能优化-接口性能优化方法" class="headerlink" title="性能优化 - 接口性能优化方法"></a>性能优化 - 接口性能优化方法</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢 ~~</p>
<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><h3 id="前端优化"><a href="#前端优化" class="headerlink" title="前端优化"></a>前端优化</h3><p>分布式文件系统、CDN 等</p>
<h3 id="后端优化"><a href="#后端优化" class="headerlink" title="后端优化"></a>后端优化</h3><ul>
<li>优化程序逻辑、代码</li>
<li>耗时操作考虑异步处理 </li>
<li>恰当使用缓存</li>
<li>SQL优化</li>
<li>数据量比较大，批量操作数据入库</li>
<li>JVM 优化</li>
<li>压缩传输内容</li>
</ul>
<p>考虑使用文件/MQ等其他方式暂存，异步再落地DB</p>
<p>跟产品讨论需求最恰当，最舒服的实现方式</p>
<h3 id="代码优化"><a href="#代码优化" class="headerlink" title="代码优化"></a>代码优化</h3><p>代码优化的效果非常显著，比如for循环次数过多、作了很多无谓的条件判断、相同逻辑重复多次等。</p>
<h3 id="SQL-优化"><a href="#SQL-优化" class="headerlink" title="SQL 优化"></a>SQL 优化</h3><p>加索引</p>
<p>避免返回不必要的数据</p>
<p>优化sql结构</p>
<p>分库分表</p>
<p>读写分离</p>
]]></content>
      <tags>
        <tag>性能基础</tag>
      </tags>
  </entry>
  <entry>
    <title>reactive api 功能</title>
    <url>/blogs/reactive-api.html</url>
    <content><![CDATA[<h1 id="reactive-api-功能"><a href="#reactive-api-功能" class="headerlink" title="reactive api 功能"></a>reactive api 功能</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢~~</p>
<p>An API for asynchronous programming<br>with observable streams</p>
<ul>
<li>asynchronous programming</li>
<li>observable streams</li>
<li>API</li>
</ul>
<h2 id="java-的异步编程"><a href="#java-的异步编程" class="headerlink" title="java 的异步编程"></a>java 的异步编程</h2><pre class=" language-java"><code class="language-java"> <span class="token comment" spellcheck="true">// 获取一个执行器</span>
        ExecutorService executor <span class="token operator">=</span> Executors<span class="token punctuation">.</span><span class="token function">newCachedThreadPool</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        Future<span class="token operator">&lt;</span>String<span class="token operator">></span> future <span class="token operator">=</span> executor<span class="token punctuation">.</span><span class="token function">submit</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Callable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// 提交之后立即执行</span>
            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"running"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">3000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span> <span class="token string">"complete"</span><span class="token punctuation">;</span>
        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
       <span class="token comment" spellcheck="true">// 处理其他任务</span>
        <span class="token keyword">try</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
          <span class="token comment" spellcheck="true">// 调用future.get() 获取执行结果(这居然是一个可能阻塞的调用！)</span>
            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>future<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>

        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">finally</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
            executor<span class="token punctuation">.</span><span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
</code></pre>
<p>JDK8中，提供了CompletableFuture，这是对Future的扩展功能，帮助我们简化异步编程的复杂性，提供了函数式编程的能力，可以通过回调的方式处理计算结果，并且提供了转换和组合的方法。这也说明Java一直在想办法提供更好的异步操作模型。</p>
<p>讲到这里，我们应该能够了解，无论是编程语言还是系统，所能提供的异步编程模型都存在一些问题：</p>
<p>某些模型不完善，依然会导致阻塞的风险<br>对于线程，同步等问题的抽象不够，导致无法应对复杂业务逻辑<br>在异步代码的编写上，也不如同步代码那样容易理解</p>
<h2 id="RxJava-技术背景"><a href="#RxJava-技术背景" class="headerlink" title="RxJava 技术背景"></a>RxJava 技术背景</h2><h2 id="RxJava-能带来什么"><a href="#RxJava-能带来什么" class="headerlink" title="RxJava 能带来什么"></a>RxJava 能带来什么</h2><ul>
<li>优点</li>
<li>缺点</li>
</ul>
<h2 id="RxJava-的开源实践"><a href="#RxJava-的开源实践" class="headerlink" title="RxJava 的开源实践"></a>RxJava 的开源实践</h2><h2 id="RxJava-的事例"><a href="#RxJava-的事例" class="headerlink" title="RxJava 的事例"></a>RxJava 的事例</h2><ul>
<li>ReactiveX首先从Iterable这种Pull模型的身上推导出了更容易支持异步的Push模型。</li>
<li>基于Push,打造出了数据流的概念，Everything is stream</li>
<li>基于数据流设计简洁高效的异步操作流程</li>
</ul>
<p>Reactor 在 SpringBoot 中的应用</p>
]]></content>
      <tags>
        <tag>响应式编程</tag>
      </tags>
  </entry>
  <entry>
    <title>高并发 - 缓存问题处理方案</title>
    <url>/blogs/problems-cache.html</url>
    <content><![CDATA[<h1 id="高并发-缓存问题处理方案"><a href="#高并发-缓存问题处理方案" class="headerlink" title="高并发 - 缓存问题处理方案"></a>高并发 - 缓存问题处理方案</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢~~</p>
<h5 id="特别说明-1"><a href="#特别说明-1" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 PR 谢谢~~</p>
<h2 id="一-缓存雪崩"><a href="#一-缓存雪崩" class="headerlink" title="一. 缓存雪崩"></a>一. 缓存雪崩</h2><h3 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h3><h5 id="可能是因为数据未加载到缓存中，或者缓存同一时间大面积的失效，从而导致所有请求都去查数据库，导致数据库CPU和内存负载过高，甚至宕机。"><a href="#可能是因为数据未加载到缓存中，或者缓存同一时间大面积的失效，从而导致所有请求都去查数据库，导致数据库CPU和内存负载过高，甚至宕机。" class="headerlink" title="可能是因为数据未加载到缓存中，或者缓存同一时间大面积的失效，从而导致所有请求都去查数据库，导致数据库CPU和内存负载过高，甚至宕机。"></a>可能是因为数据未加载到缓存中，或者缓存同一时间大面积的失效，从而导致所有请求都去查数据库，导致数据库CPU和内存负载过高，甚至宕机。</h5><h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><ol>
<li>均匀分布 key 的过期时间。防止同一时间 key 大面试失效</li>
</ol>
<p>2 种策略（同时使用）：</p>
<h5 id="1-对缓存做高可用，防止缓存宕机"><a href="#1-对缓存做高可用，防止缓存宕机" class="headerlink" title="1) .对缓存做高可用，防止缓存宕机"></a>1) .对缓存做高可用，防止缓存宕机</h5><ul>
<li>分析用户行为，然后失效时间均匀分布。或者在失效时间的基础上再加1~5分钟的随机数。</li>
</ul>
<h5 id="2-使用断路器，如果缓存宕机，为了防止系统全部宕机，限制部分流量进入-DB，保证部分可用，其余的请求返回断路器的默认值。"><a href="#2-使用断路器，如果缓存宕机，为了防止系统全部宕机，限制部分流量进入-DB，保证部分可用，其余的请求返回断路器的默认值。" class="headerlink" title="2). 使用断路器，如果缓存宕机，为了防止系统全部宕机，限制部分流量进入 DB，保证部分可用，其余的请求返回断路器的默认值。"></a>2). 使用断路器，如果缓存宕机，为了防止系统全部宕机，限制部分流量进入 DB，保证部分可用，其余的请求返回断路器的默认值。</h5><ul>
<li> 加锁计数（即限制并发的数量，可以用 semphore）或者起一定数量的队列来避免缓存失效时大量请求并发到数据库。但这种方式会降低吞吐量。</li>
</ul>
<ol start="3">
<li>按照 key 加锁，同一时间只允许一个请求去读库。</li>
</ol>
<h2 id="二-缓存穿透"><a href="#二-缓存穿透" class="headerlink" title="二. 缓存穿透"></a>二. 缓存穿透</h2><h3 id="定义：-1"><a href="#定义：-1" class="headerlink" title="定义："></a>定义：</h3><h5 id="用户查询一个不存在的-key，redis-没有，请求打到缓存中。"><a href="#用户查询一个不存在的-key，redis-没有，请求打到缓存中。" class="headerlink" title="用户查询一个不存在的 key，redis 没有，请求打到缓存中。"></a>用户查询一个不存在的 key，redis 没有，请求打到缓存中。</h5><ol>
<li>如果查询数据库也为空，直接设置一个默认值存放到缓存，这样第二次到缓冲中获取就有值了，而不会继续访问数据库。设置一个过期时间或者当有值的时候将缓存中的值替换掉即可。</li>
<li>可以给key设置一些格式规则，然后查询之前先过滤掉不符合规则的Key。</li>
<li>如果查询数据库也为空的时候，把这个 key 缓存起来，这样在下次请求过来的时候就可以走缓存了。当然这种方案有个弊端，那就是请求过来的 key 必须大部分相同，如果受到攻击的话，每次的 key 肯定不是固定的，只要不固定 key，这个方案就没用。</li>
<li>可以用缓存 key 的规则来做一些限制，当然这种只适合特定的使用场景，比如我们查询商品信息，我们把商品信息存储在 Mongodb 中，Mongodb 有一个 _id 是自动生成的，它有一定的生成规则，如果是直接根据 id 查询商品，在查询之前我们可以对这个 id 做认证，看是不是符合规范，当不符合的时候就直接返回默认的值，既不用去缓存中查询，也不用操作数据库了。这种方案可以解决一部分问题，使用场景比较少。</li>
<li>利用布隆过滤器来实现对缓存 key 的检验，需要将所有可能缓存的数据 Hash 到一个足够大的 BitSet 中，在缓存之前先从布隆过滤器中判断这个 key 是否存在，然后做对应的操作<br>d<h2 id="三-缓存击穿"><a href="#三-缓存击穿" class="headerlink" title="三. 缓存击穿"></a>三. 缓存击穿</h2></li>
</ol>
<h3 id="定义：-2"><a href="#定义：-2" class="headerlink" title="定义："></a>定义：</h3><h5 id="如果网站并发访问高，一个缓存如果失效，可能出现多个进程同时查询DB，同时设置缓存的情况，如果并发确实很大，这也可能造成DB压力过大，还有缓存频繁更新的问题"><a href="#如果网站并发访问高，一个缓存如果失效，可能出现多个进程同时查询DB，同时设置缓存的情况，如果并发确实很大，这也可能造成DB压力过大，还有缓存频繁更新的问题" class="headerlink" title="如果网站并发访问高，一个缓存如果失效，可能出现多个进程同时查询DB，同时设置缓存的情况，如果并发确实很大，这也可能造成DB压力过大，还有缓存频繁更新的问题"></a>如果网站并发访问高，一个缓存如果失效，可能出现多个进程同时查询DB，同时设置缓存的情况，如果并发确实很大，这也可能造成DB压力过大，还有缓存频繁更新的问题</h5><ol>
<li>对缓存查询加锁，如果 <code>KEY</code> 不存在，就加锁，然后查DB入缓存，然后解锁；其他进程如果发现有锁就等待，然后等解锁后返回数据或者进入DB查询。</li>
</ol>
<h2 id="四-缓存预热"><a href="#四-缓存预热" class="headerlink" title="四. 缓存预热"></a>四. 缓存预热</h2><h3 id="目的就是在系统上线前，将数据加载到缓存中。解决思路"><a href="#目的就是在系统上线前，将数据加载到缓存中。解决思路" class="headerlink" title="目的就是在系统上线前，将数据加载到缓存中。解决思路"></a>目的就是在系统上线前，将数据加载到缓存中。解决思路</h3><ol>
<li>数据量不大的话，在系统启动的时候直接加载。</li>
<li>自己写个简单的缓存预热程序。</li>
</ol>
<h2 id="五-缓存算法"><a href="#五-缓存算法" class="headerlink" title="五. 缓存算法"></a>五. 缓存算法</h2><ol>
<li>FIFO算法：First in First out，先进先出。原则：一个数据最先进入缓存中，则应该最早淘汰掉。也就是说，当缓存满的时候，应当把最先进入缓存的数据给淘汰掉。</li>
<li>LFU算法：Least Frequently Used，最不经常使用算法。</li>
<li>LRU算法：Least Recently Used，近期最少使用算法。</li>
<li>LRU和LFU的区别。LFU算法是根据在一段时间里数据项被使用的次数选择出最少使用的数据项，即根据使用次数的差异来决定。而LRU是根据使用时间的差异来决定的</li>
</ol>
<h4 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h4><p><a href="http://c.biancheng.net/view/5555.html">http://c.biancheng.net/view/5555.html</a></p>
<p>-<a href="https://alsritter.icu/posts/56acbef6/">Redis 缓存读写策略设计及常见问题</a></p>
]]></content>
      <tags>
        <tag>分布式基础</tag>
      </tags>
  </entry>
  <entry>
    <title>响应式编程简介</title>
    <url>/blogs/reactive-introduce.html</url>
    <content><![CDATA[<h1 id="响应式编程简介"><a href="#响应式编程简介" class="headerlink" title="响应式编程简介"></a>响应式编程简介</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢~~</p>
<h2 id="响应式宣言"><a href="#响应式宣言" class="headerlink" title="响应式宣言"></a>响应式宣言</h2><p><a href="https://www.reactivemanifesto.org/zh-CN">https://www.reactivemanifesto.org/zh-CN</a></p>
<h5 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h5>]]></content>
      <tags>
        <tag>响应式编程</tag>
      </tags>
  </entry>
  <entry>
    <title>响应式编程 - ReactiveX 模型推导</title>
    <url>/blogs/reactive-reduction.html</url>
    <content><![CDATA[<h1 id="响应式编程-ReactiveX-模型推导"><a href="#响应式编程-ReactiveX-模型推导" class="headerlink" title="响应式编程 - ReactiveX 模型推导"></a>响应式编程 - ReactiveX 模型推导</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢~~</p>
<h1 id="响应式编程-ReactiveX-模型推导-1"><a href="#响应式编程-ReactiveX-模型推导-1" class="headerlink" title="响应式编程  - ReactiveX 模型推导"></a>响应式编程  - ReactiveX 模型推导</h1><p>从 迭代器推导出</p>
<p>Java 中的异步编程</p>
<ol>
<li>使用 CallBack</li>
</ol>
<blockquote>
<p>流程复杂，嵌套时，会导致 回调地狱</p>
</blockquote>
<ol start="2">
<li>使用 Future</li>
</ol>
<blockquote>
<p>JDK 8 之前，Future 为阻塞模型，JDK 8  后新增 API CompletableFuture 类，这个类是 Future 也是一个 CompletionStage，CompletableFuture 支持 then 的级联操作。提供可操作的功能相对简单。</p>
</blockquote>
]]></content>
      <tags>
        <tag>响应式编程</tag>
      </tags>
  </entry>
  <entry>
    <title>reactor-mono</title>
    <url>/blogs/reactor-mono.html</url>
    <content><![CDATA[<h1 id="Reactor"><a href="#Reactor" class="headerlink" title="Reactor"></a>Reactor</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢~~</p>
<p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢~~</p>
<p>Reactor 有两种类型：Flux<T> 和 Mono<T>。Flux 类似于 RxJava 的 Observable，它可以触发零到多个事件，并根据实际情况结束处理或触发错误。我们可以从返回类型获知一个方法：发射并忘记或者请求等待(Mono)/处理一个包含多个数据项的流(Flux)。</p>
<p>Flux 和 Mono 主要用途是在于把对象合并到更高层次的流中，搜易一般来说，在现有代码上应用响应式模式，不应该把 <code>long getCount()</code> 这样的方法转换成 <code>Mono&lt;Long&gt; getCount()</code>。</p>
<p><img src="https://docs.spring.io/spring-framework/docs/5.0.0.BUILD-SNAPSHOT/spring-framework-reference/html/images/webflux-overview.png" alt="SpringWebFlux"></p>
<h3 id="Router-Function"><a href="#Router-Function" class="headerlink" title="Router Function"></a>Router Function</h3><p>对标注 <code>@Controller</code>,<code>@RequestMapping</code> 等标准的 Spring MVC 注解，提供一套函数式风格的 API，用于创建 Router， Handler 和 Filter。</p>
<h3 id="WebFlux"><a href="#WebFlux" class="headerlink" title="WebFlux"></a>WebFlux</h3><p>核心组件，协调上下游各个组件，提供响应式编程支持。可以平衡请求或响应率，即，响应堵塞时，会同时堵塞请求。</p>
<p>背压，是一种通过传输（通知）接受者可以消费多少元素来调节生产的机制（消费决定生产）；TCP 具有字节抽象而不是逻辑元素抽象。我们通常所说的背压控制是控制向网络发送/接收的逻辑原件的数量。即使 TCP 有自己的流控制，这个流控制仍然是字节而不是逻辑元素。</p>
<h3 id="Reactive-Streams"><a href="#Reactive-Streams" class="headerlink" title="Reactive Streams"></a>Reactive Streams</h3><p>一种支持背压（Backpressure）的异步数据流处理标准，主流实现有 RxJava 和 Reator，Spring WebFlux 默认继承的是 Reactor。（Reactor 类似于 RxJava 2.0）</p>
<h2 id="Flux"><a href="#Flux" class="headerlink" title="Flux"></a>Flux</h2><p>file.getName(),null,InspectPlanListExportTO.class,getExcelType(),null</p>
<p>existInspectStandard != null &amp;&amp; inspectStandard.getInspectStandardPO().getId() != existInspectStandard.getId()</p>
<p> for (InspectPlanProcedureRelationPO inspectPlanProcedureRelationPO : this.inspectPlanProcedureRelationPOs) {<br>            inspectPlanProcedureRelationPO.setInspectPlanId(this.inspectPlanPO.getId());<br>        }</p>
]]></content>
      <tags>
        <tag>响应式编程</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解 Redis - AOF 与 RDB</title>
    <url>/blogs/redis-aof-rdb.html</url>
    <content><![CDATA[<h1 id="深入理解-Redis-AOF-与-RDB"><a href="#深入理解-Redis-AOF-与-RDB" class="headerlink" title="深入理解 Redis - AOF 与 RDB"></a>深入理解 Redis - AOF 与 RDB</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢 ~~</p>
<h2 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h2><p>redis 的 rdb  持久化  也可以通过手动方式触发，执行 save 和 bgsave</p>
<p>生成 dump.rdb 二进制文件</p>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ol>
<li><p>相对于 aof 的每次命令追加，持久化到磁盘， rdb 速度更快，rdb 在使用 bgsave 时，fork 进程，进行 copyonwrite</p>
</li>
<li><p>保存了 redis 在某个时间点的数据。这种方式适用于 备份和 容灾。</p>
</li>
</ol>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>rdb 针对的是对整个数据集进行备份，比如 3 min 更新一次 rdb 文件，如果在上一次和下一次之间发生 redis 问题，就会丢失这中间的缓存数据。</p>
<h3 id="copyonwrite"><a href="#copyonwrite" class="headerlink" title="copyonwrite"></a>copyonwrite</h3><p>原理：</p>
<p>主进程 fork 子进程后，此时，内核会把内存页设置为 read-only,然后子进程的地址空间指向主进程，此时子进程共享主进程内存数据。<br>当有线程进行数据写入时 此时由于 fork 子进程不参与写逻辑，cup 检测到当前页只读，发送异常中断，中断例程中，内核会把触发异常的页复制一份。<br>redis 将数据集写入到新的 dump.rdb 文件中，替换旧的的 rdb 文件，并删除旧的 rdb 文件。</p>
<h2 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h2><p>aof 的持久化操作时，每一次的 redis 修改，命令都会通过 write 函数追加到  appendonly.aof 文件中。可通过配置 </p>
<pre class=" language-javascript"><code class="language-javascript">appendfsync yes</code></pre>
<p>来开启全程的 aof 持久化。此功能默认关闭。当redis 意外关闭时，可以通过 aof 来重放数据，恢复到 redis 关闭之前的状态。</p>
<pre class=" language-javascript"><code class="language-javascript">appendfsync yes
appendfsync always     #每次有数据修改发生时都会写入AOF文件。
appendfsync everysec   #每秒钟同步一次，该策略为AOF的缺省策略。</code></pre>
<p>原理</p>
<p>redis 执行 fork 命令，创建一个子进程。此时父进程会将新数据放到一个内存缓存中，子进程将命令追加咋 aof 文件末尾。当子进程完成工作后，<br>会发送一个信号给父进程告诉父进程任务完成，此时父进程会将内存缓存中的数据追加到 aof 文件中，然后会用新的 aof 文件替换旧的 aof 文件。</p>
<p>优点</p>
<ul>
<li>aof 会进行文件压缩。(AOF BGREWRITEAOF 重写)</li>
</ul>
<p>缺点</p>
<h5 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h5><ul>
<li><p><a href="https://segmentfault.com/a/1190000018388385">RDB 和 AOF 持久化的原理是什么？我应该用哪一个？它们的优缺点？</a></p>
</li>
<li><p><a href="https://blog.csdn.net/ctwctw/article/details/105147277?utm_source=app&app_version=4.21.1&utm_source=app">彻底搞懂Redis持久化之RDB原理</a></p>
</li>
<li><p><a href="https://segmentfault.com/a/1190000021559677">redis的rdb和aof两种持久化机制原理及优缺点</a></p>
</li>
</ul>
]]></content>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解 Redis -  位图BitMap</title>
    <url>/blogs/redis-bitmap.html</url>
    <content><![CDATA[<h1 id="深入理解-Redis-位图BitMap"><a href="#深入理解-Redis-位图BitMap" class="headerlink" title="深入理解 Redis -  位图BitMap"></a>深入理解 Redis -  位图BitMap</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢 ~~</p>
<p>底层使用的是 byte 数组</p>
<h5 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h5><ul>
<li><a href="https://www.jianshu.com/p/4b30536ad936">Redis bitmap数据结构</a></li>
</ul>
]]></content>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis 缓存问题</title>
    <url>/blogs/redis-cache.html</url>
    <content><![CDATA[<h1 id="Redis-缓存"><a href="#Redis-缓存" class="headerlink" title="Redis 缓存"></a>Redis 缓存</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢 ~~</p>
<p>Redis 缓存方案  业务设计</p>
<ol>
<li><p>Cache-Aisde</p>
</li>
<li><p>Read-Through</p>
</li>
</ol>
<p>3.</p>
<ol start="4">
<li></li>
</ol>
<p>Redis 缓存更新方案  Redis 自身设计</p>
<ol>
<li><p>LRU/LFU/FIFO 算法</p>
</li>
<li><p>超时剔除</p>
</li>
<li><p>主动更新</p>
</li>
</ol>
<h5 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h5><ul>
<li><a href="https://alsritter.icu/posts/56acbef6/">Redis 缓存读写策略设计及常见问题</a></li>
</ul>
]]></content>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis Cluster 实战经验</title>
    <url>/blogs/redis-cluster-1.html</url>
    <content><![CDATA[<h1 id="Redis-Cluster-实战经验"><a href="#Redis-Cluster-实战经验" class="headerlink" title="Redis Cluster 实战经验"></a>Redis Cluster 实战经验</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢 ~~</p>
<p>当前文章目前只做同类型经验文章收集。</p>
<h5 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h5><ul>
<li><a href="https://my.oschina.net/vivotech/blog/5281502">Redis大集群扩容性能优化实践</a></li>
</ul>
]]></content>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解 Redis - 主从复制</title>
    <url>/blogs/redis-cluster.html</url>
    <content><![CDATA[<h1 id="深入理解-Redis-主从复制"><a href="#深入理解-Redis-主从复制" class="headerlink" title="深入理解 Redis - 主从复制"></a>深入理解 Redis - 主从复制</h1><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢~~</p>
<blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href="https://starriers.github.com/">Starrier</a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 PR 谢谢~~</p>
<blockquote>
<ol>
<li><p><a href="">深入理解 Redis - 简单动态字符串</a></p>
</li>
<li><p><a href="">深入理解 Redis - 跳跃表</a></p>
</li>
<li><p><a href="">深入理解 Redis - 压缩列表</a></p>
</li>
<li><p><a href="">深入理解 Redis - 字典</a></p>
</li>
<li><p><a href="">深入理解 Redis - 整数集合</a></p>
</li>
<li><p><a href="">深入理解 Redis - QuickList</a></p>
</li>
<li><p><a href="">深入理解 Redis - Stream</a></p>
</li>
<li><p><a href="">深入理解 Redis - LUA</a></p>
</li>
<li><p><a href="">深入理解 Redis - GEO </a></p>
</li>
<li><p><a href="">深入理解 Redis - HyperLogLog</a></p>
</li>
<li><p><a href="">深入理解 Redis - 内存模型</a></p>
</li>
<li><p><a href="">深入理解 Redis - 持久化</a></p>
</li>
<li><p><a href="">深入理解 Redis - 主从复制</a></p>
</li>
<li><p><a href="">深入理解 Redis - 哨兵和集群</a></p>
</li>
<li><p><a href="">深入理解 Redis - 事务</a></p>
</li>
</ol>
</blockquote>
<h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><ol>
<li><a href="https://xie.infoq.cn/article/843e1968b57d597c1149dda00">【Redis 干货领域】帮你完全搞定 Cluster 原理（架构篇）</a></li>
</ol>
]]></content>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解 Redis Hash 数据结构</title>
    <url>/blogs/redis-hash.html</url>
    <content><![CDATA[<h1 id="深入理解-Redis-Hash-数据结构"><a href="#深入理解-Redis-Hash-数据结构" class="headerlink" title="深入理解 Redis Hash 数据结构"></a>深入理解 Redis Hash 数据结构</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢 ~~</p>
<p>Redis Hash 的扩容原理</p>
<p>Redis 的 hash 有个字典，字典中 dicth 的数据结构，里面有 ht[0] 和 ht[1]。<br>初始时，当前数据都存储在 ht[0]，h[1] 在进行扩容时使用。当数据需要扩容的时候。h[1] 在进行扩容缩容的时候，大小为当前 ht[0] 中已使用数据长度的最小 2 次冥的值。<br>Hash 扩容使用的是 渐进式 rehash。</p>
<p>Redis 的扩容阶段，分散在 reids 的每一次操作中。<br>首先，为 ht[1] 预分配空间。</p>
<h5 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h5><ul>
<li><a href="https://cloud.tencent.com/developer/article/1873205">redis中hash扩容过程</a></li>
</ul>
]]></content>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>redis-hyperloglog</title>
    <url>/blogs/redis-hyperloglog.html</url>
    <content><![CDATA[<h1 id="Redis-HyperLogLog"><a href="#Redis-HyperLogLog" class="headerlink" title="Redis - HyperLogLog"></a>Redis - HyperLogLog</h1><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢~~</p>
<p>HyperLogLog 使用动态字符串存储数据，为了区别普通的 SDS，在头部固定了字节 <code>HYLL</code></p>
<p>HyperLogLog 底层数据结构</p>
<pre class=" language-c"><code class="language-c"><span class="token keyword">struct</span> hllhdr <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 固定值 HYLL</span>
    <span class="token keyword">char</span> magic<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">/* "HYLL" */</span>
    <span class="token comment" spellcheck="true">// 编码格式 HLL_DENSE 和 HLL_SPARSE</span>
    uint8_t encoding<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">/* HLL_DENSE or HLL_SPARSE. */</span>
    uint8_t notused<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/* Reserved for future use, must be zero. */</span>
    uint8_t card<span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* Cached cardinality, little endian. */</span>
    uint8_t registers<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/* Data bytes. */</span>
<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">;</span></code></pre>
<p>HLL  存储分为两部分：hllhdr 和 registers。</p>
<ul>
<li><p>registers: 用来存储组数据</p>
</li>
<li><p>hllhdr: 为 HLL 的头部信息，</p>
</li>
</ul>
<p>其中 <code>encoding</code> 来标识使用的编码，可以简单理解为空分组较多时使用稀疏编码存储，空分组较少时使用密集编码存储，内部计算使用 <code>HLL_RAW</code> 编码，因为数据总是增加的，所以一般只存在稀疏编码转为密集编码。</p>
<h2 id="HLL-的命名"><a href="#HLL-的命名" class="headerlink" title="HLL 的命名"></a>HLL 的命名</h2><ul>
<li>pfadd</li>
<li>pfcount</li>
<li>pfmerge</li>
</ul>
<h3 id="PFADD"><a href="#PFADD" class="headerlink" title="PFADD"></a>PFADD</h3><ol>
<li>功能：</li>
</ol>
<p>pfadd 用来讲一个或多个元素添加到指定的 HLL 中。Redis 不保存元素本身，而是将元素散列后，找到对应分组并比较计数值，如果大于旧值则更新，反之则不更新。</p>
<blockquote>
<p>PFADD key element [element element …]</p>
</blockquote>
<ol start="2">
<li>原理</li>
</ol>
<p>将所有元素添加到之地当的 HLL 数据结构中。如果对应的近似基数发生变化，则返回 <code>1</code>，否则返回 <code>0</code>。如果指定的 key 不存在，则会自动创建一个空的 HLL 数据结构并执行添加操作。不知道 element 的情况下，如果 key 不存在，也会创建一个新的 HLL 数据结构并返回 <code>1</code>。否则什么也不做，并返回 <code>0</code>。</p>
<ol start="3">
<li>源码实现原理</li>
</ol>
<p>TODO 待处理</p>
<h5 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h5><ul>
<li><a href="https://juejin.cn/book/6844733724618129422/section/6844733724706209805">应用 4：四两拨千斤 —— HyperLogLog</a></li>
</ul>
]]></content>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis 简介</title>
    <url>/blogs/redis-introduction.html</url>
    <content><![CDATA[<h1 id="Redis-简介"><a href="#Redis-简介" class="headerlink" title="Redis 简介"></a>Redis 简介</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢 ~~</p>
<ol>
<li><p><a href="">简单动态字符串</a></p>
</li>
<li><p><a href="">链表</a></p>
</li>
<li><p><a href="">字典</a></p>
</li>
<li><p><a href="">跳跃表</a></p>
</li>
<li><p><a href="">整数集合</a></p>
</li>
<li><p><a href="">压缩列表</a></p>
</li>
<li><p><a href="">对象</a></p>
</li>
<li><p><a href="">Redis IO 线程模型</a></p>
</li>
<li><p><a href="">Redis 与 MySQL 读写一致性</a></p>
</li>
<li><p><a href="">Redis 哨兵</a></p>
</li>
<li><p><a href="">Redis TTL 原理</a></p>
</li>
<li><p><a href="">Redis 内存淘汰策略，缓存过期策略</a></p>
</li>
</ol>
<p>redis 单线程架构</p>
<p>redis 为什么那么快</p>
<ol>
<li>基于内存</li>
<li>非阻塞 IO，Redis使用epoll作为I/O多路复用技术的实现，再加上Redis自身的事件处理模型将epoll中的连接、读写、关闭都转换为事件，不在网络I/O上浪费过多的时间</li>
<li>单线程，避免了线程切换产生的额外消耗</li>
</ol>
<h5 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h5><ul>
<li><a href="https://bbs.huaweicloud.com/blogs/262901">【Redis破障之路】三：Redis单线程架构</a></li>
</ul>
]]></content>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>redis-lua 简介</title>
    <url>/blogs/redis-lua.html</url>
    <content><![CDATA[<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢~~</p>
<p>从 Redis 2.6.0 版本开始，通过内置的 Lua 解释器，可以使用 EVAL 命令对 Lua 脚本进行求值。</p>
<p>script 参数是一段 Lua  脚本程序，它会被运行在 Redis 服务器上下文中，这段脚本不必(也不应该)定义为一个 Lua 函数。</p>
<p>numkeys 参数用于指定键名参数的个数。</p>
<h1 id="Redis-Lua-简介"><a href="#Redis-Lua-简介" class="headerlink" title="Redis  Lua 简介"></a>Redis  Lua 简介</h1><p><code>redis.call()</code>; 将返回一个错误给调用者</p>
<p><code>redis.pcall()</code>: 将捕获的错误以 <code>LUA</code> 表的形式返回。</p>
<h2 id="Redis-Lua-优势"><a href="#Redis-Lua-优势" class="headerlink" title="Redis Lua 优势"></a><code>Redis Lua</code> 优势</h2><p>1.减少网络开销：本来 5 次的网络请求操作，可以用一个请求完成，原先 5 次请求的逻辑放在 <code>redis</code> 服务器上完成。使用脚本，减少了网络往返时延。</p>
<p>2.原子操作：<code>Redis</code> 会将整个脚本作为一个整体执行，中间不会被其他命令插入。</p>
<p>3.复用：客户端发送的脚本会永久存储在 <code>Redis</code> 中，意味着其他客户端可以复用这一脚本而不需要使用代码完成同样的逻辑。</p>
<h2 id="Redis-注意事项"><a href="#Redis-注意事项" class="headerlink" title="Redis 注意事项"></a>Redis 注意事项</h2><ol>
<li><p><code>Lua</code> 无返回值导致阻塞时，整个 <code>Redis</code> 不可用。</p>
</li>
<li><p><code>Lua</code> 实现核心内容即可，言简意赅。</p>
</li>
<li><p><code>Lua</code> 中不应该存在常量 <code>Key</code>，这样会导致每次执行时都会在脚本字典中新建一个条目，应该使用全局变量数组 <code>KEYS</code> 和 <code>ARGV</code>, <code>KEYS</code> 和 <code>ARGV</code> 的索引都从 <code>1</code> 开始。</p>
</li>
<li><p>传递给 <code>lua</code> 脚本的键列表应该包括可能会读取或者写入的所有键。传入全部的键使得在使用各种分片或者集群技术时，其他软件可以在应用层检查所有的数据是不是都在同一个分片里面。<br>另外集群版 <code>redis</code> 也会对将要访问的 <code>key</code> 进行检查，如果不在同一个服务器里面，那么 <code>redis</code> 将会返回一个错误。<br>（决定使用集群版之前应该考虑业务拆分），参数列表无所谓。。</p>
</li>
<li><p><code>lua</code> 和 <code>redis</code> 命令，事务一样都是原子，的已经进行了数据写入的 <code>lua</code> 脚本将无法中断，只能使用 <code>SHUTDOWN NOSAVE</code> 杀死 <code>Redis</code> 服务器。</p>
</li>
</ol>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul>
<li><p><a href="https://juejin.cn/post/6844903697034510343">深入分析 Redis Lua 脚本运行原理</a></p>
</li>
<li><p><a href="https://www.cnblogs.com/chopper-poet/p/14172485.html">redis源码学习之lua执行原理</a></p>
</li>
</ul>
]]></content>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis 主从复制原理</title>
    <url>/blogs/redis-master-slave-replication.html</url>
    <content><![CDATA[<h1 id="Redis-主从复制原理"><a href="#Redis-主从复制原理" class="headerlink" title="Redis 主从复制原理"></a>Redis 主从复制原理</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢 ~~</p>
<p>在 <code>Redis</code> 的持久化中曾提到，<code>Redis</code> 高可用的方案包括持久化、主从复制（及读写分离）、哨兵和集群。其中持久化侧重解决的是 <code>Redis</code> 数据的单机备份问题（从内存到硬盘的备份）；而主从复制则侧重解决数据的多机热备。此外，主从复制还可以实现负载均衡和故障恢复。</p>
<p><code>Redis</code> 的主从复制，主要有两种方式</p>
<ul>
<li>通过在配置文件 <code>redis.conf</code> 中设置 <code>slaveof</code> 方式（永久）</li>
<li>直接在客户端执行 <code>slaveof ip port</code> 的方式（临时）；</li>
</ul>
<h2 id="主从一致性原理"><a href="#主从一致性原理" class="headerlink" title="主从一致性原理"></a>主从一致性原理</h2><h3 id="全量复制"><a href="#全量复制" class="headerlink" title="全量复制"></a>全量复制</h3><p>使用消息队列检测消息是否丢失时，我们无法处理不知道消息已经丢失的情况。一般而言，一个新的系统刚刚上线，各方面都不太稳定，需要一个磨合期，这个时候，特别需要监控到你的系统中是否有消息丢失的情况。</p>
<p>分布式链路追踪系统，使用类似的追踪系统可以很方便地追踪每一条消息。如果没有这样的追踪系统，也可以使用其他方式，来检查是否有消息丢失的情况。</p>
<p>我们可以利用消息队列的有序性来验证是否有消息丢失。原理非常简单，在 <code>Producer</code> 端，我们给每个发出的消息附加一个连续递增的序号，然后在 <code>Consumer</code> 端来检查这个序号的连续性。如果没有消息丢失，<code>Consumer</code> 收到消息的序号必然是连续递增的，或者说收到的消息，其中的序号必然是上一条消息的序号 +1。如果检测到序号不连续，那就是丢消息了。还可以通过缺失的序号来确定丢失的是哪条消息，方便进一步排查原因。</p>
<p>大多数消息队列的客户端都支持拦截器机制，你可以利用这个拦截器机制，在 <code>Producer</code> 发送消息之前的拦截器中将序号注入到消息中，在 <code>Consume</code>r 收到消息的拦截器中检测序号的连续性，这样实现的好处是消息检测的代码不会侵入到你的业务代码中，待你的系统稳定后，也方便将这部分检测的逻辑关闭或者删除。如果是在一个分布式系统中实现这个检测方法，有几个问题需要你注意。首先，像 <code>Kafka</code> 和 <code>RocketMQ</code> 这样的消息队列，它是不保证在 <code>Topic</code> 上的严格顺序的，只能保证分区上的消息是有序的，所以我们在发消息的时候必须要指定分区，并且，在每个分区单独检测消息序号的连续性。如果你的系统中 <code>Producer</code> 是多实例的，由于并不好协调多个 <code>Producer</code> 之间的发送顺序，所以也需要每个 <code>Producer</code> 分别生成各自的消息序号，并且需要附加上 <code>Producer</code> 的标识，在 <code>Consumer</code> 端按照每个 <code>Producer</code> 分别来检测序号的连续性。<code>Consumer</code> 实例的数量最好和分区数量一致，做到 <code>Consumer</code> 和分区一一对应，这样会比较方便地在 <code>Consumer</code> 内检测消息序号的连续性。</p>
<h2 id="一-主从复制-概述"><a href="#一-主从复制-概述" class="headerlink" title="一. 主从复制 - 概述"></a>一. 主从复制 - 概述</h2><h3 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h3><p>是指将一台 <code>Redis</code> 服务器的数据，复制到其他的 <code>Redis</code> 服务器。前者称为主节点(master)，后者称为从节点(slave)；数据的复制是单向的，只能由主节点到从节点。</p>
<p>默认情况下，每台 <code>Redis</code> 服务器都是主节点；且一个主节点可以有多个从节点(或没有从节点)，但一个从节点只能有一个主节点。</p>
<h3 id="主从复制的作用"><a href="#主从复制的作用" class="headerlink" title="主从复制的作用"></a>主从复制的作用</h3><h4 id="1-数据冗余："><a href="#1-数据冗余：" class="headerlink" title="1. 数据冗余："></a>1. 数据冗余：</h4><p>主从复制实现了数据的热备份，是持久化之外的一种数据冗余方式。</p>
<h4 id="2-故障恢复："><a href="#2-故障恢复：" class="headerlink" title="2. 故障恢复："></a>2. 故障恢复：</h4><p>当主节点出现问题时，可以由从节点提供服务，实现快速的故障恢复；实际上是一种服务的冗余。</p>
<h4 id="3-负载均衡："><a href="#3-负载均衡：" class="headerlink" title="3. 负载均衡："></a>3. 负载均衡：</h4><p>在主从复制的基础上，配合读写分离，可以由主节点提供写服务，由从节点提供读服务（即写Redis数据时应用连接主节点，读Redis数据时应用连接从节点），分担服务器负载；尤其是在写少读多的场景下，通过多个从节点分担读负载，可以大大提高Redis服务器的并发量。</p>
<h4 id="4-高可用基石："><a href="#4-高可用基石：" class="headerlink" title="4. 高可用基石："></a>4. 高可用基石：</h4><p>除了上述作用以外，主从复制还是哨兵和集群能够实施的基础，因此说主从复制是Redis高可用的基础。</p>
<h2 id="主从复制-原理"><a href="#主从复制-原理" class="headerlink" title="主从复制 - 原理"></a>主从复制 - 原理</h2><p>主从复制过程大体可以分为3个阶段：</p>
<ul>
<li>连接建立阶段（即准备阶段）</li>
<li>数据同步阶段</li>
<li>命令传播阶段</li>
</ul>
<h3 id="连接建立"><a href="#连接建立" class="headerlink" title="连接建立"></a>连接建立</h3><p>1：保存主节点信息</p>
<p>从节点服务器内部维护了两个字段，即masterhost和masterport字段，用于存储主节点的ip和port信息。</p>
<p>需要注意的是，slaveof是异步命令，从节点完成主节点ip和port的保存后，向发送slaveof命令的客户端直接返回OK，实际的复制操作在这之后才开始进行。</p>
<p>2：建立 <code>socket</code>连接</p>
<p>从节点每秒1次调用复制定时函数replicationCron()，如果发现了有主节点可以连接，便会根据主节点的ip和port，创建socket连接。如果连接成功，则：</p>
<p>从节点：为该socket建立一个专门处理复制工作的文件事件处理器，负责后续的复制工作，如接收RDB文件、接收命令传播等。</p>
<p>主节点：接收到从节点的socket连接后（即accept之后），为该socket创建相应的客户端状态，并将从节点看做是连接到主节点的一个客户端，后面的步骤会以从节点向主节点发送命令请求的形式来进行。</p>
<p>3：发送ping命令</p>
<p>从节点成为主节点的客户端之后，发送ping命令进行首次请求，目的是：检查socket连接是否可用，以及主节点当前是否能够处理请求。</p>
<p>从节点发送ping命令后，可能出现3种情况：</p>
<p>（1）返回pong：说明socket连接正常，且主节点当前可以处理请求，复制过程继续。</p>
<p>（2）超时：一定时间后从节点仍未收到主节点的回复，说明socket连接不可用，则从节点断开socket连接，并重连。</p>
<p>（3）返回pong以外的结果：如果主节点返回其他结果，如正在处理超时运行的脚本，说明主节点当前无法处理命令，则从节点断开socket连接，并重连。</p>
<p>4：身份验证</p>
<p>如果从节点中设置了masterauth选项，则从节点需要向主节点进行身份验证；没有设置该选项，则不需要验证。从节点进行身份验证是通过向主节点发送auth命令进行的，auth命令的参数即为配置文件中的masterauth的值。</p>
<p>如果主节点设置密码的状态，与从节点masterauth的状态一致（一致是指都存在，且密码相同，或者都不存在），则身份验证通过，复制过程继续；如果不一致，则从节点断开socket连接，并重连。</p>
<h3 id="数据同步阶段"><a href="#数据同步阶段" class="headerlink" title="数据同步阶段"></a>数据同步阶段</h3><p>主从节点之间的连接建立以后，便可以开始进行数据同步，该阶段可以理解为从节点数据的初始化。具体执行的方式是：从节点向主节点发送 <code>psync</code> 命令（Redis2.8以前是sync命令），开始同步。</p>
<p>数据同步阶段是主从复制最核心的阶段，根据主从节点当前状态的不同，可以分为全量复制和部分复制，下面会有一章专门讲解这两种复制方式以及 <code>psync</code> 命令的执行过程，这里不再详述。</p>
<p>需要注意的是，在数据同步阶段之前，从节点是主节点的客户端，主节点不是从节点的客户端；而到了这一阶段及以后，主从节点互为客户端。原因在于：在此之前，主节点只需要响应从节点的请求即可，不需要主动发请求，而在数据同步阶段和后面的命令传播阶段，主节点需要主动向从节点发送请求（如推送缓冲区中的写命令），才能完成复制。</p>
<h3 id="命令传播阶段"><a href="#命令传播阶段" class="headerlink" title="命令传播阶段"></a>命令传播阶段</h3><p>数据同步阶段完成后，主从节点进入命令传播阶段；在这个阶段主节点将自己执行的写命令发送给从节点，从节点接收命令并执行，从而保证主从节点数据的一致性。</p>
<p>在命令传播阶段，除了发送写命令，主从节点还维持着心跳机制：<code>PING和REPLCONF ACK</code>。由于心跳机制的原理涉及部分复制，因此将在介绍了部分复制的相关内容后单独介绍该心跳机制。</p>
<p>延迟与不一致</p>
<p>需要注意的是，命令传播是异步的过程，即主节点发送写命令后并不会等待从节点的回复；因此实际上主从节点之间很难保持实时的一致性，延迟在所难免。数据不一致的程度，与主从节点之间的网络状况、主节点写命令的执行频率、以及主节点中的repl-disable-tcp-nodelay配置等有关。</p>
<p><code>repl-disable-tcp-nodelay no</code>：</p>
<p>该配置作用于命令传播阶段，控制主节点是否禁止与从节点的 <code>TCP_NODELAY</code>；默认 <code>no</code>，即不禁止 <code>TCP_NODELAY</code>。当设置为 <code>yes</code> 时，<code>TCP</code> 会对包进行合并从而减少带宽，但是发送的频率会降低，从节点数据延迟增加，一致性变差；具体发送频率与 <code>Linux</code> 内核的配置有关，默认配置为40ms。当设置为no时，TCP会立马将主节点的数据发送给从节点，带宽增加但延迟变小。</p>
<p>一般来说，只有当应用对Redis数据不一致的容忍度较高，且主从节点之间网络状况不好时，才会设置为yes；多数情况使用默认值no。</p>
<p>数据同步阶段</p>
<blockquote>
<p>全量复制和部分复制</p>
</blockquote>
<h3 id="全量复制-1"><a href="#全量复制-1" class="headerlink" title="全量复制"></a>全量复制</h3><p>Redis通过psync命令进行全量复制的过程如下：</p>
<p>（1）从节点判断无法进行部分复制，向主节点发送全量复制的请求；或从节点发送部分复制的请求，但主节点判断无法进行部分复制；具体判断过程需要在讲述了部分复制原理后再介绍。</p>
<p>（2）主节点收到全量复制的命令后，执行 <code>bgsave</code>，在后台生成 <code>RDB</code> 文件，并使用一个缓冲区（称为复制缓冲区）记录从现在开始执行的所有写命令</p>
<p>（3）主节点的 <code>bgsave</code> 执行完成后，将 <code>RDB</code> 文件发送给从节点；从节点首先清除自己的旧数据，然后载入接收的 <code>RDB</code> 文件，将数据库状态更新至主节点执行 <code>bgsave</code> 时的数据库状态</p>
<p>（4）主节点将前述复制缓冲区中的所有写命令发送给从节点，从节点执行这些写命令，将数据库状态更新至主节点的最新状态</p>
<p>（5）如果从节点开启了 <code>AOF</code>，则会触发 <code>bgrewriteaof</code> 的执行，从而保证 <code>AOF</code> 文件更新至主节点的最新状态</p>
<p>从节点在载入主节点的数据之前要先将老数据清除；从节点在同步完数据后，调用了 <code>bgrewriteaof</code>。</p>
<p>通过全量复制的过程可以看出，全量复制是非常重型的操作：</p>
<p>（1）主节点通过 <code>bgsave</code> 命令 <code>fork</code> 子进程进行 <code>RDB</code> 持久化，该过程是非常消耗 <code>CPU</code>、内存(页表复制)、硬盘 <code>IO</code> 的；关于 <code>bgsave</code> 的性能问题，可以参考 深入学习Redis（2）：持久化</p>
<p>（2）主节点通过网络将 <code>RDB</code> 文件发送给从节点，对主从节点的带宽都会带来很大的消耗</p>
<p>（3）从节点清空老数据、载入新 <code>RDB</code> 文件的过程是阻塞的，无法响应客户端的命令；如果从节点执行 <code>bgrewriteaof</code>，也会带来额外的消耗</p>
<h3 id="部分复制"><a href="#部分复制" class="headerlink" title="部分复制"></a>部分复制</h3><p>（1）复制偏移量<br>主节点和从节点分别维护一个复制偏移量（offset），代表的是主节点向从节点传递的字节数；主节点每次向从节点传播N个字节数据时，主节点的offset增加N；从节点每次收到主节点传来的N个字节数据时，从节点的offset增加N。</p>
<p>offset用于判断主从节点的数据库状态是否一致：如果二者offset相同，则一致；如果offset不同，则不一致，此时可以根据两个offset找出从节点缺少的那部分数据。例如，如果主节点的offset是1000，而从节点的offset是500，那么部分复制就需要将offset为501-1000的数据传递给从节点。而offset为501-1000的数据存储的位置，就是下面要介绍的复制积压缓冲区。</p>
<p>（2）复制积压缓冲区<br>复制积压缓冲区是由主节点维护的、固定长度的、先进先出(FIFO)队列，默认大小1MB；当主节点开始有从节点时创建，其作用是备份主节点最近发送给从节点的数据。注意，无论主节点有一个还是多个从节点，都只需要一个复制积压缓冲区。</p>
<p>在命令传播阶段，主节点除了将写命令发送给从节点，还会发送一份给复制积压缓冲区，作为写命令的备份；除了存储写命令，复制积压缓冲区中还存储了其中的每个字节对应的复制偏移量（offset）。由于复制积压缓冲区定长且是先进先出，所以它保存的是主节点最近执行的写命令；时间较早的写命令会被挤出缓冲区。</p>
<p>由于该缓冲区长度固定且有限，因此可以备份的写命令也有限，当主从节点offset的差距过大超过缓冲区长度时，将无法执行部分复制，只能执行全量复制。反过来说，为了提高网络中断时部分复制执行的概率，可以根据需要增大复制积压缓冲区的大小(通过配置repl-backlog-size)；例如如果网络中断的平均时间是60s，而主节点平均每秒产生的写命令(特定协议格式)所占的字节数为100KB，则复制积压缓冲区的平均需求为6MB，保险起见，可以设置为12MB，来保证绝大多数断线情况都可以使用部分复制。</p>
<p>从节点将offset发送给主节点后，主节点根据offset和缓冲区大小决定能否执行部分复制：</p>
<p>如果offset偏移量之后的数据，仍然都在复制积压缓冲区里，则执行部分复制；<br>如果offset偏移量之后的数据已不在复制积压缓冲区中（数据已被挤出），则执行全量复制。<br>（3）服务器运行ID(runid)<br>每个Redis节点(无论主从)，在启动时都会自动生成一个随机ID(每次启动都不一样)，由40个随机的十六进制字符组成；runid用来唯一识别一个Redis节点。通过info Server命令，可以查看节点的runid：</p>
<p>主从节点初次复制时，主节点将自己的runid发送给从节点，从节点将这个runid保存起来；当断线重连时，从节点会将这个runid发送给主节点；主节点根据runid判断能否进行部分复制：</p>
<p>如果从节点保存的runid与主节点现在的runid相同，说明主从节点之前同步过，主节点会继续尝试使用部分复制(到底能不能部分复制还要看offset和复制积压缓冲区的情况)；<br>如果从节点保存的runid与主节点现在的runid不同，说明从节点在断线前同步的Redis节点并不是当前的主节点，只能进行全量复制。</p>
]]></content>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>redis-multip-thread-model</title>
    <url>/blogs/redis-multip-thread-model.html</url>
    <content><![CDATA[<h1 id="Redis-多线程模型"><a href="#Redis-多线程模型" class="headerlink" title="Redis 多线程模型"></a>Redis 多线程模型</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢 ~~</p>
<h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><ul>
<li><a href="https://mp.weixin.qq.com/s/04wrExb50YSsX7Rtq6WBbg">Redis 新特性篇：多线程模型解读</a></li>
</ul>
]]></content>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis 性能问题</title>
    <url>/blogs/redis-performance.html</url>
    <content><![CDATA[<h1 id="Redis-性能问题"><a href="#Redis-性能问题" class="headerlink" title="Redis 性能问题"></a>Redis 性能问题</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢 ~~</p>
<h5 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h5><ul>
<li><a href="https://my.oschina.net/u/4526289/blog/5379857">分析内部运行机制，教你解决Redis性能问题</a></li>
</ul>
]]></content>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解 Redis - QuickList</title>
    <url>/blogs/redis-quicklist.html</url>
    <content><![CDATA[<h1 id="深入理解-Redis-QuickList"><a href="#深入理解-Redis-QuickList" class="headerlink" title="深入理解 Redis - QuickList"></a>深入理解 Redis - QuickList</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢 ~~</p>
]]></content>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解 RDB 持久化</title>
    <url>/blogs/redis-rdb.html</url>
    <content><![CDATA[<h1 id="深入理解-RDB-持久化"><a href="#深入理解-RDB-持久化" class="headerlink" title="深入理解 RDB 持久化"></a>深入理解 RDB 持久化</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢 ~~</p>
<pre class=" language-c"><code class="language-c">def <span class="token function">SAVE</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
   # 创建 RDB 文件
   <span class="token function">rdbSave</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

def <span class="token function">BGSAVE</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
   # 创建子进程
   pid <span class="token operator">=</span>  <span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
   <span class="token keyword">if</span> pid <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>
         # 子进程负责创建 RDB 文件
         <span class="token function">rdbSave</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
         # 完成后向父进程发送信号
         <span class="token function">signal_parent</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
   elif pid <span class="token operator">></span> <span class="token number">0</span> <span class="token punctuation">:</span>
         # 父进程继续处理命令请求，并通过轮询等待子进程的信号
         <span class="token function">handle_request_and_wait_signal</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
   <span class="token keyword">else</span><span class="token punctuation">:</span>
         # 处理出错情况
         <span class="token function">handle_fork_error</span><span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre>
<p>AOF  的更新频率通常比 RDB 文件更新频率高，所以：</p>
<ul>
<li><p>如果服务器开启了 AOF  持久化功能，那么服务器会优先使用 AOF  文件来还原数据库状态。</p>
</li>
<li><p>只有 AOF 持久化功能处于关闭状态时，服务器才会使用 RDB 文件来还原数据库状态。</p>
</li>
</ul>
<h5 id="SAVE，BGSAVE-执行命令的时候程序运行状态"><a href="#SAVE，BGSAVE-执行命令的时候程序运行状态" class="headerlink" title="SAVE，BGSAVE 执行命令的时候程序运行状态"></a>SAVE，BGSAVE 执行命令的时候程序运行状态</h5><p>SAVE：</p>
<p>由于 SAVE 执行过程时，进程是阻塞的，此时 Redis 所有的操作都会被阻塞，知道 SAVE 命令执行结束。</p>
<p>BGSAVE：</p>
<p>由于 BGSAVE 执行持久化的过程是由子进程执行的，所以此时 Redis 的核心线程仍可以运行。只是此时，SAVE，BGSAVE，BGREWRITEAOF 命令会有所不同</p>
<ul>
<li><p>SAVE 命令会被拒绝执行，防止另个命令同时调用 rdb 文件写入，产生竞态条件。</p>
</li>
<li><p>BGSAVE 命令也会背拒绝执行，两个命令同时调用 rdb 文件写入，也会产生竞态条件。</p>
</li>
<li><p>BGREWRITE  和 BGSAVE 同一时刻只会有一个执行，另一个需要等待上个命令执行完成才能继续执行。</p>
</li>
</ul>
<p><strong>服务器载入 RBD文件时，会一直阻塞，知道当前命令执行的操作完成为止。</strong></p>
<h4 id="自动保存间隔。"><a href="#自动保存间隔。" class="headerlink" title="自动保存间隔。"></a>自动保存间隔。</h4><p>Redis 的结构中 有  saveParams 和 Direct。saveparams 中保存了时间错和修改书。</p>
<p>使用 SAVE 命令指定参数。</p>
<p>eg. 每 200 s 修改了 100 次，则触发一次 RDB。<br>save 200 100</p>
<p>直到 上一次的时间到当前 &gt;= 200 s 并且修改数超过了 100 次才会进行一次 RDB。</p>
<p>Redis  RDB 文件结构</p>
<p>“REDIS” db_version  database EOF check_sum</p>
<p>REDIS 表示这是一个 Redis 文件。</p>
<p>db_version 代表了当前 rdb 文件的版本号。</p>
<p>database 表示的是数据库信息</p>
<p>check_sum 校验和，用于在 Redis 载入 RDB 文件时，查看文件是否完整。</p>
<h5 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h5><ul>
<li><a href=""></a></li>
</ul>
]]></content>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解 redis - 简单动态字符串</title>
    <url>/blogs/redis-sds.html</url>
    <content><![CDATA[<h1 id="深入理解-redis-简单动态字符串"><a href="#深入理解-redis-简单动态字符串" class="headerlink" title="深入理解 redis - 简单动态字符串"></a>深入理解 redis - 简单动态字符串</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢 ~~</p>
]]></content>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解 Redis 哨兵机制</title>
    <url>/blogs/redis-sentinel.html</url>
    <content><![CDATA[<h1 id="深入理解-Redis-哨兵机制"><a href="#深入理解-Redis-哨兵机制" class="headerlink" title="深入理解 Redis 哨兵机制"></a>深入理解 Redis 哨兵机制</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢 ~~</p>
<p>Redis 哨兵机制的主要作用是监控 Redis 的运行状态，并在主节点发生故障的时候可以第一时间进行<br>主库的切换。实现故障转义，保障系统的可用性。</p>
<p>哨兵具备以下能力：</p>
<ul>
<li><p>监控 </p>
</li>
<li><p>自动切换主库</p>
</li>
<li><p>通知</p>
</li>
</ul>
<h5 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h5><ul>
<li><a href="https://juejin.cn/post/6844903663362637832#heading-26">深入剖析Redis系列(二) - Redis哨兵模式与高可用集群</a></li>
</ul>
]]></content>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解 Redis 字符串</title>
    <url>/blogs/redis-string.html</url>
    <content><![CDATA[<h1 id="深入理解-Redis-字符串"><a href="#深入理解-Redis-字符串" class="headerlink" title="深入理解 Redis 字符串"></a>深入理解 Redis 字符串</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢 ~~</p>
<p>简单动态字符串</p>
<p>SDS 在 Redis 中的作用 </p>
<ol>
<li>实现字符串对象</li>
<li>替代 char* 类型的数据</li>
</ol>
<p>C 语言中，字符串的实现是以结尾为 \0 的 char 数组实现的。</p>
<h5 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h5><ul>
<li><a href="https://redisbook.readthedocs.io/en/latest/internal-datastruct/sds.html">简单动态字符串</a></li>
</ul>
]]></content>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis 事务</title>
    <url>/blogs/redis-transcation.html</url>
    <content><![CDATA[<h1 id="Redis-事务"><a href="#Redis-事务" class="headerlink" title="Redis 事务"></a>Redis 事务</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢 ~~</p>
<h5 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h5><ul>
<li><a href=""></a></li>
</ul>
]]></content>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解 Redis TTL 原理</title>
    <url>/blogs/redis-ttl.html</url>
    <content><![CDATA[<h1 id="深入理解-Redis-TTL-原理"><a href="#深入理解-Redis-TTL-原理" class="headerlink" title="深入理解 Redis TTL 原理"></a>深入理解 Redis TTL 原理</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢 ~~</p>
<h5 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h5><ul>
<li><a href="https://www.jianshu.com/p/53083f5f2ddc">redis TTL实现原理</a></li>
</ul>
]]></content>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解 Redis zset</title>
    <url>/blogs/redis-zset.html</url>
    <content><![CDATA[<h1 id="深入理解-Redis-zset"><a href="#深入理解-Redis-zset" class="headerlink" title="深入理解 Redis zset"></a>深入理解 Redis zset</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢 ~~</p>
<h5 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h5><ul>
<li><a href=""></a></li>
</ul>
]]></content>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>RSocket 简介</title>
    <url>/blogs/rsocket-introduce.html</url>
    <content><![CDATA[<h1 id="RSocket-简介"><a href="#RSocket-简介" class="headerlink" title="RSocket 简介"></a>RSocket 简介</h1><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢~~</p>
<blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 PR 谢谢~~</p>
<p>响应式reactive是Java中高效应用的下一个前沿，但它目前主要有两个障碍：数据访问和网络。RSocket是一种新的第7层语言无关的应用网络协议（解决后者），它由Facebook，Netifi和Pivotal等工程师开发，提供Java，JavaScript，C ++和Kotlin等实现，RSocket与Servlet并不是同类的产品。</p>
]]></content>
      <tags>
        <tag>响应式编程</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解 Rx 背压</title>
    <url>/blogs/rx-backpress.html</url>
    <content><![CDATA[<h1 id="深入理解-Rx-背压"><a href="#深入理解-Rx-背压" class="headerlink" title="深入理解 Rx 背压"></a>深入理解 Rx 背压</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢 ~~</p>
<h5 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h5><ul>
<li><a href="https://xie.infoq.cn/article/3d4475f65498d7bee27456672">深入讲解 RxJava 响应式编程框架，背压问题的几种应对模式</a></li>
</ul>
]]></content>
      <tags>
        <tag>Rx</tag>
      </tags>
  </entry>
  <entry>
    <title>响应式编程 - RxJava - Disposable</title>
    <url>/blogs/rxJava-disposable.html</url>
    <content><![CDATA[<h1 id="响应式白城-RxJava-Disposable"><a href="#响应式白城-RxJava-Disposable" class="headerlink" title="响应式白城 - RxJava - Disposable"></a>响应式白城 - RxJava - Disposable</h1><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢~~</p>
<h3 id="1-Disposable-有两个方法"><a href="#1-Disposable-有两个方法" class="headerlink" title="1. Disposable 有两个方法"></a>1. Disposable 有两个方法</h3><pre class=" language-java"><code class="language-java"> <span class="token comment" spellcheck="true">// 取消订阅</span>
 <span class="token keyword">void</span> <span class="token function">dispose</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token comment" spellcheck="true">// 判断订阅状态</span>
 <span class="token keyword">boolean</span> <span class="token function">isDisposed</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p>在 RxJava 中，在数据流结束后，如果不取消订阅，则可能会导致内存泄露。我们可以通过使用 Disposable 来取消订阅关系。在 RxJava 中，<code>onError</code> 和 <code>onComplete</code> 中，都存在 <code>this::dispose</code>。这也是为什么  <code>onError</code> 和 <code>onComplete</code> 不能同时存在的原因。</p>
<h3 id="2-CompositeDisposable"><a href="#2-CompositeDisposable" class="headerlink" title="2. CompositeDisposable"></a>2. CompositeDisposable</h3><p>CompositeDisposable 类是一个存放 Disposable 的 hash 容器，对放入其中的 disposable 会将其解除订阅。如果在添加是，容器内已经被解除，那么新增的会被阻断。</p>
<p>在使用的时候，我们使用容器，调用，<code>add </code>或者 <code>addAll</code>，容器退出时，调用 <code>clear</code> 方法即可将容器内的关系解除。</p>
]]></content>
      <tags>
        <tag>响应式编程</tag>
      </tags>
  </entry>
  <entry>
    <title>RxJava 简介</title>
    <url>/blogs/rxjava-introduce.html</url>
    <content><![CDATA[<h1 id="RxJava-简介"><a href="#RxJava-简介" class="headerlink" title="RxJava 简介"></a>RxJava 简介</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢 ~~</p>
<h2 id="RxJava-操作符概述"><a href="#RxJava-操作符概述" class="headerlink" title="RxJava 操作符概述"></a>RxJava 操作符概述</h2><ul>
<li>创建操作符</li>
<li>变化操作符</li>
<li>过滤操作符</li>
<li>组合操作符</li>
<li>辅助操作符</li>
<li>错误处理操作符</li>
<li>布尔操作符</li>
<li>条件操作符</li>
<li>转换操作符</li>
</ul>
<h3 id="一-创建操作符"><a href="#一-创建操作符" class="headerlink" title="一. 创建操作符"></a>一. 创建操作符</h3><h4 id="1-create"><a href="#1-create" class="headerlink" title="1. create"></a>1. create</h4><h4 id="2-from"><a href="#2-from" class="headerlink" title="2. from"></a>2. from</h4><h4 id="3-just"><a href="#3-just" class="headerlink" title="3. just"></a>3. just</h4><h4 id="4-interval"><a href="#4-interval" class="headerlink" title="4. interval"></a>4. interval</h4><h4 id="5-range"><a href="#5-range" class="headerlink" title="5. range"></a>5. range</h4><h4 id="6-repeat"><a href="#6-repeat" class="headerlink" title="6. repeat"></a>6. repeat</h4><h3 id="二-变换操作符"><a href="#二-变换操作符" class="headerlink" title="二. 变换操作符"></a>二. 变换操作符</h3><h4 id="1-map"><a href="#1-map" class="headerlink" title="1. map"></a>1. map</h4><h4 id="2-flatMap"><a href="#2-flatMap" class="headerlink" title="2. flatMap"></a>2. flatMap</h4><h4 id="3-concatMap"><a href="#3-concatMap" class="headerlink" title="3. concatMap"></a>3. concatMap</h4><h4 id="4-cast"><a href="#4-cast" class="headerlink" title="4. cast"></a>4. cast</h4><h4 id="5-flatMapIterable"><a href="#5-flatMapIterable" class="headerlink" title="5. flatMapIterable"></a>5. flatMapIterable</h4><h4 id="6-buffer"><a href="#6-buffer" class="headerlink" title="6. buffer"></a>6. buffer</h4><h4 id="7-groupBy"><a href="#7-groupBy" class="headerlink" title="7. groupBy"></a>7. groupBy</h4><h3 id="三-过滤操作符"><a href="#三-过滤操作符" class="headerlink" title="三. 过滤操作符"></a>三. 过滤操作符</h3><h4 id="1-filter"><a href="#1-filter" class="headerlink" title="1. filter"></a>1. filter</h4><h4 id="2-elementAt"><a href="#2-elementAt" class="headerlink" title="2. elementAt"></a>2. elementAt</h4><h4 id="3-distinct"><a href="#3-distinct" class="headerlink" title="3. distinct"></a>3. distinct</h4><h4 id="4-skip"><a href="#4-skip" class="headerlink" title="4. skip"></a>4. skip</h4><h4 id="5-take"><a href="#5-take" class="headerlink" title="5. take"></a>5. take</h4><h4 id="6-ignoreElements"><a href="#6-ignoreElements" class="headerlink" title="6. ignoreElements"></a>6. ignoreElements</h4><h4 id="7-throttleFirst"><a href="#7-throttleFirst" class="headerlink" title="7. throttleFirst"></a>7. throttleFirst</h4><h4 id="8-throttleWithTimeOut"><a href="#8-throttleWithTimeOut" class="headerlink" title="8. throttleWithTimeOut"></a>8. throttleWithTimeOut</h4><h3 id="组合操作符"><a href="#组合操作符" class="headerlink" title="组合操作符"></a>组合操作符</h3><h4 id="1-startWith"><a href="#1-startWith" class="headerlink" title="1. startWith"></a>1. startWith</h4><h4 id="2-merge"><a href="#2-merge" class="headerlink" title="2. merge"></a>2. merge</h4><h4 id="3-concat"><a href="#3-concat" class="headerlink" title="3. concat"></a>3. concat</h4><h4 id="4-zip"><a href="#4-zip" class="headerlink" title="4. zip"></a>4. zip</h4><h4 id="5-combineLastest"><a href="#5-combineLastest" class="headerlink" title="5. combineLastest"></a>5. combineLastest</h4><h3 id="辅助操作符"><a href="#辅助操作符" class="headerlink" title="辅助操作符"></a>辅助操作符</h3><ol>
<li><p>delay</p>
</li>
<li><p>do</p>
</li>
<li><p>subscribeOn</p>
</li>
<li><p>observeOn</p>
</li>
<li><p>timeout</p>
</li>
</ol>
<h3 id="错误操作符"><a href="#错误操作符" class="headerlink" title="错误操作符"></a>错误操作符</h3><ol>
<li>catch</li>
<li>retry</li>
</ol>
<h3 id="布尔操作符"><a href="#布尔操作符" class="headerlink" title="布尔操作符"></a>布尔操作符</h3><ol>
<li>all</li>
<li>contains</li>
<li>isEmpty</li>
<li>exists</li>
<li>sequenceEqual</li>
</ol>
<h3 id="条件操作符"><a href="#条件操作符" class="headerlink" title="条件操作符"></a>条件操作符</h3><ol>
<li>amb</li>
<li>defaultIfEmpty</li>
</ol>
<h3 id="转换操作符"><a href="#转换操作符" class="headerlink" title="转换操作符"></a>转换操作符</h3><ol>
<li>toList</li>
<li>toSortList</li>
<li>toMap</li>
</ol>
<h5 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h5><ul>
<li><a href="https://www.cnblogs.com/jymblog/p/11731546.html">一张图看懂Rxjava的原理</a></li>
</ul>
]]></content>
      <tags>
        <tag>响应式编程</tag>
      </tags>
  </entry>
  <entry>
    <title>保障网站安全</title>
    <url>/blogs/security-introduction.html</url>
    <content><![CDATA[<h1 id="保障网站安全"><a href="#保障网站安全" class="headerlink" title="保障网站安全"></a>保障网站安全</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢 ~~</p>
<h5 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h5><ul>
<li><a href="https://juejin.cn/post/6887410793059450887">常见Web安全漏洞（一）</a></li>
</ul>
]]></content>
      <tags>
        <tag>网站安全</tag>
      </tags>
  </entry>
  <entry>
    <title>密码学简介</title>
    <url>/blogs/security-password.html</url>
    <content><![CDATA[<h1 id="密码学简介"><a href="#密码学简介" class="headerlink" title="密码学简介"></a>密码学简介</h1><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢~~</p>
<blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 PR 谢谢~~</p>
<h1 id="密码学"><a href="#密码学" class="headerlink" title="密码学"></a>密码学</h1><h2 id="一-密码学的四个目标"><a href="#一-密码学的四个目标" class="headerlink" title="一. 密码学的四个目标"></a>一. 密码学的四个目标</h2><h4 id="1-机密性（隐私性）"><a href="#1-机密性（隐私性）" class="headerlink" title="1. 机密性（隐私性）"></a>1. 机密性（隐私性）</h4><p>在网络中传递的是一连串无意义的数据，只有通过指定秘钥才能获取真正的数据，密钥是算法的关键。</p>
<h4 id="2-完整性"><a href="#2-完整性" class="headerlink" title="2. 完整性"></a>2. 完整性</h4><p>密码学中，主要使用消息验证码 (MAC) 算法保证完整性。</p>
<h4 id="3-身份验证"><a href="#3-身份验证" class="headerlink" title="3. 身份验证"></a>3. 身份验证</h4><p>一般使用数字签名来确认通信双方的身份，是否是指定通信对象。</p>
<h4 id="4-不可抵赖性"><a href="#4-不可抵赖性" class="headerlink" title="4. 不可抵赖性"></a>4. 不可抵赖性</h4><p>数字签名可以避免抵赖，即消息发送方身份。</p>
]]></content>
      <tags>
        <tag>信息安全</tag>
      </tags>
  </entry>
  <entry>
    <title>security-ssrf</title>
    <url>/blogs/security-ssrf.html</url>
    <content><![CDATA[<h1 id="SSRF-漏洞的原理以及-Java-中的处理"><a href="#SSRF-漏洞的原理以及-Java-中的处理" class="headerlink" title="SSRF 漏洞的原理以及 Java 中的处理"></a>SSRF 漏洞的原理以及 Java 中的处理</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢 ~~</p>
<p>SSRF(Server-Side Request Forgery:服务器端请求伪造) 是由攻击者构造非授权的 URL, 由服务端发起请求的一个安全漏洞。一般情况下，SSRF攻击的目标是从外网无法访问的内部系统。</p>
<p>Java 中如何避免 SSRF</p>
<p>只需要在服务端对要发起请求的 URL 做判断即可. 检测 URL 是内部的域名, 或者 IP 地址, 就进行拦截.</p>
<p>有时候我们需要调用的内部其它服务, 这种情况下把内部的 域名, IP 添加白名单即可.</p>
]]></content>
      <tags>
        <tag>security</tag>
      </tags>
  </entry>
  <entry>
    <title>servlet-annotation-postconstruct</title>
    <url>/blogs/servlet-annotation-postconstruct.html</url>
    <content><![CDATA[<h1 id="Servlet-annotation-PostConstruct-应用原理及注意事项"><a href="#Servlet-annotation-PostConstruct-应用原理及注意事项" class="headerlink" title="Servlet annotation PostConstruct 应用原理及注意事项"></a>Servlet annotation PostConstruct 应用原理及注意事项</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢 ~~</p>
<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>JavaEE 5 中引入此注解。用来修饰非静态 void 方法。在服务器加载 Servlet 时运行，并且只会被服务器执行一次。</p>
<h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><p>执行的时间节点：</p>
<ol>
<li>开始</li>
<li>web 加载 servlet 容器。</li>
<li>Servlet 构造函数</li>
<li>PostConstruct 注解方法</li>
<li>init() 方法</li>
<li>Service() 方法</li>
<li>destory() 方法</li>
<li>PreDestroy 注解方法</li>
<li>结束。</li>
</ol>
<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><ol>
<li>在生成对象时完成某些初始化操作，而浙西初始化操作又依赖于 依赖注入，无法在构造函数中实现。</li>
</ol>
<blockquote>
<p>@PostConstruct 注解的方法将会在依赖注入完成后被自动调用</p>
</blockquote>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ol>
<li>注解发生于应用初始化。</li>
<li>不可加载耗时操作。</li>
</ol>
<h2 id="应用注意事项"><a href="#应用注意事项" class="headerlink" title="应用注意事项"></a>应用注意事项</h2><h5 id="1-PostConstruct-不可与-Component-共用。-Component-需改为-Service，否则会导致-PostConstruct-会初始化两次"><a href="#1-PostConstruct-不可与-Component-共用。-Component-需改为-Service，否则会导致-PostConstruct-会初始化两次" class="headerlink" title="1. @PostConstruct 不可与 @Component 共用。@Component 需改为 @Service，否则会导致 @PostConstruct 会初始化两次"></a>1. <code>@PostConstruct</code> 不可与 <code>@Component</code> 共用。<code>@Component</code> 需改为 <code>@Service</code>，否则会导致 <code>@PostConstruct</code> 会初始化两次</h5><p>问题并不是 <code>@PostConstruct</code> 造成的，而是 <code>@Component</code> 造成的。在 <code>web.xml</code> 中的 <code>DispatcherServlet</code> 继承自 <code>ContextLoaderListener</code>，两者共用 <code>ApplicationContext</code>，但是在启动的时候，会分别调用 <code>initWebApplicationContext()</code> 方法，各自对 <code>@Component</code> 注解对象实例化一次，<code>DispatcherServlet</code> 调用在后，在 <code>Controller</code> 中使用的是后面实例化的对象</p>
]]></content>
      <tags>
        <tag>Java 基础</tag>
      </tags>
  </entry>
  <entry>
    <title>java --XXE 攻击原理及防御</title>
    <url>/blogs/security-xxe.html</url>
    <content><![CDATA[<h1 id="java-–XXE-攻击原理及防御"><a href="#java-–XXE-攻击原理及防御" class="headerlink" title="java –XXE 攻击原理及防御"></a>java –XXE 攻击原理及防御</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢 ~~</p>
<p>XXE(XML External Entity Injection) 全称为 XML 外部实体注入，从名字就能看出来，这是一个注入漏洞，注入的是什么？XML外部实体。需要强调的是利用点是 外部实体 ，也是提醒读者将注意力集中于外部实体中，而不要被 XML 中其他的一些名字相似的东西扰乱了思维(盯好外部实体就行了)，如果能注入 外部实体并且成功解析的话，这就会大大拓宽我们 XML 注入的攻击面。</p>
<h5 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h5><ul>
<li><a href="https://www.k0rz3n.com/2018/11/19/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%B8%A6%E4%BD%A0%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%20XXE%20%E6%BC%8F%E6%B4%9E/">一篇文章带你理解漏洞之 XXE 漏洞</a></li>
</ul>
]]></content>
      <tags>
        <tag>security</tag>
      </tags>
  </entry>
  <entry>
    <title>sit-optimize-applicable-device</title>
    <url>/blogs/sit-optimize-applicable-device.html</url>
    <content><![CDATA[<h1 id="网站优化-设备适配优化"><a href="#网站优化-设备适配优化" class="headerlink" title="网站优化 - 设备适配优化"></a>网站优化 - 设备适配优化</h1><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢~~</p>
<h2 id="1-PC"><a href="#1-PC" class="headerlink" title="1. PC"></a>1. PC</h2><p>如果该网页只适合在电脑上进行浏览，例如（<a href="http://starrier.org/">http://starrier.org/</a> ），</p>
<p>在html中加入如下meta：</p>
<pre class=" language-html"><code class="language-html"> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>applicable-device<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>pc<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>  </code></pre>
<h2 id="2-Mobile-移动端"><a href="#2-Mobile-移动端" class="headerlink" title="2. Mobile 移动端"></a>2. Mobile 移动端</h2><p>如果该网页只适合在移动设备上进行浏览，例如（<a href="http://m.starrier.org/">http://m.starrier.org/</a> ），</p>
<p>在 html中加入如下meta：</p>
<pre class=" language-html"><code class="language-html"> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>applicable-device<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>mobile<span class="token punctuation">"</span></span><span class="token punctuation">></span></span> </code></pre>
<h2 id="3-PC-amp-amp-移动端都适配"><a href="#3-PC-amp-amp-移动端都适配" class="headerlink" title="3. PC &amp;&amp; 移动端都适配"></a>3. PC &amp;&amp; 移动端都适配</h2><p>如果网页采用了响应式网页设计，例如（<a href="http://starrier.starrier.org/%EF%BC%89">http://starrier.starrier.org/）</a> 不需要经过url自适配跳转就可以根据浏览器的屏幕大小自适应的展现合适的效果，同时适合在移动设备和电脑上进行浏览</p>
<p>在html中加入如下meta：  </p>
<pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>applicable-device<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>pc,mobile<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
</code></pre>
]]></content>
      <tags>
        <tag>性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title>网站站点优化</title>
    <url>/blogs/sit-optimize-html.html</url>
    <content><![CDATA[<h1 id="网站站点优化"><a href="#网站站点优化" class="headerlink" title="网站站点优化"></a>网站站点优化</h1><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢~~</p>
<h2 id="1-添加-meta-元属性"><a href="#1-添加-meta-元属性" class="headerlink" title="1. 添加 meta 元属性"></a>1. 添加 <code>meta</code> 元属性</h2><h2 id="2-html-添加-language"><a href="#2-html-添加-language" class="headerlink" title="2. html 添加 language"></a>2. html 添加 language</h2><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>en<span class="token punctuation">"</span></span><span class="token punctuation">></span></span></code></pre>
<p>link <a href="https://web.dev/html-has-lang/?utm_source=lighthouse&amp;utm_medium=cli">https://web.dev/html-has-lang/?utm_source=lighthouse&amp;utm_medium=cli</a></p>
]]></content>
      <tags>
        <tag>性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title>网站优化 - SEO - referrer</title>
    <url>/blogs/sit-optimize-referrer.html</url>
    <content><![CDATA[<h1 id="网站优化-SEO-使用-meta-referrer"><a href="#网站优化-SEO-使用-meta-referrer" class="headerlink" title="网站优化 - SEO - 使用 meta-referrer"></a>网站优化 - SEO - 使用 <code>meta-referrer</code></h1><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢~~</p>
<p>head 中添加</p>
<pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>referrer<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>origin<span class="token punctuation">"</span></span><span class="token punctuation">></span></span></code></pre>
<p>参考文章</p>
<p><a href="https://blog.csdn.net/ccfxue/article/details/53119936">https://blog.csdn.net/ccfxue/article/details/53119936</a></p>
]]></content>
      <tags>
        <tag>性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title>Starrier&#39;s Blog 站点说明</title>
    <url>/blogs/site-introduce.html</url>
    <content><![CDATA[<h1 id="站点建设"><a href="#站点建设" class="headerlink" title="站点建设"></a>站点建设</h1><h2 id="一-项目背景"><a href="#一-项目背景" class="headerlink" title="一. 项目背景"></a>一. 项目背景</h2><h3 id="1-关于当前已发布文章的缺陷说明"><a href="#1-关于当前已发布文章的缺陷说明" class="headerlink" title="1. 关于当前已发布文章的缺陷说明"></a>1. 关于当前已发布文章的缺陷说明</h3><p>当前已发布的文章，主要是为了做文章迁移。参见 <a href="https://github.com/Starrier/starrier.github.io/issues/2">issuse</a></p>
<h4 id="1）-文章内容排版结构"><a href="#1）-文章内容排版结构" class="headerlink" title="1）.文章内容排版结构"></a>1）.文章内容排版结构</h4><pre class=" language-markdown"><code class="language-markdown"><span class="token list punctuation">1.</span> 文章说明

<span class="token list punctuation">2.</span> 内容简介

<span class="token list punctuation">3.</span> 原理

<span class="token list punctuation">4.</span> 为什么使用，使用场景，是否有可替代方案

<span class="token list punctuation">5.</span> 实战

<span class="token list punctuation">6.</span> 总结
</code></pre>
<h3 id="2-关于文章发布内容的说明"><a href="#2-关于文章发布内容的说明" class="headerlink" title="2. 关于文章发布内容的说明"></a>2. 关于文章发布内容的说明</h3><p>所有文章，所属领域，只会发布一篇，并作持续内容的最新更新。</p>
<h3 id="3-关于站点建设问题"><a href="#3-关于站点建设问题" class="headerlink" title="3. 关于站点建设问题"></a>3. 关于站点建设问题</h3><p>如果所发布文章有疑问，或者愿意一起建设的，可以提 <a href="https://github.com/Starrier/starrier.github.io/issues">PR</a></p>
<p><strong>谢谢阅读</strong></p>
<p>(*￣︶￣)  喵喵喵 ~~</p>
<p>如有文章侵权相关，侵权立删，联系人：</p>
<p><a href="https://github.com/Starriers">Starriers</a></p>
<p>团队邮箱：</p>
<p><a href="mailto:&#x73;&#116;&#x61;&#x72;&#x72;&#105;&#101;&#x72;&#64;&#x73;&#116;&#97;&#x72;&#x72;&#x69;&#x65;&#x72;&#x2e;&#111;&#x72;&#x67;">&#x73;&#116;&#x61;&#x72;&#x72;&#105;&#101;&#x72;&#64;&#x73;&#116;&#97;&#x72;&#x72;&#x69;&#x65;&#x72;&#x2e;&#111;&#x72;&#x67;</a></p>
<p>个人邮箱：</p>
<p><a href="mailto:&#115;&#116;&#x61;&#x72;&#x72;&#x69;&#x65;&#114;&#115;&#x40;&#115;&#x74;&#x61;&#x72;&#114;&#x69;&#x65;&#114;&#46;&#111;&#x72;&#x67;">&#115;&#116;&#x61;&#x72;&#x72;&#x69;&#x65;&#114;&#115;&#x40;&#115;&#x74;&#x61;&#x72;&#114;&#x69;&#x65;&#114;&#46;&#111;&#x72;&#x67;</a></p>
]]></content>
      <tags>
        <tag>Starrier</tag>
      </tags>
  </entry>
  <entry>
    <title>译文 - 提高 10 倍性能：优化静态网站</title>
    <url>/blogs/site-static-seo.html</url>
    <content><![CDATA[<h1 id="译-提高-10-倍性能：优化静态网站"><a href="#译-提高-10-倍性能：优化静态网站" class="headerlink" title="[译] 提高 10 倍性能：优化静态网站"></a>[译] 提高 10 倍性能：优化静态网站</h1><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢~~</p>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 PR 谢谢~~</p>
<blockquote>
<ul>
<li>原文地址：<a href="https://hackernoon.com/optimizing-a-static-site-d5ab6899f249">10x Performance Increases: Optimizing a Static Site</a></li>
<li>原文作者：<a href="https://hackernoon.com/@jonluca?source=post_header_lockup">JonLuca De Caro</a></li>
<li>译文出自：<a href="https://github.com/xitu/gold-miner">掘金翻译计划</a></li>
<li>本文永久链接：<a href="https://github.com/xitu/gold-miner/blob/master/TODO1/optimizing-a-static-site.md">https://github.com/xitu/gold-miner/blob/master/TODO1/optimizing-a-static-site.md</a></li>
<li>译者：<a href="https://github.com/Starriers">Starriers</a></li>
<li>校对者：<a href="https://github.com/dandyxu">dandyxu</a>、<a href="https://github.com/Hopsken">Hopsken</a></li>
</ul>
</blockquote>
<h1 id="提高-10-倍性能：优化静态网站"><a href="#提高-10-倍性能：优化静态网站" class="headerlink" title="提高 10 倍性能：优化静态网站"></a>提高 10 倍性能：优化静态网站</h1><p>几个月前，我在国外旅行，想给朋友看我个人（静态）网站上的一个链接。我试着浏览我的网站，但花费的时间比我预期的要长。网站绝对没有任何动态内容–只有动画和一些响应式设计，而且内容始终保持不变。 我对结果感到震惊，DOMContentLoaded 要 4 s，整个页面加载要 6.8 s。有 20 项关于<strong>静态网站</strong>的请求（总数据的 1MB）被转移。我习惯了从洛杉矶到我在旧金山的服务器之间用 1 GB/s 的低延迟互联网连接，这使得这个怪物看起来像闪电一样快。在意大利，8 MB/s 的速度让情况变得完全不同。</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/4/8/162a4a354ba3f527?w=800&h=505&f=png&s=153445"></p>
<p>这是我第一次尝试优化。到目前为止，每次我想添加一个库或者资源时，我都只是将它引入并使用 <strong>src=””</strong> 指向它。从缓存到内联，再到延迟加载，对任何形式的性能我都没有给予关注。</p>
<p>我开始寻找有相似经历的人。不幸的是，许多有关静态优化的文献很快就过时–那些来自 2010 或者 2011 年的建议，要么是在讨论库，要么做一些根本不再试用的假设，要么就是不断地重复某些相同的准则。</p>
<p>不过我确实找到了两个很好的信息源 – <a href="https://hpbn.co/">高性能浏览器网络</a>和 <a href="https://danluu.com/octopress-speedup/">Dan Luu 类似的静态网站优化经历</a>。尽管在剥离格式和内容方面还不如 Dan，但是我确实成功地让我的页面加载速度提高了大约 10 倍。DOMContentLoaded 大约需要五分之一秒，而整个页面加载只有 388 ms（实际上有点不准确，下文将解释延迟加载的原因）。</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/4/8/162a4a3561be31e1?w=800&h=572&f=png&s=126355"></p>
<h3 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h3><p>过程的第一步是对网站进行分析梳理，我想弄清楚哪些地方花费了最长的时间，以及如何最好地并行化一切。我运行了各种工具来分析我的网站，并在世界各地测试它，包括：</p>
<ul>
<li>  <a href="https://tools.pingdom.com/">https://tools.pingdom.com/</a></li>
<li>  <a href="http://www.webpagetest.org/">www.webpagetest.org/</a></li>
<li>  <a href="https://tools.keycdn.com/speed">https://tools.keycdn.com/speed</a></li>
<li>  <a href="https://developers.google.com/web/tools/lighthouse/">https://developers.google.com/web/tools/lighthouse/</a></li>
<li>  <a href="https://developers.google.com/speed/pagespeed/insights/">https://developers.google.com/speed/pagespeed/insights/</a></li>
<li>  <a href="https://webspeedtest.cloudinary.com/">https://webspeedtest.cloudinary.com/</a></li>
</ul>
<p>其中一些提供了改进建议，但当静态站点有 50 个请求时，您只能做这么多 – 从 90 年代遗留下来的间隔 gif 到不再使用的资源（我加载了 6 种字体但只使用了 1 种字体）。</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/4/8/162a4a3567665f00?w=800&h=864&f=png&s=286748"></p>
<p>我的网站时间线 – 我在 Web Archive(译者注：一家提供网站历史快照的服务商)上测试了这个却没有截取原始图片，可是它看起来和我几个月前看到的还是很相似。</p>
<p>我想改进我所能控制的一切 – 从 JavaScript 的内容和速度到实际的 Web 服务器（Ngnix）和 DNS 设置。</p>
<h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><h4 id="简化与合并资源"><a href="#简化与合并资源" class="headerlink" title="简化与合并资源"></a>简化与合并资源</h4><p>我注意到的第一件事是，不管是对于 CSS 还是 JS，我都向各种网站发起十几个请求（没有任何形式的 HTTP keepalive），其中还有一些是 https 请求。这增加了对各种 CDN 或 服务器的多次往返，一些 JS 文件正在请求其他文件，这导致了上面所示的阻塞级联。</p>
<p>我使用 <a href="https://webpack.js.org/">webpack</a> 将所有资源合并到一个 js 文件中。每当我对内容进行更改时，它都会自动简化并将我的所有依赖项转换为单文件。</p>
<pre><code>const UglifyJsPlugin = require(&#39;uglifyjs-webpack-plugin&#39;);
const ZopfliPlugin = require(&quot;zopfli-webpack-plugin&quot;);

module.exports = &#123;
  entry: &#39;./js/app.js&#39;,
  mode: &#39;production&#39;,
  output: &#123;
    path: __dirname + &#39;/dist&#39;,
    filename: &#39;bundle.js&#39;
  &#125;,
  module: &#123;
    rules: [&#123;
      test: /\.css$/,
      loaders: [&#39;style-loader&#39;, &#39;css-loader&#39;]
    &#125;, &#123;
      test: /(fonts|images)/,
      loaders: [&#39;url-loader&#39;]
    &#125;]
  &#125;,
  plugins: [new UglifyJsPlugin(&#123;
    test: /\.js($|\?)/i
  &#125;), new ZopfliPlugin(&#123;
    asset: &quot;[path].gz[query]&quot;,
    algorithm: &quot;zopfli&quot;,
    test: /\.(js|html)$/,
    threshold: 10240,
    minRatio: 0.8
  &#125;)]

&#125;;</code></pre>
<p>我尝试了各种不同的配置。现在，这个 bundle.js 文件在我网站的 <code>&lt;head&gt;</code> 中，并且处于阻塞状态。它的最终大小是 829 kb，包括每个非图像资源（字体、css、所有的库、依赖项以及 js）。绝大多数字体使用的是 font-awesome，它们占 829 kb 中的 724。</p>
<p>我浏览了 Font Awesome 库，除了我要使用的 fa-github、fa-envelope 和 fa-code 三个图标外，其他的所有图标都已经删除。我使用叫做 <a href="http://fontello.com/">fontello</a> 的服务来提取我需要的图标。新的大小只有 94 kb。</p>
<p>按照目前网站的构建方式，如果我们只有样式表，它看起来是不正确的，所以我接受了单个 bundle.js 的阻塞特性。加载时间为 118 ms，比之前提高了一个数量级。</p>
<p>这也带来了一些额外的好处–我不再指向第三方资源或 CDN，因此用户不需要：（1）执行对该资源的 DNS 查询，（2）执行 https 握手，（3）等待该资源被完整地下载。</p>
<p>虽然 CDN 和分布式缓存对于大规模的分布式网站可能是有意义的，但对于我的小型静态网站来说却没有意义。是否需要优化这额外的 100 ms 左右时间是值得权衡的。</p>
<h4 id="压缩资源"><a href="#压缩资源" class="headerlink" title="压缩资源"></a>压缩资源</h4><p>我加载了一个 8 MB 大小的头像，然后以 10% 的宽高比显示它。这不仅仅是缺少优化，这几乎<strong>是忽略了用户对带宽使用</strong>。</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/4/8/162a4a3541bc520c?w=800&h=217&f=png&s=79121"></p>
<p>我使用 <a href="https://webspeedtest.cloudinary.com/">https://webspeedtest.cloudinary.com/</a> 来压缩所有的图像 – 它还建议我切换到  <a href="https://developers.google.com/speed/webp/">webp</a>，但我希望尽可能多的与其他浏览器进行兼容，所以我坚持使用 jpg。尽管完全有可能建立一个只将 webp 交付给支持它的浏览器系统，但我希望尽可能地保持简单，添加抽象层的好处似乎并不明显。</p>
<h4 id="改进-Web-Server-—-HTTP2-TLS-等"><a href="#改进-Web-Server-—-HTTP2-TLS-等" class="headerlink" title="改进 Web Server — HTTP2, TLS 等"></a>改进 Web Server — HTTP2, TLS 等</h4><p>我做的第一件事是过度到 https – 一开始，我在 80 端口运行 Ngnix，只服务于来自 /var/www/html 的文件。</p>
<pre><code>server&#123;
    listen 80;
    server_name jonlu.ca www.jonlu.ca;

    root /var/www/html;
    index index.html index.htm;
    location ~ /.git/ &#123;
          deny all;
    &#125;
    location ~ / &#123;
        allow all;
    &#125;
&#125;</code></pre>
<p>首先设置 https 并将所有 http 请求重定向到 https。我从 <a href="https://letsencrypt.org/">Let’s Encrypt</a> (一个刚开始签署通配符证书的伟大组织！<a href="https://community.letsencrypt.org/t/acme-v2-and-wildcard-certificate-support-is-live/55579">wildcard certificates</a> )那里获得了自己的 TLS 证书。</p>
<pre><code>server &#123;
    listen 443 ssl http2;
    listen [::]:443 ssl http2;
    server_name jonlu.ca www.jonlu.ca;

    root /var/www/html;
    index index.html index.htm;

    location ~ /.git &#123;
        deny all;
    &#125;

    location / &#123;
        allow all;
    &#125;

    ssl_certificate /etc/letsencrypt/live/jonlu.ca/fullchain.pem; # managed by Certbot
    ssl_certificate_key /etc/letsencrypt/live/jonlu.ca/privkey.pem; # managed by Certbot
&#125;</code></pre>
<p>只要添加 http2 的指令，Ngnix 就能够利用 HTTP 最新特性的所有优点。注意，如果要利用 HTTP2（以前的 SPDY），您<strong>必须</strong>使用 HTTPS，在<a href="https://hpbn.co/http2/">这里</a>阅读更多内容。</p>
<p>您还可以利用 HTTP2 push 指令，使用 <strong>http2</strong> push images/Headshot.jpg；</p>
<p>注意：启用 gzip 和 TLS 可能会使您面临 <a href="https://en.wikipedia.org/wiki/BREACH">BREACH</a> 风险。由于这是一个静态网站，而 BREACH 实际的风险很低，所以保持压缩状态让我感觉舒服。</p>
<h4 id="利用缓存和压缩指令"><a href="#利用缓存和压缩指令" class="headerlink" title="利用缓存和压缩指令"></a>利用缓存和压缩指令</h4><p>仅通过使用 Ngnix 还能完成什么呢？首先是缓存和压缩指令。</p>
<p>我之前一直都是发送未经压缩的原始 HTML。只需要一个单独的 <strong>gzip</strong>；是的，我就可以从 16000 字节减少到 8000 字节，减少 50%。</p>
<p>实际上，我们能够进一步改进这个数字，如果将 Ngnix 的 <strong>gzip</strong> 静态设置为开启，它会事先查找所有请求文件的预压缩版本。这与我们上面的 webpack 配置结合在一起 – 我们可以在构建时使用 <a href="https://github.com/webpack-contrib/zopfli-webpack-plugin">ZopflicPlugin</a> 预压缩所有文件！这节省了计算资源，并允许我们在不牺牲速度的情况下最大限度地实现压缩。</p>
<p>此外，我的站点变化很少，所以我希望尽可能长时间地缓存资源。这样，在以后的访问中，用户就不需要重新下载所有资源（特别是 bundle.js）。</p>
<p>我更新的服务器配置如下所示。请注意，我不会涉及我所做的所有更改，例如 TCP 设置更改、gzip 指令和文件缓存。如果您想了解更多，请<a href="https://www.nginx.com/blog/tuning-nginx/">阅读这篇关于 Ngnix 调优的文章</a>。</p>
<pre><code>worker_processes auto;
pid /run/nginx.pid;
worker_rlimit_nofile 30000;

events &#123;
    worker_connections 65535;
    multi_accept on;
    use epoll;
&#125;

http &#123;

    ##
    # Basic Settings
    ##

    sendfile on;
    tcp_nopush on;
    tcp_nodelay on;
    keepalive_timeout 65;
    types_hash_max_size 2048;

    # Turn of server tokens specifying nginx version
    server_tokens off;

    open_file_cache max=200000 inactive=20s;
    open_file_cache_valid 30s;
    open_file_cache_min_uses 2;
    open_file_cache_errors on;

    include /etc/nginx/mime.types;
    default_type application/octet-stream;

    add_header Referrer-Policy &quot;no-referrer&quot;;

    ##
    # SSL Settings
    ##

    ssl_protocols TLSv1 TLSv1.1 TLSv1.2;
    ssl_prefer_server_ciphers on;
    ssl_dhparam /location/to/dhparam.pem;
    ssl_ciphers &#39;ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-AES256-GCM-SHA384:DHE-RSA-AES128-GCM-SHA256:DHE-DSS-AES128-GCM-SHA256:kEDH+AESGCM:ECDHE-RSA-AES128-SHA256:ECDHE-ECDSA-AES128-SHA256:ECDHE-RSA-AES128-SHA:ECDHE-ECDSA-AES128-SHA:ECDHE-RSA-AES256-SHA384:ECDHE-ECDSA-AES256-SHA384:ECDHE-RSA-AES256-SHA:ECDHE-ECDSA-AES256-SHA:DHE-RSA-AES128-SHA256:DHE-RSA-AES128-SHA:DHE-DSS-AES128-SHA256:DHE-RSA-AES256-SHA256:DHE-DSS-AES256-SHA:DHE-RSA-AES256-SHA:AES128-GCM-SHA256:AES256-GCM-SHA384:AES128-SHA256:AES256-SHA256:AES128-SHA:AES256-SHA:AES:CAMELLIA:!aNULL:!eNULL:!EXPORT:!DES:!RC4:!MD5:!PSK:!aECDH:!EDH-DSS-DES-CBC3-SHA:!EDH-RSA-DES-CBC3-SHA:!KRB5-DES-CBC3-SHA&#39;;

    ssl_session_timeout 1d;
    ssl_session_cache shared:SSL:50m;
    ssl_stapling on;
    ssl_stapling_verify on;
    add_header Strict-Transport-Security &#39;max-age=31536000; includeSubDomains; preload&#39;;

    ssl_certificate /location/to/fullchain.pem;
    ssl_certificate_key /location/to/privkey.pem;

    ##
    # Logging Settings
    ##

    access_log /var/log/nginx/access.log;
    error_log /var/log/nginx/error.log;

    ##
    # Gzip Settings
    ##

    gzip on;
    gzip_disable &quot;msie6&quot;;

    gzip_vary on;
    gzip_proxied any;
    gzip_comp_level 6;
    gzip_buffers 16 8k;
    gzip_http_version 1.1;
    gzip_types text/plain text/css application/json application/javascript text/xml application/xml application/xml+rss text/javascript application/vnd.ms-fontobject application/x-font-ttf font/opentype image/svg+xml image/x-icon;
    gzip_min_length 256;

    ##
    # Virtual Host Configs
    ##

    include /etc/nginx/conf.d/*.conf;
    include /etc/nginx/sites-enabled/*;
&#125;</code></pre>
<p>以及相应的服务器块</p>
<pre><code>server &#123;
    listen 443 ssl http2;

    server_name jonlu.ca www.jonlu.ca;

    root /var/www/html;
    index index.html index.htm;

    location ~ /.git/ &#123;
        deny all;
    &#125;

    location ~* /(images|js|css|fonts|assets|dist) &#123;
        gzip_static on; # 告诉 Nginx 首先查找所有请求文件的压缩版本。
        expires 15d; # 15 day expiration for all static assets
    &#125;

&#125;</code></pre>
<h4 id="延迟加载"><a href="#延迟加载" class="headerlink" title="延迟加载"></a>延迟加载</h4><p>最后我的实际网站有一个小的变化，它所带来的优化是不可忽视的。有 5 张图片直到您按下相应选项卡后才能看到，但它们是与其他所有内容同时加载的（因为它们位于 <code>&lt;img src=”…”&gt;</code> 标签中）。</p>
<p>我编写了一个简短的脚本，用 <strong>lazyload 类</strong>修改每个元素的属性。只有单击相应的框后才会加载这些图像。</p>
<pre><code>$(document).ready(function() &#123;
    $(&quot;#about&quot;).click(function() &#123;
        $(&#39;#about &gt; .lazyload&#39;).each(function() &#123;
            // set the img src from data-src
            $(this).attr(&#39;src&#39;, $(this).attr(&#39;data-src&#39;));
        &#125;);
    &#125;);

    $(&quot;#articles&quot;).click(function() &#123;
        $(&#39;#articles &gt; .lazyload&#39;).each(function() &#123;
            // set the img src from data-src
            $(this).attr(&#39;src&#39;, $(this).attr(&#39;data-src&#39;));
        &#125;);
    &#125;);

&#125;);</code></pre>
<p>因此一旦文档完成加载，它将修改 <code>&lt;img&gt;</code> 标签，使他们从 <code>&lt;img data-src=”…”&gt;</code> 转到 <code>&lt;img src=”…”&gt;</code> 然后将其加载到后台。</p>
<h4 id="未来的改进"><a href="#未来的改进" class="headerlink" title="未来的改进"></a>未来的改进</h4><p>还有一些其他的更改可以提高页面加载速度 – 最显著的是使用 Service Workers 缓存并拦截所有请求，让站点甚至脱机运行，在 CDN 上缓存内容，这样用户就不需要在 SF 中对服务器进行完整的往返操作。这些都是有价值的改变，但对于个人静态网站来说并不是特别重要，因为它是一个在线简历（关于我）的页面。</p>
<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>这使我的页面加载时间从第一次加载的 8 s 提高到 350 ms，之后的页面加载速度达到了 200 ms。我真的建议阅读<a href="https://hpbn.co/#toc">高性能浏览器网络</a> – 您可以很快就阅读完它，它提供了对现代互联网的一个非常好的概述，并在互联网模型的每一层都进行了优化。</p>
<p><strong>我遗漏了什么事情吗？是否有任何违反最优做法？或者可以改善我的叙述内容甚至是其他方面？请随时指正 –</strong> <a href="https://medium.com/@jonluca"><em>JonLuca De Caro</em></a><strong>！</strong></p>
<p><img src="https://user-gold-cdn.xitu.io/2018/4/8/162a4a35452205a1?w=800&h=400&f=png&s=37767"></p>
<hr>
<blockquote>
<p><a href="https://github.com/xitu/gold-miner">掘金翻译计划</a> 是一个翻译优质互联网技术文章的社区，文章来源为 <a href="https://juejin.im/">掘金</a> 上的英文分享文章。内容覆盖 <a href="https://github.com/xitu/gold-miner#android">Android</a>、<a href="https://github.com/xitu/gold-miner#ios">iOS</a>、<a href="https://github.com/xitu/gold-miner#%E5%89%8D%E7%AB%AF">前端</a>、<a href="https://github.com/xitu/gold-miner#%E5%90%8E%E7%AB%AF">后端</a>、<a href="https://github.com/xitu/gold-miner#%E5%8C%BA%E5%9D%97%E9%93%BE">区块链</a>、<a href="https://github.com/xitu/gold-miner#%E4%BA%A7%E5%93%81">产品</a>、<a href="https://github.com/xitu/gold-miner#%E8%AE%BE%E8%AE%A1">设计</a>、<a href="https://github.com/xitu/gold-miner#%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD">人工智能</a>等领域，想要查看更多优质译文请持续关注 <a href="https://github.com/xitu/gold-miner">掘金翻译计划</a>、<a href="http://weibo.com/juejinfanyi">官方微博</a>、<a href="https://zhuanlan.zhihu.com/juejinfanyi">知乎专栏</a>。</p>
</blockquote>
<h5 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h5>]]></content>
      <tags>
        <tag>性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title>spring-DispatcherServlet</title>
    <url>/blogs/spring-DispatcherServlet.html</url>
    <content><![CDATA[<h1 id="Spring-DispatcherServlet"><a href="#Spring-DispatcherServlet" class="headerlink" title="Spring - DispatcherServlet"></a>Spring - DispatcherServlet</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢 ~~</p>
<h5 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h5><ul>
<li><a href="https://blog.csdn.net/zhaodongchao1992/article/details/106626581">DispatcherServlet工作原理解析</a></li>
</ul>
]]></content>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>spring-aop</title>
    <url>/blogs/spring-aop.html</url>
    <content><![CDATA[<h1 id="Spring-AOP"><a href="#Spring-AOP" class="headerlink" title="Spring AOP"></a>Spring AOP</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢 ~~</p>
<p>AOP 的实现有两种</p>
<p>一种是采用动态代理，在执行过程中，获取对象，对对象进行装饰，增强对象的功能</p>
<p>一种是采用静态织入的方式，让编译器在编译期间就可以为对象创建指定的行为。</p>
<p>Spring  AOP  和 Aspectj AOP</p>
<p>Spring 是运行时增强(基于代理)</p>
<p>Aspject 是编译时增强（基于字节码）</p>
<h5 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h5><ul>
<li><a href=""></a></li>
</ul>
]]></content>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>spring-applicationcontext</title>
    <url>/blogs/spring-applicationcontext.html</url>
    <content><![CDATA[<h1 id="Spring-ApplicationContext"><a href="#Spring-ApplicationContext" class="headerlink" title="Spring - ApplicationContext"></a>Spring - ApplicationContext</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢 ~~</p>
<p>ApplicationContext 是 Spring 在 BeanFactory 基础上提供的另一个 IoC 容器。除了用于 BeanFactory 的所有功能外，还拥有统一资源加载，信息国际化，<br>容器内事件等。</p>
<h5 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h5><ul>
<li><a href="https://www.zybuluo.com/zhuanxu/note/1059418">Attack-spring-boot-3：深入理解 Application Context</a></li>
</ul>
]]></content>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解 Spring 自动装配原理</title>
    <url>/blogs/spring-auto-config-prinpicle.html</url>
    <content><![CDATA[<h1 id="深入理解-Spring-自动装配原理"><a href="#深入理解-Spring-自动装配原理" class="headerlink" title="深入理解 Spring 自动装配原理"></a>深入理解 Spring 自动装配原理</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢 ~~</p>
<p>springboot 注解中有个  EnableAutoConfiguration，里面会有 @Import 类</p>
<p>Register.class</p>
<h5 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h5><ul>
<li><p><a href="https://www.jianshu.com/p/8351c5fa4dd0">Spring自动装配原理</a></p>
</li>
<li><p><a href="https://www.cnblogs.com/hhcode520/p/9450933.html">非常详细的 SpringBoot 自动装配原理</a></p>
</li>
<li><p><a href="https://www.cnblogs.com/lonely-wolf/p/14577141.html">SpringBoot自动装配原理分析，看完你也能手写一个starter组件</a></p>
</li>
</ul>
]]></content>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Bean  生命周期</title>
    <url>/blogs/spring-bean-lifecycle.html</url>
    <content><![CDATA[<h1 id="Spring-Bean-生命周期"><a href="#Spring-Bean-生命周期" class="headerlink" title="Spring Bean  生命周期"></a>Spring Bean  生命周期</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢 ~~</p>
<h2 id="Spring-Bean"><a href="#Spring-Bean" class="headerlink" title="Spring Bean"></a>Spring Bean</h2><ul>
<li>实例化</li>
<li>属性赋值</li>
<li>初始化<br>使用中</li>
<li>销毁</li>
</ul>
<h3 id="实例化"><a href="#实例化" class="headerlink" title="实例化"></a>实例化</h3><h3 id="属性赋值"><a href="#属性赋值" class="headerlink" title="属性赋值"></a>属性赋值</h3><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><h4 id="1-Aware-相关接口检查，并设置对应的依赖"><a href="#1-Aware-相关接口检查，并设置对应的依赖" class="headerlink" title="1. Aware 相关接口检查，并设置对应的依赖"></a>1. Aware 相关接口检查，并设置对应的依赖</h4><p>Aware 主要是让 对应的 Bean 拥有 Spring 容器的功能。</p>
<h4 id="2-BeanPostProcessor"><a href="#2-BeanPostProcessor" class="headerlink" title="2. BeanPostProcessor"></a>2. BeanPostProcessor</h4><h4 id="3-查看是否实现了-InitializingBean"><a href="#3-查看是否实现了-InitializingBean" class="headerlink" title="3. 查看是否实现了 InitializingBean"></a>3. 查看是否实现了 InitializingBean</h4><h4 id="4-查看是否配置了-init-method"><a href="#4-查看是否配置了-init-method" class="headerlink" title="4. 查看是否配置了 init-method"></a>4. 查看是否配置了 init-method</h4><h4 id="5-BeanPostProcessor"><a href="#5-BeanPostProcessor" class="headerlink" title="5. BeanPostProcessor"></a>5. BeanPostProcessor</h4><p>##InitializingBean</p>
<p>初始化 bean 时，调用一次，后续不会再调用。</p>
<ol>
<li><p>Spring为bean提供了两种初始化bean的方式，实现InitializingBean接口，实现afterPropertiesSet方法，或者在配置文件中通过init-method指定，两种方式可以同时使用。</p>
</li>
<li><p>实现InitializingBean接口是直接调用afterPropertiesSet方法，比通过反射调用init-method指定的方法效率要高一点，但是init-method方式消除了对spring的依赖。</p>
</li>
<li><p>如果调用afterPropertiesSet方法时出错，则不调用init-method指定的方法。</p>
</li>
</ol>
<h5 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h5><ul>
<li><p><a href="https://blog.csdn.net/Asa_Prince/article/details/108508964">Spring中的InitializingBean接口的使用</a></p>
</li>
<li><p><a href="https://juejin.cn/post/6844903682673229831">聊聊spring的那些扩展机制</a></p>
</li>
<li><p><a href="https://juejin.cn/post/6966158157202587662#heading-5">Spring IOC详解及Bean生命周期详细过程，看完直接吊打面试官！</a></p>
</li>
</ul>
]]></content>
      <tags>
        <tag>Srping</tag>
      </tags>
  </entry>
  <entry>
    <title>spring-bean-post-processor</title>
    <url>/blogs/spring-bean-post-processor.html</url>
    <content><![CDATA[<h1 id="spring-bean-post-processor"><a href="#spring-bean-post-processor" class="headerlink" title="spring-bean-post-processor"></a>spring-bean-post-processor</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢 ~~</p>
<h5 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h5><ul>
<li><a href=""></a></li>
</ul>
]]></content>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>spring-beandefinition</title>
    <url>/blogs/spring-beandefinition.html</url>
    <content><![CDATA[<h1 id="spring-beandefinition"><a href="#spring-beandefinition" class="headerlink" title="spring-beandefinition"></a>spring-beandefinition</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢 ~~</p>
<p><code>BeanDefinition</code> 继承 <code>AtrributeAccessor</code> 和 <code>BeanMetaDataElement</code></p>
<p>类名、scope、属性、构造函数参数列表、依赖的bean、是否是单例类、是否是懒加载等，其实就是将Bean的定义信息存储到这个BeanDefinition相应的属性中，后面对Bean的操作就直接对BeanDefinition进行，例如拿到这个BeanDefinition后，可以根据里面的类名、构造函数、构造函数参数，使用反射进行对象创建。<br>默认的 Bean 都是单例的。</p>
<h5 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h5><ul>
<li><a href="https://www.cnblogs.com/watertreestar/p/12830261.html">Spring-BeanDefinition</a></li>
</ul>
]]></content>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>spring-cloud-feign</title>
    <url>/blogs/spring-cloud-feign.html</url>
    <content><![CDATA[<h1 id="spring-cloud-feign"><a href="#spring-cloud-feign" class="headerlink" title="spring-cloud-feign"></a>spring-cloud-feign</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢 ~~</p>
<h5 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h5><ul>
<li><a href="https://www.cnblogs.com/crazymakercircle/p/11965726.html">feign 原理图解</a></li>
</ul>
]]></content>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>spring-beanfactory</title>
    <url>/blogs/spring-beanfactory.html</url>
    <content><![CDATA[<h1 id="Spring-BeanFactory"><a href="#Spring-BeanFactory" class="headerlink" title="Spring - BeanFactory"></a>Spring - BeanFactory</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢 ~~</p>
<p>BeanFactory 作为 IoC 的顶层容器，提供访问 bean 的基础功能，后续其他接口的扩展都是为其增强不同的功能。包括<br>使用最多的 ApplicationContext。</p>
<p>DefaultListableBeanFactory 是 Spring 加载 Bean 的核心，是 Spring 注册和 Bean 加载的默认实现。</p>
<p>BeanFactory 一般不提供给开发者使用</p>
<blockquote>
<p>加载配置文件时，不会创建 bean 对象，只有第一次创建（使用）对象时，才会创建 Bean 对象，后续的使用都是缓存中的同一个对象。</p>
</blockquote>
<p>ApplicationContext 一般由开发者使用</p>
<blockquote>
<p>加载配置文件时，就创建对象，后续使用的都是同一个对象。</p>
</blockquote>
<p><strong>如果不是单例，都是在每次创建(使用)对象时，才创建对象</strong></p>
<h3 id="BeanFactory-及其子类介绍"><a href="#BeanFactory-及其子类介绍" class="headerlink" title="BeanFactory 及其子类介绍"></a>BeanFactory 及其子类介绍</h3><p>BeanFactory</p>
<p>主要方法是 getBean(),提供了访问bean，获取bean，bean 是否是单例 等。</p>
<p>BeanFactory的三个子接口：</p>
<ul>
<li>HierarchicalBeanFactory<blockquote>
<p>提供父容器的访问功能</p>
</blockquote>
</li>
<li>ListableBeanFactory<blockquote>
<p>提供了批量获取Bean的方法</p>
</blockquote>
</li>
<li>AutowireCapableBeanFactory<blockquote>
<p>在BeanFactory基础上实现对已存在实例的管理</p>
</blockquote>
</li>
</ul>
<p>ConfigurableBeanFactory接口：<br>主要单例bean的注册，生成实例，以及统计单例bean</p>
<p>ConfigurableListableBeanFactory接口：<br>继承了上述的所有接口，增加了其他功能：比如类加载器,类型转化,属性编辑器,BeanPostProcessor,作用域,bean定义,处理bean依赖关系, bean如何销毁…</p>
<p>实现类DefaultListableBeanFactory 的详细介绍：<br>实现了ConfigurableListableBeanFactory接口，实现上述BeanFactory所有功能。它还可以注册BeanDefinition</p>
<p>ApplicationContext 有个 ConfigurableApplicationContext 接口，接口中有 Refresh  和  close 两个方法，<br>让 ApplicationContext 具有启动，刷新和关闭上下文的功能。</p>
<h5 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h5><ul>
<li><p><a href="https://juejin.cn/post/6854573209497370632#heading-8">理解Spring系列——BeanFactory，Spring IoC的核心担当</a></p>
</li>
<li><p><a href="https://cloud.tencent.com/developer/article/1497577">【小家Spring】一文读懂Spring中的BeanFactory和FactoryBean（以及它和ObjectFactory的区别）的区别</a></p>
</li>
</ul>
]]></content>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>深入分析与理解 spring-cloud-hystrix - HystrixCommand</title>
    <url>/blogs/spring-cloud-hystrix-hystrixcommand.html</url>
    <content><![CDATA[<h1 id="深入分析与理解-spring-cloud-hystrix-HystrixCommand"><a href="#深入分析与理解-spring-cloud-hystrix-HystrixCommand" class="headerlink" title="深入分析与理解 spring-cloud-hystrix - HystrixCommand"></a>深入分析与理解 spring-cloud-hystrix - HystrixCommand</h1><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢~~</p>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 PR 谢谢~~</p>
<h2 id="EnableCircuitBreaker"><a href="#EnableCircuitBreaker" class="headerlink" title="@EnableCircuitBreaker"></a><code>@EnableCircuitBreaker</code></h2><p><code>@EnableHystrix</code>:</p>
<pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Target</span><span class="token punctuation">(</span>ElementType<span class="token punctuation">.</span>TYPE<span class="token punctuation">)</span>
<span class="token annotation punctuation">@Retention</span><span class="token punctuation">(</span>RetentionPolicy<span class="token punctuation">.</span>RUNTIME<span class="token punctuation">)</span>
<span class="token annotation punctuation">@Documented</span>
<span class="token annotation punctuation">@Inherited</span>
<span class="token annotation punctuation">@EnableCircuitBreaker</span>
<span class="token keyword">public</span> @<span class="token keyword">interface</span> <span class="token class-name">EnableHystrix</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre>
<p><code>@EnableCircuitBreaker</code> :</p>
<pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Target</span><span class="token punctuation">(</span>ElementType<span class="token punctuation">.</span>TYPE<span class="token punctuation">)</span>
<span class="token annotation punctuation">@Retention</span><span class="token punctuation">(</span>RetentionPolicy<span class="token punctuation">.</span>RUNTIME<span class="token punctuation">)</span>
<span class="token annotation punctuation">@Documented</span>
<span class="token annotation punctuation">@Inherited</span>
<span class="token annotation punctuation">@Import</span><span class="token punctuation">(</span>EnableCircuitBreakerImportSelector<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> @<span class="token keyword">interface</span> <span class="token class-name">EnableCircuitBreaker</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre>
<p><code>@EnableHystrix</code> 是对 <code>@EnableCircuitBreaker</code> 的增强。</p>
<p>HystrixCommandAspect 通过 AOP 拦截所有的 <code>@HystrixCommand</code> 注解的方法，从而使得 @HystrixCommand 能够集成到 SpringBoot 中。</p>
<p>HystrixCommandAspect：</p>
<ol>
<li>hystrixCommandAnnotationPointcut() 定义拦截 HystrixCommand</li>
<li>hystrixCollapserAnnotationPointcut() 定义拦截 HystrixCollapser</li>
<li>方法 methodsAnnotatedWithHystrixCommand(…) 通过 @Around(…) 拦截所有 HystrixCommand 和 HystrixCollapser 注解的方法。</li>
</ol>
<pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Aspect</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HystrixCommandAspect</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>

    <span class="token annotation punctuation">@Pointcut</span><span class="token punctuation">(</span><span class="token string">"@annotation(com.netflix.hystrix.contrib.javanica.annotation.HystrixCommand)"</span><span class="token punctuation">)</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">hystrixCommandAnnotationPointcut</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>

    <span class="token annotation punctuation">@Pointcut</span><span class="token punctuation">(</span><span class="token string">"@annotation(com.netflix.hystrix.contrib.javanica.annotation.HystrixCollapser)"</span><span class="token punctuation">)</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">hystrixCollapserAnnotationPointcut</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>

  <span class="token annotation punctuation">@Around</span><span class="token punctuation">(</span><span class="token string">"hystrixCommandAnnotationPointcut() || hystrixCollapserAnnotationPointcut()"</span><span class="token punctuation">)</span>
    <span class="token keyword">public</span> Object <span class="token function">methodsAnnotatedWithHystrixCommand</span><span class="token punctuation">(</span><span class="token keyword">final</span> ProceedingJoinPoint joinPoint<span class="token punctuation">)</span> <span class="token keyword">throws</span> Throwable <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// 获取拦截的Method</span>
        Method method <span class="token operator">=</span> <span class="token function">getMethodFromTarget</span><span class="token punctuation">(</span>joinPoint<span class="token punctuation">)</span><span class="token punctuation">;</span>
        Validate<span class="token punctuation">.</span><span class="token function">notNull</span><span class="token punctuation">(</span>method<span class="token punctuation">,</span> <span class="token string">"failed to get method from joinPoint: %s"</span><span class="token punctuation">,</span> joinPoint<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// 只有被HystrixCommand和HystrixCollapser注解的方法才执行后续操作</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>method<span class="token punctuation">.</span><span class="token function">isAnnotationPresent</span><span class="token punctuation">(</span>HystrixCommand<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> method<span class="token punctuation">.</span><span class="token function">isAnnotationPresent</span><span class="token punctuation">(</span>HystrixCollapser<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalStateException</span><span class="token punctuation">(</span><span class="token string">"method cannot be annotated with HystrixCommand and HystrixCollapser "</span> <span class="token operator">+</span>
                    <span class="token string">"annotations at the same time"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// 根据拦截方法的注解HystrixCommand或HystrixCollapser分别获取CommandMetaHolderFactory或者CollapserMetaHolderFactory类</span>
        MetaHolderFactory metaHolderFactory <span class="token operator">=</span> META_HOLDER_FACTORY_MAP<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>HystrixPointcutType<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span>method<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// 将拦截方法封装到MetaHolder中</span>
        MetaHolder metaHolder <span class="token operator">=</span> metaHolderFactory<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>joinPoint<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// 根据metaHolder生成相应的HystrixCommand，包含生成hystrix执行时需要的配置信息，这些配置信息来自默认配置或我们自定义的属性</span>
        HystrixInvokable invokable <span class="token operator">=</span> HystrixCommandFactory<span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>metaHolder<span class="token punctuation">)</span><span class="token punctuation">;</span>
        ExecutionType executionType <span class="token operator">=</span> metaHolder<span class="token punctuation">.</span><span class="token function">isCollapserAnnotationPresent</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">?</span>
                metaHolder<span class="token punctuation">.</span><span class="token function">getCollapserExecutionType</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span> metaHolder<span class="token punctuation">.</span><span class="token function">getExecutionType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        Object result<span class="token punctuation">;</span>
        <span class="token keyword">try</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
           <span class="token comment" spellcheck="true">// 根据是否是Observable执行CommandExecutor.execute()方法，executeObservable最后也会执行CommandExecutor.execute()方法</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>metaHolder<span class="token punctuation">.</span><span class="token function">isObservable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
                result <span class="token operator">=</span> CommandExecutor<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span>invokable<span class="token punctuation">,</span> executionType<span class="token punctuation">,</span> metaHolder<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">else</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
                result <span class="token operator">=</span> <span class="token function">executeObservable</span><span class="token punctuation">(</span>invokable<span class="token punctuation">,</span> executionType<span class="token punctuation">,</span> metaHolder<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">HystrixBadRequestException</span> e<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
            <span class="token keyword">throw</span> e<span class="token punctuation">.</span><span class="token function">getCause</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> null <span class="token operator">?</span> e<span class="token punctuation">.</span><span class="token function">getCause</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span> e<span class="token punctuation">;</span>
        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">HystrixRuntimeException</span> e<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
            <span class="token keyword">throw</span> <span class="token function">hystrixRuntimeExceptionToThrowable</span><span class="token punctuation">(</span>metaHolder<span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> result<span class="token punctuation">;</span>
    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>

…<span class="token punctuation">.</span>
<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre>
<p>@EnableCircuitBreaker 和 @EnableCircuitBreakerImportSelctor</p>
<p>HystrixCircuitBreakerConfiguration 的执行：</p>
<pre class=" language-java"><code class="language-java">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>cloud<span class="token punctuation">.</span>client<span class="token punctuation">.</span>circuitbreaker<span class="token punctuation">.</span>EnableCircuitBreaker<span class="token operator">=</span>\
org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>cloud<span class="token punctuation">.</span>netflix<span class="token punctuation">.</span>hystrix<span class="token punctuation">.</span>HystrixCircuitBreakerConfiguration</code></pre>
<p>通过 @Import 来初始化 EnableCircuitBreakerImportSelector 类，可以参见 @EnableCircuitBreaker.</p>
<p>EnableCircuitBreakerImportSelector 是 SpringFactoryImportSelector 子类。此类在初始化后，会执行 selectImports(AnnotationMetadata metadata) 的方法。此方法会根据注解启动的注解（这里指 <code>@EnableCircuitBreaker</code>）从spring.factories 文件中获取其配置需要初始化 <code>@Configuration</code> 类（这里是 org.springframework.cloud.netflix.hystrix.HystrixCircuitBreakerConfiguration），从而最终初始化 HystrixCommandAspect 类，从而实现拦截 HystrixCommand` 的功能</p>
<p>以上就是通过 <code>@EnableCircuitBreake</code> 可以开启 Hystrix 的原理。</p>
<h5 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h5>]]></content>
      <tags>
        <tag>分布式中间件</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解 Spring Cloud Hystrix 原理</title>
    <url>/blogs/spring-cloud-hystrix-principle.html</url>
    <content><![CDATA[<h1 id="深入理解-Spring-Cloud-Hystrix-原理"><a href="#深入理解-Spring-Cloud-Hystrix-原理" class="headerlink" title="深入理解 Spring Cloud Hystrix 原理"></a>深入理解 Spring Cloud Hystrix 原理</h1><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢~~</p>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 PR 谢谢~~</p>
<h5 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h5>]]></content>
      <tags>
        <tag>分布式中间件</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring 中的设计模式</title>
    <url>/blogs/spring-design-pattern.html</url>
    <content><![CDATA[<h1 id="Spring-中的设计模式"><a href="#Spring-中的设计模式" class="headerlink" title="Spring 中的设计模式"></a>Spring 中的设计模式</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢 ~~</p>
<h3 id="工厂设计模式（Spring-IOC-DI）"><a href="#工厂设计模式（Spring-IOC-DI）" class="headerlink" title="工厂设计模式（Spring IOC DI）"></a>工厂设计模式（Spring IOC DI）</h3><p>Spring使用工厂模式可以通过 BeanFactory 或 ApplicationContext 创建 bean 对象。</p>
<h3 id="单例设计模式"><a href="#单例设计模式" class="headerlink" title="单例设计模式"></a>单例设计模式</h3><p>Spring 中，bean 默认都是单例的。</p>
<h3 id="代理模式（AOP）"><a href="#代理模式（AOP）" class="headerlink" title="代理模式（AOP）"></a>代理模式（AOP）</h3><h3 id="模版"><a href="#模版" class="headerlink" title="模版"></a>模版</h3><p>如  JDBC template 等 以 template 结尾的类。</p>
<h3 id="观察者模式（Spring-的事件驱动）"><a href="#观察者模式（Spring-的事件驱动）" class="headerlink" title="观察者模式（Spring 的事件驱动）"></a>观察者模式（Spring 的事件驱动）</h3><h3 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h3><p>Spring 中的 AOP 使用的是代理模式，但是 Spring 的增强通知 使用的是适配器模式。</p>
<p>Spring MVC 中的 Handler 也是。</p>
<h3 id="装饰器模式"><a href="#装饰器模式" class="headerlink" title="装饰器模式"></a>装饰器模式</h3><p>Spring中用到的包装器模式在类名上有两种表现：一种是类名中含有Wrapper，另一种是类名中含有Decorator。</p>
<h3 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h3><p>Source 接口</p>
<p>Resource</p>
<h5 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h5><ul>
<li><p><a href="https://blog.csdn.net/weixin_39595320/article/details/111039337">spring中的设计模式_面试官：“谈谈Spring中都用到了那些设计模式？”。</a></p>
</li>
<li><p><a href="https://blog.csdn.net/caoxiaohong1005/article/details/80039656">Spring中涉及的设计模式总结</a></p>
</li>
</ul>
]]></content>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>spring-factorybean</title>
    <url>/blogs/spring-factorybean.html</url>
    <content><![CDATA[<h1 id="Spring-FactroyBean"><a href="#Spring-FactroyBean" class="headerlink" title="Spring - FactroyBean"></a>Spring - FactroyBean</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢 ~~</p>
<p>FactoryBean</p>
<p>这个 Bean 不是简单的 Bean，而是一个能生产或者修饰对象的工厂 Bean,它的实现与设计模式中的工厂模式和修饰器模式类似</p>
<p>一般情况下，Spring 通过反射机制，利用 bean 的 calss 指定实现类实例化 bean。在某些情况下，实例化 bean 比较复杂，如果按照传统的方法，<br>需要提供大量的配置信息。</p>
<p>配置方式的灵活性是受限的，因此我们可以继承 BeanFactory 来定制 bean 实例化的过程。</p>
<p>FactoryBean的着重于自定义创建对象过程，由BeanFactory通过FactoryBean来获取目标对象，而如果是isSingleton返回true的话，spring会利用单例缓存来缓存通过FactoryBean创建的对象。</p>
<h5 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h5><ul>
<li><a href=""></a></li>
</ul>
]]></content>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解 Spring 注入方式</title>
    <url>/blogs/spring-inject.html</url>
    <content><![CDATA[<h1 id="深入理解-Spring-注入方式"><a href="#深入理解-Spring-注入方式" class="headerlink" title="深入理解 Spring 注入方式"></a>深入理解 Spring 注入方式</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢 ~~</p>
<h5 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h5><ul>
<li><a href=""></a></li>
</ul>
]]></content>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring 目录</title>
    <url>/blogs/spring-introduce.html</url>
    <content><![CDATA[<h1 id="Spring-目录"><a href="#Spring-目录" class="headerlink" title="Spring 目录"></a>Spring 目录</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢 ~~</p>
<h5 id="1-Spring-Bean"><a href="#1-Spring-Bean" class="headerlink" title="1. Spring Bean"></a>1. Spring Bean</h5><ul>
<li><a href="">spring-bean-BeanFactory</a></li>
<li><a href="">spring-bean-FactoryBean</a></li>
<li><a href="">spring-bean-BeanPostProcessor</a></li>
<li><a href="">spring-bean-注入</a></li>
</ul>
<h5 id="2-Spring-IOC"><a href="#2-Spring-IOC" class="headerlink" title="2. Spring IOC"></a>2. Spring IOC</h5><ul>
<li><a href="">spring-ioc-概述</a></li>
<li><a href="">spring-ioc-原理</a></li>
<li><a href="">spring-ioc-初始化</a></li>
<li><a href="">spring-ioc-依赖注入</a></li>
</ul>
<h5 id="3-Spring-AOP"><a href="#3-Spring-AOP" class="headerlink" title="3. Spring AOP"></a>3. Spring AOP</h5><ul>
<li><a href="">spring-aop-概述</a></li>
<li><a href="">spring-aop-原理</a></li>
<li><a href="">spring-aop-AopProxy</a></li>
<li><a href="">spring-aop-拦截器</a></li>
<li><a href="">spring-aop-高级特性</a></li>
</ul>
<h5 id="4-Spring-事务"><a href="#4-Spring-事务" class="headerlink" title="4. Spring 事务"></a>4. Spring 事务</h5><ul>
<li><a href="">spring-事务概述</a></li>
<li><a href="">spring-事务原理</a></li>
<li><a href="">spring-事务处理器</a></li>
</ul>
<h5 id="5-Spring-数据库相关"><a href="#5-Spring-数据库相关" class="headerlink" title="5. Spring 数据库相关"></a>5. Spring 数据库相关</h5><ul>
<li><a href="">spring-database-概述</a></li>
<li><a href="">spring-database-jdbc</a></li>
<li><a href="">spring-database-hibernate</a></li>
<li><a href="">spring-database-mybatis</a></li>
</ul>
<h5 id="6-Spring-MVC"><a href="#6-Spring-MVC" class="headerlink" title="6. Spring MVC"></a>6. Spring MVC</h5><ul>
<li><a href="">spring-mvc-概述</a></li>
<li><a href="">spring-mvc-初始化</a></li>
<li><a href="">spring-mvc-原理</a></li>
<li><a href="">spring-mvc-视图</a></li>
</ul>
<p>spring 自动装配原理</p>
<h5 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h5><ul>
<li><a href=""></a></li>
</ul>
]]></content>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解 Spring Ioc 原理</title>
    <url>/blogs/spring-ioc-principle.html</url>
    <content><![CDATA[<h1 id="深入理解-Spring-Ioc-原理"><a href="#深入理解-Spring-Ioc-原理" class="headerlink" title="深入理解 Spring Ioc 原理"></a>深入理解 Spring Ioc 原理</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢 ~~</p>
<h2 id="Ioc-容器的启动流程"><a href="#Ioc-容器的启动流程" class="headerlink" title="Ioc 容器的启动流程"></a>Ioc 容器的启动流程</h2><p>依赖注入 和 依赖查找的区别</p>
<p>依赖查找，是主动或手动去形式。通过BeanFactory的getBean方法来获取；<br>依赖注入，是手动或者自动的形式。需要某个Bean，我只需在类中方法或字段上添加@Autowired或@Resource注解即可，由IoC容器来帮我完成查找并注入。</p>
<p>主要分为两部分：</p>
<ul>
<li>容器的启动阶段</li>
<li>Bean 的实例化阶段</li>
</ul>
<h5 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h5><ul>
<li><p><a href="https://jishuin.proginn.com/p/763bfbd2a478">Spring IOC 原理深层解析</a></p>
</li>
<li><p><a href="https://lingmoumou.github.io/p/2020/02/06/2dc6b46a/">控制反转（IoC）、依赖注入（DI）、依赖查找（DL）</a></p>
</li>
<li><p><a href="https://juejin.cn/post/6976888072277327902">深入理解Spring的依赖查找和依赖注入</a></p>
</li>
<li><p><a href="https://blog.csdn.net/m0_43448868/article/details/111866510">在Spring IoC中，依赖注入和依赖查找的数据来源区别</a></p>
</li>
</ul>
]]></content>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>深入分析与理解 Spring MVC 原理</title>
    <url>/blogs/spring-mvc-principle.html</url>
    <content><![CDATA[<h1 id="深入分析与理解-Spring-MVC-原理"><a href="#深入分析与理解-Spring-MVC-原理" class="headerlink" title="深入分析与理解 Spring MVC 原理"></a>深入分析与理解 Spring MVC 原理</h1><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢~~</p>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 PR 谢谢~~</p>
<h4 id="SpringMVC-流程："><a href="#SpringMVC-流程：" class="headerlink" title="SpringMVC 流程："></a>SpringMVC 流程：</h4><ol>
<li>用户发送请求至前端控制器 <code>DispatcherServlet</code></li>
<li><code>DispatcherServlet</code> 首先要请求调用 <code>HandlerMapping</code> 处理器映射器。</li>
<li>处理器映射器找到具体的处理器（可以根据 <code>xml</code> 配置、注解进行查找），生成处理器对象以及处理器拦截器（如果有则生成）一并返回给 <code>DispatcherServlet</code>。</li>
<li><code>DispatcherServlet</code> 调用 <code>HandlerAdapter</code> 处理器适配器。</li>
<li><code>HandlerAdapter</code> 经过适配器调用具体的处理器（<code>Controller</code>，也叫后端控制器）。</li>
<li><code>Controller</code> 执行完成返回 <code>ModelAndView</code></li>
<li><code>HandlerAdapter</code> 将 <code>controller</code> 执行结果 <code>ModelAndView</code> 返回给 <code>DispatcherServlet</code>。</li>
<li><code>DispatcherServlet</code> 将 <code>ModelAndView</code> 传给 <code>ViewReslover</code> 视图解析器。</li>
<li><code>ViewReslover</code> 解析后返回具体的 <code>View</code>。</li>
<li><code>DispatcherServlet</code> 根据 <code>View</code> 进行渲染视图（即将模型数据填充至视图中）。</li>
<li><code>DispatcherServlet</code> 响应用户。</li>
</ol>
<h5 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h5>]]></content>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring 容器 refresh 过程</title>
    <url>/blogs/spring-refresh.html</url>
    <content><![CDATA[<h1 id="Spring-容器-refresh-过程"><a href="#Spring-容器-refresh-过程" class="headerlink" title="Spring 容器 refresh 过程"></a>Spring 容器 refresh 过程</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢 ~~</p>
<h5 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h5><ul>
<li><a href="https://fangjian0423.github.io/2017/05/10/springboot-context-refresh/">SpringBoot源码分析之Spring容器的refresh过程</a></li>
</ul>
]]></content>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解 Spring MVC ulr</title>
    <url>/blogs/spring-mvc-url-match.html</url>
    <content><![CDATA[<h1 id="深入理解-Spring-MVC-ulr"><a href="#深入理解-Spring-MVC-ulr" class="headerlink" title="深入理解 Spring MVC ulr"></a>深入理解 Spring MVC ulr</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢 ~~</p>
<h5 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h5><ul>
<li><a href="https://blog.csdn.net/zzti_erlie/article/details/106168046">Spring MVC源码解析：各种类型Handler的注册和查找</a></li>
</ul>
]]></content>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解 Spring 事务</title>
    <url>/blogs/spring-transcation.html</url>
    <content><![CDATA[<h1 id="深入理解-Spring-事务"><a href="#深入理解-Spring-事务" class="headerlink" title="深入理解 Spring 事务"></a>深入理解 Spring 事务</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢 ~~</p>
<p>TransactionInterceptor</p>
<p>负责拦截方法执行，进行判断是否需要提交或者回滚事务</p>
<p>PlatformTransactionManager</p>
<p>Spring 中的事务管理接口，真正定义了事务如何回滚和提交。</p>
<h5 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h5><ul>
<li><a href=""></a></li>
</ul>
]]></content>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring - validate</title>
    <url>/blogs/spring-validate.html</url>
    <content><![CDATA[<h1 id="Spring-validate"><a href="#Spring-validate" class="headerlink" title="Spring - validate"></a>Spring - validate</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢 ~~</p>
<p>Spring 校验框架，Spring Validate 是在对 Hibernate Validate 的基础上进行的封装。SpringBoot 2.3x 之前默认加载，之后的版本想要使用需要<br>显示声明对应的 maven 坐标。</p>
<h5 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h5><ul>
<li><a href="https://segmentfault.com/a/1190000023471742">Spring Validation最佳实践及其实现原理，参数校验没那么简单！</a></li>
</ul>
]]></content>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>TCP  知识</title>
    <url>/blogs/tcp-rst.html</url>
    <content><![CDATA[<h1 id="TCP-知识"><a href="#TCP-知识" class="headerlink" title="TCP 知识"></a>TCP 知识</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢 ~~</p>
<ul>
<li><a href="https://my.oschina.net/yunqi/blog/5023988">那些你不知道的 TCP 冷门知识</a></li>
</ul>
]]></content>
      <tags>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title>单元测试 - Mockito - powermock - 异常测试</title>
    <url>/blogs/test-mockito-exception.html</url>
    <content><![CDATA[<h1 id="单元测试-Mockito-powermock-异常测试"><a href="#单元测试-Mockito-powermock-异常测试" class="headerlink" title="单元测试 - Mockito - powermock - 异常测试"></a>单元测试 - Mockito - powermock - 异常测试</h1><blockquote>
<ul>
<li>原文地址：<a href="https://starrier.starrier.org/blogs/test-mockito-exception.html">https://starrier.starrier.org/blogs/test-mockito-exception.html</a></li>
<li>原文作者：<a href="https://github.com/imperater">imperater</a></li>
<li>本文永久链接：<a href="https://starrier.starrier.org/blogs/test-mockito-exception.html">https://starrier.starrier.org/blogs/test-mockito-exception.html</a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢~~</p>
<blockquote>
<ol>
<li><p><a href="https://starrier.starrier.org/blogs/test-mockito-method.html">单元测试 - Mockito - powermock - 实例函数调用</a></p>
</li>
<li><p><a href="https://starrier.starrier.org/blogs/test-mockito-static.html">单元测试 - Mockito - powermock - 静态方法</a></p>
</li>
<li><p><a href="https://starrier.starrier.org/blogs/test-mockito-exception.html">单元测试 - Mockito - powermock - 异常测试</a></p>
</li>
<li><p><a href="https://starrier.starrier.org/blogs/test-mockito-private.html">单元测试 - Mockito - powermock - 内部私有函数</a></p>
</li>
</ol>
</blockquote>
<h2 id="一-引入-maven-坐标"><a href="#一-引入-maven-坐标" class="headerlink" title="一. 引入 maven 坐标"></a>一. 引入 maven 坐标</h2><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.powermock<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>powermock-api-mockito<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>$<span class="token entity" title="&#123;">&amp;#123;</span>powermock.version<span class="token entity" title="&#125;">&amp;#125;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>scope</span><span class="token punctuation">></span></span>test<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>scope</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.powermock<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>powermock-core<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>$<span class="token entity" title="&#123;">&amp;#123;</span>powermock.version<span class="token entity" title="&#125;">&amp;#125;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>scope</span><span class="token punctuation">></span></span>test<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>scope</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span> 
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.powermock<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>powermock-module-junit4<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>$<span class="token entity" title="&#123;">&amp;#123;</span>powermock.version<span class="token entity" title="&#125;">&amp;#125;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>scope</span><span class="token punctuation">></span></span>test<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>scope</span><span class="token punctuation">></span></span>
 <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span></code></pre>
<blockquote>
<p>具体的版本，可去 maven 中心仓库自行查找自己想要的</p>
</blockquote>
<h2 id="二-Mock-异常"><a href="#二-Mock-异常" class="headerlink" title="二. Mock 异常"></a>二. Mock 异常</h2><h3 id="1-mock-异常的发生"><a href="#1-mock-异常的发生" class="headerlink" title="1. mock 异常的发生"></a>1. mock 异常的发生</h3><pre class=" language-java"><code class="language-java">Mockito<span class="token punctuation">.</span><span class="token function">when</span><span class="token punctuation">(</span>Mockito<span class="token punctuation">.</span><span class="token function">anyObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token punctuation">.</span><span class="token function">thenThrow</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Exception</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p>或者使用</p>
<pre class=" language-java"><code class="language-java"> Mockito<span class="token punctuation">.</span><span class="token function">when</span><span class="token punctuation">(</span>Mockito<span class="token punctuation">.</span><span class="token function">anyObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token punctuation">.</span><span class="token function">thenThrow</span><span class="token punctuation">(</span>Exception<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<h3 id="2-对异常进行断言"><a href="#2-对异常进行断言" class="headerlink" title="2. 对异常进行断言"></a>2. 对异常进行断言</h3><h4 id="1）-使用-Test-注解"><a href="#1）-使用-Test-注解" class="headerlink" title="1）. 使用 @Test 注解"></a>1）. 使用 <code>@Test</code> 注解</h4><p>在测试类上加上注解，<code>expected</code> 中的异常为具体的  <code>mock</code>  异常。</p>
<pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Test</span><span class="token punctuation">(</span>expected <span class="token operator">=</span> Exception<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span></code></pre>
<h4 id="2）-使用-try-catch"><a href="#2）-使用-try-catch" class="headerlink" title="2）. 使用 try-catch"></a>2）. 使用 <code>try-catch</code></h4><h4 id="3）-使用-Rule-结合-JUnit-的-ExpectedException-类"><a href="#3）-使用-Rule-结合-JUnit-的-ExpectedException-类" class="headerlink" title="3）.  使用 @Rule  结合 JUnit 的 ExpectedException 类"></a>3）.  使用 <code>@Rule</code>  结合 <code>JUnit</code> 的 <code>ExpectedException</code> 类</h4><ul>
<li><p>声明全局变量，且为 <code>public</code> 类型</p>
<pre class=" language-java"><code class="language-java">  <span class="token annotation punctuation">@Rule</span>
  <span class="token keyword">public</span> ExpectedException exception <span class="token operator">=</span> ExpectedException<span class="token punctuation">.</span><span class="token function">none</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
</li>
<li><p>在调用方法前，使用断言</p>
</li>
</ul>
<pre class=" language-java"><code class="language-java">exception<span class="token punctuation">.</span><span class="token function">expect</span><span class="token punctuation">(</span>IOException<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<h5 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h5>]]></content>
      <tags>
        <tag>单元测试</tag>
      </tags>
  </entry>
  <entry>
    <title>单元测试 - Mockito - powermock -实例函数调用</title>
    <url>/blogs/test-mockito-method.html</url>
    <content><![CDATA[<h1 id="单元测试-Mockito-powermock-实例函数调用"><a href="#单元测试-Mockito-powermock-实例函数调用" class="headerlink" title="单元测试 - Mockito - powermock -实例函数调用"></a>单元测试 - Mockito - powermock -实例函数调用</h1><blockquote>
<ul>
<li>原文地址：<a href="https://starrier.starrier.org/blogs/test-mockito-method.html">https://starrier.starrier.org/blogs/test-mockito-method.html</a></li>
<li>原文作者：<a href="https://github.com/imperater">imperater</a></li>
<li>本文永久链接：<a href="https://starrier.starrier.org/blogs/test-mockito-method.html">https://starrier.starrier.org/blogs/test-mockito-method.html</a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢~~</p>
<blockquote>
<ol>
<li><p><a href="https://starrier.starrier.org/blogs/test-mockito-method.html">单元测试 - Mockito - powermock - 实例函数调用</a> </p>
</li>
<li><p><a href="https://starrier.starrier.org/blogs/test-mockito-static.html">单元测试 - Mockito - powermock - 静态方法</a> </p>
</li>
<li><p><a href="https://starrier.starrier.org/blogs/test-mockito-exception.html">单元测试 - Mockito - powermock - 异常测试</a></p>
</li>
<li><p><a href="https://starrier.starrier.org/blogs/test-mockito-private.html">单元测试 - Mockito - powermock - 内部私有函数</a></p>
</li>
</ol>
</blockquote>
<h2 id="一-引入-Maven-坐标"><a href="#一-引入-Maven-坐标" class="headerlink" title="一. 引入 Maven 坐标"></a>一. 引入 Maven 坐标</h2><pre class=" language-xml"><code class="language-xml">       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.powermock<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>powermock-api-mockito<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>$<span class="token entity" title="&#123;">&amp;#123;</span>powermock.version<span class="token entity" title="&#125;">&amp;#125;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>scope</span><span class="token punctuation">></span></span>test<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>scope</span><span class="token punctuation">></span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.powermock<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>powermock-core<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>$<span class="token entity" title="&#123;">&amp;#123;</span>powermock.version<span class="token entity" title="&#125;">&amp;#125;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>scope</span><span class="token punctuation">></span></span>test<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>scope</span><span class="token punctuation">></span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.powermock<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>powermock-module-junit4<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>$<span class="token entity" title="&#123;">&amp;#123;</span>powermock.version<span class="token entity" title="&#125;">&amp;#125;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>scope</span><span class="token punctuation">></span></span>test<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>scope</span><span class="token punctuation">></span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span></code></pre>
<blockquote>
<p>具体的版本，可去 maven 中心仓库自行查找自己想要的</p>
</blockquote>
<h2 id="二-测试类声明"><a href="#二-测试类声明" class="headerlink" title="二 测试类声明"></a>二 测试类声明</h2><p>在当前的测试类上，引入下列代码。其中 <code>@PrepareForTest</code>  用于声明所需要引入的静态类（如工具类）。详情参见：<a href="https://starrier.starrier.org/blogs/test-mockito-static.html">单元测试 - Mockito - powermock - 静态方法</a></p>
<pre class=" language-[java]"><code class="language-[java]">@RunWith(PowerMockRunner.class)
@PowerMockRunnerDelegate()
@PowerMockIgnore(&#123;"javax.management.*", "javax.net.ssl.*"&#125;)
@PrepareForTest(&#123;     
&#125;)</code></pre>
<h2 id="三-注入实例"><a href="#三-注入实例" class="headerlink" title="三. 注入实例"></a>三. 注入实例</h2><p>注入对应的实例变量，包括待测试的类以及对应类所引用的实例（需要被 mock 的方法）</p>
<pre class=" language-[java]"><code class="language-[java]">    //  待测试的类
    @InjectMocks
    private TargetService targetService;

    //  需要被 mock 的实例方法
    @Mock
    private TargetDao targetDao;

    // mock 初始化
    @Before
    public void before() throws Exception &#123;
        MockitoAnnotations.initMocks(this);
        MemberModifier
                .field(TargetService.class, "targetDao")
                .set(targetService, targetDao);
    &#125;</code></pre>
<h2 id="四-在-test-中，引入-mock-的数据"><a href="#四-在-test-中，引入-mock-的数据" class="headerlink" title="四.  在 test 中，引入 mock 的数据"></a>四.  在 test 中，引入 mock 的数据</h2><pre class=" language-[java]"><code class="language-[java]"> @Test
 public void saveCertificatePolicy()&#123;
   Mockito
     .when(targetDao.insert(Mockito.any(TargetMapping.class)))
    .thenReturn(new TargetEntity());
   &#125;</code></pre>
<h5 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h5><ol>
<li> 如果 Mockito 中，包含多个参数，则要么都为实际参数，要么都是 Mockito 所构造的参数，否则会报错。</li>
<li> 如果对于返回值 <code>thenReturn</code> 需要指定的数据，则自行自己定义并放入即可。</li>
</ol>
<h5 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h5>]]></content>
      <tags>
        <tag>单元测试</tag>
      </tags>
  </entry>
  <entry>
    <title>单元测试 - Mockito - powermock - 内部私有函数</title>
    <url>/blogs/test-mockito-private.html</url>
    <content><![CDATA[<h1 id="单元测试-Mockito-powermock-内部私有函数"><a href="#单元测试-Mockito-powermock-内部私有函数" class="headerlink" title="单元测试 - Mockito - powermock - 内部私有函数"></a>单元测试 - Mockito - powermock - 内部私有函数</h1><blockquote>
<ul>
<li>原文地址：<a href="https://starrier.starrier.org/blogs/test-mockito-private.html">https://starrier.starrier.org/blogs/test-mockito-private.html</a></li>
<li>原文作者：<a href="https://github.com/imperater">imperater</a></li>
<li>本文永久链接：<a href="https://starrier.starrier.org/blogs/test-mockito-private.html">https://starrier.starrier.org/blogs/test-mockito-private.html</a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢~~</p>
<blockquote>
<ol>
<li><p><a href="https://starrier.starrier.org/blogs/test-mockito-method.html">单元测试 - Mockito - powermock - 实例函数调用</a></p>
</li>
<li><p><a href="https://starrier.starrier.org/blogs/test-mockito-static.html">单元测试 - Mockito - powermock - 静态方法</a></p>
</li>
<li><p><a href="https://starrier.starrier.org/blogs/test-mockito-exception.html">单元测试 - Mockito - powermock - 异常测试</a></p>
</li>
<li><p><a href="https://starrier.starrier.org/blogs/test-mockito-private.html">单元测试 - Mockito - powermock - 内部私有函数</a></p>
</li>
</ol>
</blockquote>
<h2 id="第一种方式："><a href="#第一种方式：" class="headerlink" title="第一种方式："></a>第一种方式：</h2><blockquote>
<p>部分版本可能会有问题，未深究。</p>
</blockquote>
<h2 id="第二种方式"><a href="#第二种方式" class="headerlink" title="第二种方式"></a>第二种方式</h2><h5 id="1-首先，我们需要引入相关-maven-依赖。"><a href="#1-首先，我们需要引入相关-maven-依赖。" class="headerlink" title="1. 首先，我们需要引入相关 maven 依赖。"></a>1. 首先，我们需要引入相关 maven 依赖。</h5><pre class=" language-xml"><code class="language-xml">        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.powermock<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>powermock-api-mockito<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>$<span class="token entity" title="&#123;">&amp;#123;</span>powermock.version<span class="token entity" title="&#125;">&amp;#125;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>scope</span><span class="token punctuation">></span></span>test<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>scope</span><span class="token punctuation">></span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.powermock<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>powermock-core<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>$<span class="token entity" title="&#123;">&amp;#123;</span>powermock.version<span class="token entity" title="&#125;">&amp;#125;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>scope</span><span class="token punctuation">></span></span>test<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>scope</span><span class="token punctuation">></span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.powermock<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>powermock-module-junit4<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>$<span class="token entity" title="&#123;">&amp;#123;</span>powermock.version<span class="token entity" title="&#125;">&amp;#125;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>scope</span><span class="token punctuation">></span></span>test<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>scope</span><span class="token punctuation">></span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span></code></pre>
<h4 id="2-使用注解-Spy-进行方法注入"><a href="#2-使用注解-Spy-进行方法注入" class="headerlink" title="2. 使用注解 @Spy 进行方法注入"></a>2. 使用注解 <code>@Spy</code> 进行方法注入</h4><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Spy</span>
<span class="token keyword">private</span> TestService mockService <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TestService</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<h4 id="3-在方法中引用"><a href="#3-在方法中引用" class="headerlink" title="3. 在方法中引用"></a>3. 在方法中引用</h4><pre class=" language-java"><code class="language-java">Whitebox<span class="token punctuation">.</span><span class="token function">invokeMethod</span><span class="token punctuation">(</span>powerMock<span class="token punctuation">,</span> <span class="token string">"getCarOperationService"</span><span class="token punctuation">,</span> vehicleGuidePriceParam<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<h5 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h5>]]></content>
      <tags>
        <tag>单元测试</tag>
      </tags>
  </entry>
  <entry>
    <title>单元测试 - Mockito - powermock - 静态方法</title>
    <url>/blogs/test-mockito-static.html</url>
    <content><![CDATA[<h1 id="单元测试-Mockito-powermock-静态方法"><a href="#单元测试-Mockito-powermock-静态方法" class="headerlink" title="单元测试 - Mockito - powermock - 静态方法"></a>单元测试 - Mockito - powermock - 静态方法</h1><blockquote>
<ul>
<li>原文地址：<a href="https://starrier.starrier.org/blogs/test-mockito-static.html">https://starrier.starrier.org/blogs/test-mockito-static.html</a></li>
<li>原文作者：<a href="https://github.com/imperater">imperater</a></li>
<li>本文永久链接：<a href="https://starrier.starrier.org/blogs/test-mockito-static.html">https://starrier.starrier.org/blogs/test-mockito-static.html</a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢~~</p>
<blockquote>
<ol>
<li><p><a href="https://starrier.starrier.org/blogs/test-mockito-method.html">单元测试 - Mockito - powermock - 实例函数调用</a></p>
</li>
<li><p><a href="https://starrier.starrier.org/blogs/test-mockito-static.html">单元测试 - Mockito - powermock - 静态方法</a></p>
</li>
<li><p><a href="https://starrier.starrier.org/blogs/test-mockito-exception.html">单元测试 - Mockito - powermock - 异常测试</a></p>
</li>
<li><p><a href="https://starrier.starrier.org/blogs/test-mockito-private.html">单元测试 - Mockito - powermock - 内部私有函数</a></p>
</li>
</ol>
</blockquote>
<h5 id="1-首先，我们需要引入相关-maven-依赖。"><a href="#1-首先，我们需要引入相关-maven-依赖。" class="headerlink" title="1. 首先，我们需要引入相关 maven 依赖。"></a>1. 首先，我们需要引入相关 maven 依赖。</h5><pre class=" language-xml"><code class="language-xml">        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.powermock<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>powermock-api-mockito<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>$<span class="token entity" title="&#123;">&amp;#123;</span>powermock.version<span class="token entity" title="&#125;">&amp;#125;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>scope</span><span class="token punctuation">></span></span>test<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>scope</span><span class="token punctuation">></span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.powermock<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>powermock-core<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>$<span class="token entity" title="&#123;">&amp;#123;</span>powermock.version<span class="token entity" title="&#125;">&amp;#125;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>scope</span><span class="token punctuation">></span></span>test<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>scope</span><span class="token punctuation">></span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.powermock<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>powermock-module-junit4<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>$<span class="token entity" title="&#123;">&amp;#123;</span>powermock.version<span class="token entity" title="&#125;">&amp;#125;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>scope</span><span class="token punctuation">></span></span>test<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>scope</span><span class="token punctuation">></span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span></code></pre>
<blockquote>
<p>具体 pom 版本，可去 maven 中心仓库选择。</p>
</blockquote>
<h5 id="1-我们需要在测试类上加上需要使用静态类的-class"><a href="#1-我们需要在测试类上加上需要使用静态类的-class" class="headerlink" title="1. 我们需要在测试类上加上需要使用静态类的 class"></a>1. 我们需要在测试类上加上需要使用静态类的 class</h5><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@PrepareForTest</span><span class="token punctuation">(</span>Utils<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre>
<h5 id="2-在对应需要测试的地方，加上-mock-静态方法的逻辑"><a href="#2-在对应需要测试的地方，加上-mock-静态方法的逻辑" class="headerlink" title="2.  在对应需要测试的地方，加上 mock 静态方法的逻辑"></a>2.  在对应需要测试的地方，加上 mock 静态方法的逻辑</h5><pre class=" language-java"><code class="language-java">  PowerMockito<span class="token punctuation">.</span><span class="token function">mockStatic</span><span class="token punctuation">(</span>RedisProviderHelper<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  Mockito<span class="token punctuation">.</span><span class="token function">when</span><span class="token punctuation">(</span>Utils<span class="token punctuation">.</span><span class="token function">getUtils</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">thenReturn</span><span class="token punctuation">(</span>null<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<h5 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h5>]]></content>
      <tags>
        <tag>单元测试</tag>
      </tags>
  </entry>
  <entry>
    <title>IDEA - plugin - JRebel</title>
    <url>/blogs/tools-idea-plugins-jrebel.html</url>
    <content><![CDATA[<h1 id="常用开发工具-JRebel"><a href="#常用开发工具-JRebel" class="headerlink" title="常用开发工具 - JRebel"></a>常用开发工具 - JRebel</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 PR 谢谢~~</p>
<h1 id="IDEA-工具"><a href="#IDEA-工具" class="headerlink" title="IDEA  工具"></a>IDEA  工具</h1><h2 id="JRebel"><a href="#JRebel" class="headerlink" title="JRebel"></a>JRebel</h2><h5 id="1-生成-GUID-的网址"><a href="#1-生成-GUID-的网址" class="headerlink" title="1. 生成 GUID 的网址"></a>1. 生成 GUID 的网址</h5><p><a href="https://www.guidgen.com/">https://www.guidgen.com/</a></p>
<h5 id="2-用这个网址-生成的-GUID-激活"><a href="#2-用这个网址-生成的-GUID-激活" class="headerlink" title="2. 用这个网址 + 生成的 GUID 激活"></a>2. 用这个网址 + 生成的 GUID 激活</h5><p><a href="https://jrebel.qekang.com/">https://jrebel.qekang.com/</a></p>
<pre class=" language-shell"><code class="language-shell">https://jrebel.qekang.com/cb2546bb-9d43-4115-bf4b-10539349efed</code></pre>
<h5 id="3-设置离线模式-来防止失效"><a href="#3-设置离线模式-来防止失效" class="headerlink" title="3. 设置离线模式 来防止失效"></a>3. 设置离线模式 来防止失效</h5><p>File -&gt; Settings -&gt; JRebel -&gt; [Work offline]按钮</p>
<h5 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h5>]]></content>
      <tags>
        <tag>开发工具</tag>
      </tags>
  </entry>
  <entry>
    <title>日常工具-端口占用-Mac-Wind</title>
    <url>/blogs/utils-command-life-port.html</url>
    <content><![CDATA[<h1 id="日常工具-端口占用-Mac-Wind"><a href="#日常工具-端口占用-Mac-Wind" class="headerlink" title="日常工具-端口占用-Mac-Wind"></a>日常工具-端口占用-Mac-Wind</h1><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢~~</p>
<h2 id="一-Mac-环境"><a href="#一-Mac-环境" class="headerlink" title="一. Mac 环境"></a>一. Mac 环境</h2><h3 id="1-根据指定端口，查找占用端口的进程的-pid"><a href="#1-根据指定端口，查找占用端口的进程的-pid" class="headerlink" title="1. 根据指定端口，查找占用端口的进程的 pid"></a>1. 根据指定端口，查找占用端口的进程的 pid</h3><pre class=" language-shell"><code class="language-shell">lsof -i:4000</code></pre>
<h5 id="Result"><a href="#Result" class="headerlink" title="Result:"></a>Result:</h5><pre class=" language-shell"><code class="language-shell">starrier:starrier.github.io starrier$ lsof -i:4000
COMMAND  PID     USER   FD   TYPE             DEVICE SIZE/OFF NODE NAME
node    1879 starrier   46u  IPv6 0x8546bfa6d2b2dd07      0t0  TCP *:terabase (LISTEN)</code></pre>
<h3 id="2-解除端口与进程的关联"><a href="#2-解除端口与进程的关联" class="headerlink" title="2. 解除端口与进程的关联"></a>2. 解除端口与进程的关联</h3><pre class=" language-shell"><code class="language-shell">kill -9 1897</code></pre>
<h4 id="lsof-更多的使用方式，参见-lsof-command-命令用法"><a href="#lsof-更多的使用方式，参见-lsof-command-命令用法" class="headerlink" title="lsof 更多的使用方式，参见 lsof command 命令用法"></a><code>lsof</code> 更多的使用方式，参见 <a href="">lsof command 命令用法</a></h4><h5 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h5>]]></content>
      <tags>
        <tag>command</tag>
        <tag>utils</tag>
      </tags>
  </entry>
  <entry>
    <title>utils-gava-lists</title>
    <url>/blogs/utils-gava-lists.html</url>
    <content><![CDATA[<h1 id="工具-Guava-深入理解-Guava-Lists-原理与实战"><a href="#工具-Guava-深入理解-Guava-Lists-原理与实战" class="headerlink" title="工具 - Guava - 深入理解 Guava  Lists 原理与实战"></a>工具 - Guava - 深入理解 Guava  Lists 原理与实战</h1><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢~~</p>
<h5 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h5>]]></content>
  </entry>
  <entry>
    <title>使用 git cherry-pick 获取指定提交内容</title>
    <url>/blogs/utils-git-cherry-pick.html</url>
    <content><![CDATA[<h1 id="使用-git-cherry-pick-获取指定提交内容"><a href="#使用-git-cherry-pick-获取指定提交内容" class="headerlink" title="使用 git cherry-pick 获取指定提交内容"></a>使用 git cherry-pick 获取指定提交内容</h1><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢~~</p>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 PR 谢谢~~</p>
<p>简而言之，<code>cherry-pick</code> 就是从不同的分支中捡出一个单独的 commit，并把它和你当前的分支合并。如果你以并行方式在处理两个或以上分支，你可能会发现一个在全部分支中都有的 bug。如果你在一个分支中解决了它，你可以使用 <code>cherry-pick</code> 命令把它 commit 到其它分支上去，而不会弄乱其他的文件或 commit。</p>
<p>以我目前做的项目为例，现在有 4 个开发者维护着四个分支，以自己的用户名命名，开发出一个特性后定时合并到 dev 分支。并且规定各自分支不能将合并后的 dev 分支代码合并回自己分支，以免发生混乱。但是这样就有个问题，比如 A 开发出一个特性，B 的后续特性需要依赖 A 开发出来的特性，由于 B 不能合并远程的 dev 分支，故 B 是没有办法获取 A 开发的特性的。</p>
<p>这个时候，<code>cherry-pick</code> 就起作用了，假设 dev 分支上 A 最近一次提交为 <code>hash-1</code>，B 就可以在自己分支上执行 <code>git cherry-pick hash-1</code> 来获取 A 最近一次提交更新的文件，如果没有冲突，B 的分支将自动进行一次与 A 一致的提交，否则进行合并后提交。这时，B 就可以使用 A 开发的特性了。</p>
<h5 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h5>]]></content>
      <tags>
        <tag>开发工具</tag>
      </tags>
  </entry>
  <entry>
    <title>git-commit 修改提交的 commit 信息 author</title>
    <url>/blogs/utils-git-commit-author.html</url>
    <content><![CDATA[<h1 id="git-commit-修改提交的-commit-信息-author"><a href="#git-commit-修改提交的-commit-信息-author" class="headerlink" title="git-commit 修改提交的 commit 信息 author"></a>git-commit 修改提交的 commit 信息 author</h1><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢~~</p>
<h3 id="1-直接修改当前的作者信息"><a href="#1-直接修改当前的作者信息" class="headerlink" title="1. 直接修改当前的作者信息"></a>1. 直接修改当前的作者信息</h3><pre class=" language-gitexclude"><code class="language-gitexclude">git commit --amend --reset-author</code></pre>
<h3 id="2-对于已经-commit-的信息，可以使用如下命令"><a href="#2-对于已经-commit-的信息，可以使用如下命令" class="headerlink" title="2. 对于已经 commit 的信息，可以使用如下命令"></a>2. 对于已经 commit 的信息，可以使用如下命令</h3><pre class=" language-gitexclude"><code class="language-gitexclude">git commit --amend --author="NewAuthor <NewEmail@address.com>"</code></pre>
<h5 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h5>]]></content>
      <tags>
        <tag>开发工具</tag>
      </tags>
  </entry>
  <entry>
    <title>git commit 操作详解</title>
    <url>/blogs/utils-git-commit-refactor.html</url>
    <content><![CDATA[<h1 id="Git-commit-已提交-commit-记录的重写"><a href="#Git-commit-已提交-commit-记录的重写" class="headerlink" title="Git - commit 已提交 commit 记录的重写"></a>Git - commit 已提交 commit 记录的重写</h1><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢~~</p>
<h2 id="一-修改最新的-commit-信息"><a href="#一-修改最新的-commit-信息" class="headerlink" title="一. 修改最新的 commit 信息"></a>一. 修改最新的 <code>commit</code> 信息</h2><pre class=" language-shell"><code class="language-shell">git commit --amend</code></pre>
<h2 id="二-修改前-N-次提交的-commit-提交信息"><a href="#二-修改前-N-次提交的-commit-提交信息" class="headerlink" title="二. 修改前 N 次提交的 commit 提交信息"></a>二. 修改前 <code>N</code> 次提交的 <code>commit</code> 提交信息</h2><pre class=" language-shell"><code class="language-shell">git rebase -i HEAD ~ n</code></pre>
<p>修改后，保存退出，输入</p>
<pre class=" language-shell"><code class="language-shell">git commit  --amend</code></pre>
<p>保存退出后，继续输入</p>
<pre class=" language-shell"><code class="language-shell">git rebase --continue</code></pre>
<h2 id="三-git-合并-commit-记录"><a href="#三-git-合并-commit-记录" class="headerlink" title="三. git 合并 commit 记录"></a>三. git 合并 commit 记录</h2><p>存在 3 次 commit 记录，hash 值分别为 a，b，c。现在只保留 c 的 commit 记录。</p>
<pre class=" language-log"><code class="language-log">
commit1 a

commit2 b

commit3 c
</code></pre>
<h3 id="1-进行基变操作。"><a href="#1-进行基变操作。" class="headerlink" title="1. 进行基变操作。"></a>1. 进行基变操作。</h3><pre class=" language-git"><code class="language-git">git rebase -i  c</code></pre>
<p>log 文件可能如下:</p>
<pre class=" language-log"><code class="language-log">pick commit1-message
pick commit2-message
pick commit3-message</code></pre>
<p>选择第三个，使用 <code>fixup</code>，我们只保留 3，修改后保存并退出。</p>
<pre class=" language-log"><code class="language-log">pick commit1-message
fixup commit2-message
fixup commit3-message</code></pre>
<h3 id="2-此时，如果需要修改-author-可以进行-commit-–amend"><a href="#2-此时，如果需要修改-author-可以进行-commit-–amend" class="headerlink" title="2. 此时，如果需要修改 author 可以进行 commit –amend"></a>2. 此时，如果需要修改 author 可以进行 commit –amend</h3><pre class=" language-git"><code class="language-git">git commit --amend --reset-author</code></pre>
<p>重新提交信息即可。保存并退出。</p>
<h2 id="过程中，可能存在的问题："><a href="#过程中，可能存在的问题：" class="headerlink" title="过程中，可能存在的问题："></a>过程中，可能存在的问题：</h2><ol>
<li>找不到 hash 值：</li>
</ol>
<ul>
<li>使用 <code>IDEA</code> 自带的 <code>git</code> 工具</li>
<li><code>git-log</code></li>
</ul>
<ol start="2">
<li>如果不慎操作 <code>git reset --hard</code>：</li>
</ol>
<ul>
<li><ol>
<li>使用 <code>git reflog</code> 命令恢复指定版本。git 操作的所有命令所形成的版本，在 relog 中都会有记录。</li>
</ol>
<ul>
<li>使用 <code>git reset -i hash值</code>（想要恢复的版本）</li>
</ul>
</li>
</ul>
]]></content>
      <tags>
        <tag>开发工具</tag>
      </tags>
  </entry>
  <entry>
    <title>使用 git-convert 回滚已经提交的 commit</title>
    <url>/blogs/utils-git-commit-revert.html</url>
    <content><![CDATA[<h1 id="使用-git-convert-回滚已经提交的-commit"><a href="#使用-git-convert-回滚已经提交的-commit" class="headerlink" title="使用 git-convert 回滚已经提交的 commit"></a>使用 git-convert 回滚已经提交的 commit</h1><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢~~</p>
<h2 id="一-简介"><a href="#一-简介" class="headerlink" title="一. 简介"></a>一. 简介</h2><p><code>git-revert</code> 用于撤销某次指定提交的操作，被操作的版本，之前和之后的内容（包括 commit 和 history 都会被保留下来）</p>
<h2 id="二-用法"><a href="#二-用法" class="headerlink" title="二. 用法"></a>二. 用法</h2><ol>
<li>对当前版本进行回滚操作</li>
</ol>
<pre class=" language-git"><code class="language-git">git revert HEAD           </code></pre>
<ol start="2">
<li>对上一个版本内容进行回滚</li>
</ol>
<pre class=" language-git"><code class="language-git">git revert HEAD^   </code></pre>
<ol start="3">
<li>对指定版本进行回滚</li>
</ol>
<pre class=" language-git"><code class="language-git">git revert commit hashValue</code></pre>
<h2 id="三-git-revert-和-git-rebase-比较"><a href="#三-git-revert-和-git-rebase-比较" class="headerlink" title="三. git-revert 和 git-rebase 比较"></a>三. git-revert 和 git-rebase 比较</h2><ol>
<li><p><code>git revert</code> 是对之前 <code>commit</code> 内容进行覆盖。而 <code>git reset</code> 是直接删除指定的 <code>commit</code>。</p>
</li>
<li><p>两个命令效果一致：</p>
<ul>
<li><p><code>git-revert</code> 与之前的旧分支合并时，不会有新旧 <code>commit</code> 内容的冲突；</p>
</li>
<li><p><code>git-reset</code> 时，与旧分支合并时，旧分支的 <code>commit</code> 会被引入，有可能会产生冲突。</p>
</li>
</ul>
</li>
<li><p>git reset 是把 <code>HEAD</code> 向后移动了一下，而 <code>git revert</code> 是 <code>HEAD</code> 继续前进，只是新的 <code>commit</code> 的内容和要 <code>revert</code> 的内容正好相反，能够抵消要被 <code>revert</code>的内容。</p>
</li>
</ol>
<h5 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h5>]]></content>
      <tags>
        <tag>开发工具</tag>
      </tags>
  </entry>
  <entry>
    <title>gitkeep 文件作用</title>
    <url>/blogs/utils-git-gitkeep.html</url>
    <content><![CDATA[<h1 id="gitkeep-文件作用"><a href="#gitkeep-文件作用" class="headerlink" title="gitkeep 文件作用"></a>gitkeep 文件作用</h1><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢~~</p>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 PR 谢谢~~</p>
<p>git无法追踪一个空文件夹，当用户需要追踪（track)一个空文件夹的时候，按照惯例，大家会把一个称为.gitkeep的文件放在这些文件夹里。</p>
<p>使git忽略一个文件夹下的所有文件，并保留该 文件夹</p>
<h5 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h5>]]></content>
      <tags>
        <tag>开发工具</tag>
      </tags>
  </entry>
  <entry>
    <title>使用 git-reset 回滚代码到指定版本</title>
    <url>/blogs/utils-git-reflog.html</url>
    <content><![CDATA[<h1 id="使用-git-reset-回滚代码到指定版本"><a href="#使用-git-reset-回滚代码到指定版本" class="headerlink" title="使用 git-reset 回滚代码到指定版本"></a>使用 git-reset 回滚代码到指定版本</h1><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢~~</p>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 PR 谢谢~~</p>
<h2 id="一-查看-log-history"><a href="#一-查看-log-history" class="headerlink" title="一. 查看 log history"></a>一. 查看 log history</h2><pre class=" language-shell"><code class="language-shell">git log</code></pre>
<h2 id="二-查看-reflog-history"><a href="#二-查看-reflog-history" class="headerlink" title="二. 查看 reflog history"></a>二. 查看 reflog history</h2><pre class=" language-shell"><code class="language-shell">git reflog</code></pre>
<h2 id="三-选择想要回滚的指定版本"><a href="#三-选择想要回滚的指定版本" class="headerlink" title="三. 选择想要回滚的指定版本"></a>三. 选择想要回滚的指定版本</h2><pre class=" language-shell"><code class="language-shell">git reset --hard hash-value</code></pre>
<h5 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h5>]]></content>
      <tags>
        <tag>开发工具</tag>
      </tags>
  </entry>
  <entry>
    <title>Gradle provided 类型</title>
    <url>/blogs/utils-gradle-provided.html</url>
    <content><![CDATA[<h1 id="Gradle-provided-类型"><a href="#Gradle-provided-类型" class="headerlink" title="Gradle provided 类型"></a>Gradle provided 类型</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢 ~~</p>
<h5 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h5>]]></content>
      <tags>
        <tag>开发工具</tag>
      </tags>
  </entry>
  <entry>
    <title>常见 Java 压缩-解压缩算法原理与实践</title>
    <url>/blogs/utils-java-compress.html</url>
    <content><![CDATA[<h1 id="常见-Java-压缩-解压缩算法原理与实践"><a href="#常见-Java-压缩-解压缩算法原理与实践" class="headerlink" title="常见 Java 压缩-解压缩算法原理与实践"></a>常见 Java 压缩-解压缩算法原理与实践</h1><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢~~</p>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 PR 谢谢~~</p>
<h5 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h5>]]></content>
      <tags>
        <tag>Java 基础</tag>
      </tags>
  </entry>
  <entry>
    <title>工具类库 - Lombok - 注解 -@Value</title>
    <url>/blogs/utils-lombok-annotation-value.html</url>
    <content><![CDATA[<h1 id="工具类库-Lombok-注解-Value"><a href="#工具类库-Lombok-注解-Value" class="headerlink" title="工具类库 - Lombok - 注解 -@Value"></a>工具类库 - Lombok - 注解 -@Value</h1><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢~~</p>
<h5 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h5>]]></content>
      <tags>
        <tag>开发工具</tag>
      </tags>
  </entry>
  <entry>
    <title>工具类库 - Lombok - 常用注解</title>
    <url>/blogs/utils-lombok-annotations.html</url>
    <content><![CDATA[<h1 id="常用开发工具-Lombok"><a href="#常用开发工具-Lombok" class="headerlink" title="常用开发工具 - Lombok"></a>常用开发工具 - Lombok</h1><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢~~</p>
<h2 id="常用注解"><a href="#常用注解" class="headerlink" title="常用注解"></a>常用注解</h2><h3 id="Data"><a href="#Data" class="headerlink" title="@Data"></a><code>@Data</code></h3><p>注解在类上，会为类的所有属性自动生成 setter/getter、equals、canEqual、hashCode、toString 方法，如果字段属性被声明为 final，则不会为该属性生成个 setter 方法。</p>
<h3 id="Getter-Setter"><a href="#Getter-Setter" class="headerlink" title="@Getter/@Setter"></a><code>@Getter</code>/<code>@Setter</code></h3><p><code>@Data</code> 包含了多种特性，可以单独在属性上注解，来获取 getter/setter 方法。</p>
<h3 id="NonNull"><a href="#NonNull" class="headerlink" title="@NonNull"></a><code>@NonNull</code></h3><p>该注解在属性或构造器上，Lombok 会生成一个非空的声明，可用于参数校验，可以避免空指针。</p>
<p><code>@NotNull</code> （Bean 的校验框架）注解用在指明一个参数、字段或者方法的返回值不可以为 null，是标准化的。<br><code>@NonNull</code> （缺陷检查框架）变量被其修饰时，IDE 会警告可能有崩溃的风险。这个是一个静态分析的方法，运行时不报任何警告。目前只有 IDEA 支持。</p>
<h3 id="Cleanup"><a href="#Cleanup" class="headerlink" title="@Cleanup"></a><code>@Cleanup</code></h3><p>可以帮我们自动调用 close() 方法。</p>
<pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Cleanup</span> InputStream in <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileInputStream</span><span class="token punctuation">(</span>args<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token annotation punctuation">@Cleanup</span> OutStream out <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileOutputStream</span><span class="token punctuation">(</span>args<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">byte</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">byte</span><span class="token punctuation">[</span><span class="token number">1000</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">while</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> r <span class="token operator">=</span> in<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>r<span class="token operator">==</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
        <span class="token keyword">break</span><span class="token punctuation">;</span>
    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token keyword">else</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
        out<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>b<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span>r<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>

<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">// 在函数签名中添加抛出的异常类型 IOException</span>
InputStream in <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileInputStream</span><span class="token punctuation">(</span>args<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">try</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
      OutputStream out <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileOutputStream</span><span class="token punctuation">(</span>args<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">try</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
        <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">byte</span><span class="token punctuation">[</span><span class="token number">10000</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
          <span class="token keyword">int</span> r <span class="token operator">=</span> in<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>
          <span class="token keyword">if</span> <span class="token punctuation">(</span>r <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span>
          out<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>b<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
      <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">finally</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>out <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
          out<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
      <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">finally</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>in <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
        in<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre>
<h3 id="EqualsAndHashCode"><a href="#EqualsAndHashCode" class="headerlink" title="@EqualsAndHashCode"></a><code>@EqualsAndHashCode</code></h3><p>默认情况下，会使用所有的非静态和非瞬态的属性来生成 equals 和 hashCode，也可以通过 exclude 注解来排除一些属性。</p>
<h3 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="@toString"></a><code>@toString</code></h3><p>注解在类上，Lombok 会为类生成一个 toString() 方法，默认情况下，会输出类名，所有属性（按照定义的属性顺序），用 <code>,</code> 隔开。</p>
<p><strong>待添加</strong>：对内部属性的使用场景。</p>
<h3 id="NoArgsConstructor-RequiredArgsConstructor-and-AllArgsConstructor"><a href="#NoArgsConstructor-RequiredArgsConstructor-and-AllArgsConstructor" class="headerlink" title="@NoArgsConstructor/@RequiredArgsConstructor and @AllArgsConstructor"></a><code>@NoArgsConstructor</code>/<code>@RequiredArgsConstructor</code> and <code>@AllArgsConstructor</code></h3><p>无参构造器，部分参数构造器，全参构造器。Lombok 无法实现多种参数构造器的重载。</p>
<h2 id="Lombok-的运行原理"><a href="#Lombok-的运行原理" class="headerlink" title="Lombok 的运行原理"></a>Lombok 的运行原理</h2><p>对注解解析的方式：</p>
<ol>
<li><strong>运行时解析</strong>：必须将 @Retention 设置为 RUNTIME，这样就可以通过反射拿到该注解，java.lang.reflect 反射包提供了一个接口</li>
<li><strong>编译时解析</strong>：编译时有两种，一种是 Annotation Processing Tool，另一种是 Pluggable Annotation API</li>
</ol>
<p>Lombok 使用的是编译时解析的第二种。</p>
<ul>
<li>javac对源代码进行分析，生成了一棵抽象语法树（AST）</li>
<li>运行过程中调用实现了“JSR 269 API”的Lombok程序</li>
<li>此时Lombok就对第一步骤得到的AST进行处理，找到@Data注解所在类对应的语法树（AST），然后修改该语法树（AST），增加getter和setter方法定义的相应树节点</li>
<li>javac使用修改后的抽象语法树（AST）生成字节码文件，即给class增加新的节点（代码块）</li>
</ul>
<h2 id="Lombok-的优缺点"><a href="#Lombok-的优缺点" class="headerlink" title="Lombok 的优缺点"></a>Lombok 的优缺点</h2><h3 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h3><ol>
<li>能通过注解的形式自动生成构造器、getter/setter、equals、hashcode、toString等方法，提高了一定的开发效率</li>
<li>让代码变得简洁，不用过多的去关注相应的方法</li>
<li>属性做修改时，也简化了维护为这些属性所生成的getter/setter方法等</li>
</ol>
<h3 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h3><ol>
<li>不支持多种参数构造器的重载</li>
<li>虽然省去了手动创建getter/setter方法的麻烦，但大大降低了源代码的可读性和完整性，降低了阅读源代码的舒适度。</li>
</ol>
<h5 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h5>]]></content>
      <tags>
        <tag>开发工具</tag>
      </tags>
  </entry>
  <entry>
    <title>utils-maven-gpg</title>
    <url>/blogs/utils-maven-gpg.html</url>
    <content><![CDATA[<h1 id="GPG-秘钥生成"><a href="#GPG-秘钥生成" class="headerlink" title="GPG 秘钥生成"></a>GPG 秘钥生成</h1><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢~~</p>
<pre class=" language-shell"><code class="language-shell">gpg --gen-key</code></pre>
<pre class=" language-shell"><code class="language-shell">gpg --list-keys</code></pre>
<h5 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h5>]]></content>
      <tags>
        <tag>开发工具</tag>
      </tags>
  </entry>
  <entry>
    <title>推送 jar 至 Maven 中心仓库</title>
    <url>/blogs/utils-maven-jar-pub-center.html</url>
    <content><![CDATA[<h1 id="推送-jar-至-Maven-中心仓库"><a href="#推送-jar-至-Maven-中心仓库" class="headerlink" title="推送 jar 至 Maven 中心仓库"></a>推送 jar 至 Maven 中心仓库</h1><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢~~</p>
<h2 id="一"><a href="#一" class="headerlink" title="一."></a>一.</h2><h5 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h5>]]></content>
      <tags>
        <tag>开发工具</tag>
      </tags>
  </entry>
  <entry>
    <title>使用 mvn -Dverbose dependency:tree 查看依赖树 - 解决依赖问题</title>
    <url>/blogs/utils-maven-mvn-dependency-tree.html</url>
    <content><![CDATA[<h1 id="使用-mvn-Dverbose-dependency-tree-查看依赖树-解决依赖问题"><a href="#使用-mvn-Dverbose-dependency-tree-查看依赖树-解决依赖问题" class="headerlink" title="使用 mvn -Dverbose dependency:tree 查看依赖树 - 解决依赖问题"></a>使用 mvn -Dverbose dependency:tree 查看依赖树 - 解决依赖问题</h1><h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢~~</p>
<p>使用 <code>mvn dependency:tree</code> 命令查看当前项目的依赖树，解决依赖问题。</p>
]]></content>
      <tags>
        <tag>开发工具</tag>
      </tags>
  </entry>
  <entry>
    <title>Maven Pom 坐标 classifier 作用</title>
    <url>/blogs/utils-maven-pom-classifier.html</url>
    <content><![CDATA[<h1 id="Maven-Pom-坐标-classifier-作用"><a href="#Maven-Pom-坐标-classifier-作用" class="headerlink" title="Maven Pom 坐标 classifier 作用"></a>Maven Pom 坐标 classifier 作用</h1><blockquote>
<ul>
<li>原文地址：<a href=""></a></li>
<li>原文作者：<a href=""></a></li>
<li>本文永久链接：<a href=""></a></li>
</ul>
</blockquote>
<h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a><strong>特别说明</strong></h5><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢 ~~</p>
]]></content>
      <tags>
        <tag>开发工具</tag>
      </tags>
  </entry>
  <entry>
    <title>utils-websit-op</title>
    <url>/blogs/utils-websit-op.html</url>
    <content><![CDATA[<h1 id="网站性能优化"><a href="#网站性能优化" class="headerlink" title="网站性能优化"></a>网站性能优化</h1><p>当前文章内容迁移中，如有问题，请提交 <a href="https://github.com/Starrier/starrier.github.io/issues">issues</a> 谢谢~~</p>
<h2 id="JPG，PNG-等替换为使用-webp"><a href="#JPG，PNG-等替换为使用-webp" class="headerlink" title="JPG，PNG 等替换为使用 webp"></a>JPG，PNG 等替换为使用 webp</h2><ol>
<li>下载 <code>cwebp</code></li>
</ol>
<pre class=" language-shell"><code class="language-shell">brew install cwebp</code></pre>
<ol start="2">
<li>在需要替换的目录下，执行替换命令</li>
</ol>
<pre class=" language-shell"><code class="language-shell">cwebp beian-log.png -o beian-log.webp</code></pre>
<ol start="3">
<li>使用 <code>html</code> 支持的标签，替换</li>
</ol>
]]></content>
      <tags>
        <tag>性能优化</tag>
      </tags>
  </entry>
</search>
