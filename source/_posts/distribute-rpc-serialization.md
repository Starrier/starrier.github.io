---
title: distribute-rpc-serialization
date: 2021-05-19 13:04:57
author: Starrier
tags: [分布式基础]
excerpt: RPC - 序列化
swiper:
keywords: [分布式,RPC,序列化]
description: RPC - 序列化
---

# RPC - 序列化

> * 原文地址：[]()
> * 原文作者：[]()
> * 本文永久链接：[]()

##### **特别说明**

当前文章内容迁移中，如有问题，请提交 [issues](https://github.com/Starrier/starrier.github.io/issues) 谢谢 ~~

## 概述

将内存对象转化为字节流的过程。相对的是反序列化，即将字节流转化为内存对象的过程。

TCP/IP协议是一个四层协议，而OSI模型却是七层协议模型。在OSI七层协议模型中展现层（Presentation Layer）的主要功能是把应用层的对象转换成一段连续的二进制串，或者反过来，把二进制串转换成应用层的对象–这两个功能就是序列化和反序列化。一般而言，TCP/IP协议的应用层对应与OSI七层协议模型的应用层，展示层和会话层，所以序列化协议属于TCP/IP协议应用层的一部分。

## 为什么要序列化

将数据存入文件或者通过网络进行发送，就需要将数据对象转化为字节流。

而究竟如何进行序列化，则需要考虑各种因素，比如性能、占用空间、向前向后的兼容性、多语言支持等等。

## 常见的序列化方案

使用字符串进行编码，不同字段间指定分隔符，比如 “,” 或者 “|” 等。
优点是简单，缺点是不能表达嵌套格式、图片等二进制文件，数据结构变更可能导致读写代码的修改。

2. 使用特定语言的序列化模块，比如 Java Serialization 等。

这种方式可以表达复杂的对象，对于嵌套格式更是不在话下，但是由于与语言绑定，无法做到跨语言支持。

3. 使用通用的语言格式，比如 JSON、XML

这种方式存在重复的 key，并且对于二进制支持不够，需要 base64 等特殊处理。

4. 当上述 3 种方式的缺点严重阻碍你的应用时，则需要考虑自定义的序列化工具了。这个时候我们希望有一种方法，可以约束每个字段类型，并且提供数据的解析功能。这种带有 schema 的数据格式，常见的有 Thrift、Protobuf、Avro 等。此类序列化框架通常具有以下特征：

提供 IDL（Interface Description language）描述数据格式
支持跨语言交互，比如使用 Java 开发服务端，Python 作为客户端读取数据
数据编码存储，对数据进行压缩等处理，尽可能减少存储占用
支持 schema 的演化，即按照一定规则修改 schema，同时保证读写模块的向前向后的兼容性


> 注意 
> 常见的序列化框架有 Thrift、Protobuf、Avro，而由于 Thrift、Avro 可以生成 RPC 实现，所以当提到如 Thrift 服务这种说法时一般指的是 Thrift 实现的 RPC 服务端。而 Protobuf 没有 RPC 实现，所以指的就是序列化与反序列化操作，一般会结合 gRPC 来进行 RPC 实现。




参考文章

https://zhuanlan.zhihu.com/p/206625402
